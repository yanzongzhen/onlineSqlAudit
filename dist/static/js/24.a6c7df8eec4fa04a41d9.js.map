{"version":3,"sources":["webpack:///static/js/24.a6c7df8eec4fa04a41d9.js","webpack:///./~/emmet/emmet.js","webpack:///./~/base64-js/index.js","webpack:///./~/buffer/index.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js"],"names":["webpackJsonp","181","module","exports","__webpack_require__","process","Buffer","global","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","require","e","val","define","outer","modules","cache","entry","newRequire","name","jumped","currentRequire","previousRequire","err","Error","code","m","call","x","id","i","length","./bundles/snippets.js","res","snippets","setVocabulary","../lib/assets/resources","../lib/snippets.json","./lib/emmet.js","factory","getFileName","path","re","exec","normalizeProfile","profile","indent","self_closing_tag","self","this","utils","actions","parser","file","preferences","resources","ciu","logger","sliceFn","Array","prototype","slice","expandAbbreviation","abbr","syntax","contextNode","expand","run","apply","arguments","loadExtensions","fileList","payload","userSnippets","that","filter","f","ext","getExt","reader","readText","read","bind","next","shift","content","log","eval","fileName","toLowerCase","replace","parseJSON","test","deepMerge","loadUserData","loadPreferences","data","load","loadSnippets","userData","getVocabulary","loadSystemSnippets","loadCIU","resetSnippets","profiles","loadProfiles","caniuse","syntaxProfiles","syntaxprofiles","loadSyntaxProfiles","resetUserData","reset","Object","keys","forEach","options","create","tabStops","htmlMatcher","common","action","editor","./action/main","./assets/caniuse","./assets/htmlMatcher","./assets/logger","./assets/preferences","./assets/profile","./assets/resources","./assets/tabStops","./parser/abbreviation","./plugin/file","./utils/action","./utils/common","./utils/editor","action\\balance.js","last","arr","balanceHTML","direction","info","editorUtils","outputInfo","sel","range","getSelectionRange","lastMatch","equal","type","close","outerRange","innerRange","narrowed","narrowToNonSpace","find","start","createSelection","end","rangesForCSSRule","rule","pos","ranges","push","valueRange","nestedSections","cssSections","nestedSectionsInRule","items","list","Number","POSITIVE_INFINITY","namePosition","create2","concat","prop","cssEditTree","propertyFromPosition","_unterminated","getCSSRanges","ruleRange","matchEnclosingRule","parse","substring","offset","item","unique","valueOf","balanceCSS","sort","bestMatch","r","include","inside","bestMatchIx","indexOf","outerRanges","actionUtils","balance","String","isSupportedCSS","balanceInwardAction","balanceOutwardAction","goToMatchingPairAction","getContent","caretPos","getCaretPos","charAt","tag","open","setCaretPos","../assets/htmlMatcher","../assets/range","../editTree/css","../utils/action","../utils/common","../utils/cssSections","../utils/editor","action\\base64.js","startsWith","token","text","substr","encodeToBase64","imgPath","editorFile","getFilePath","locateFile","realImgPath","b64","base64","encode","mimeTypes","replaceContent","decodeFromBase64","filePath","prompt","createPath","absPath","save","decode","encodeDecodeDataUrlAction","filepath","getSelection","match","../plugin/file","../utils/base64","action\\editPoints.js","findNewEditPoint","inc","curPoint","maxLen","nextPoint","reEmptyLine","curChar","nextChar","prevChar","ix","c","previousEditPointAction","curPos","newPoint","nextEditPointAction","action\\evaluateMath.js","math","evaluateMathAction","findExpressionBounds","ch","isNumeric","expr","result","prettifyNumber","evaluate","../utils/math","action\\expandAbbreviation.js","findAbbreviation","curLine","getCurrentLineRange","extractAbbreviation","handlerList","prefs","cssGradient","handlers","add","captureContext","replaceFrom","replaceTo","cssSyntaxes","getArray","order","expandAbbreviationHandler","expandAbbreviationAction","args","toArray","expandAbbreviationWithTabAction","selRange","padString","replaceRange","_defaultHandler","ctx","addHandler","fn","removeHandler","remove","../assets/handlerList","../assets/preferences","../parser/abbreviation","../resolver/cssGradient","action\\incrementDecrement.js","intLength","num","split","increment01Action","incrementNumber","increment1Action","increment10Action","decrement01Action","decrement1Action","decrement10Action","step","hasSign","hasDecimal","strNum","parseFloat","isNaN","minus","RegExp","$1","parts","zeroPadString","join","action\\lineBreaks.js","xmlSyntaxes","insertLineBreakAction","insertLineBreakOnlyAction","curPadding","getCurrentLinePadding","len","lineRange","nextPadding","nl","getCaretPlaceholder","append","get","hasCloseBrace","il","insValue","../assets/resources","action\\main.js","addAction","label","humanizeActionName","trim","toUpperCase","str","actionModules","editPoints","evaluateMath","incrementDecrement","lineBreaks","mergeLines","reflectCSSValue","removeTag","selectItem","selectLine","splitJoinTag","toggleComment","updateImageSize","wrapWithAbbreviation","updateTag","method","hidden","prefix","suffix","Math","abs","actionId","actionMethod","actionLabel","isArray","getAll","getList","all","map","key","getMenu","skipActions","actionName","pop","menuName","submenu","getActionNameForMenuTitle","title","menu","./balance","./base64","./editPoints","./evaluateMath","./expandAbbreviation","./incrementDecrement","./lineBreaks","./mergeLines","./reflectCSSValue","./removeTag","./selectItem","./selectLine","./splitJoinTag","./toggleComment","./updateImageSize","./updateTag","./wrapWithAbbreviation","action\\mergeLines.js","mergeLinesAction","selection","pair","lines","splitByLines","textLen","escapeText","action\\reflectCSSValue.js","doCSSReflection","cssRule","parseFromPosition","property","itemFromPosition","oldRule","source","caretDelta","caret","getReflectedCSSName","baseName","vendorPrefix","reflectValueParts","value","reVendor","propPrefix","findParts","reverse","part","partValue","prefixes","cssResolver","vendorPrefixes","replaceSubstring","reflectValue","donor","receiver","getReflectedValue","curName","curValue","refName","refValue","floor","parseInt","reflectCSSValueAction","getSyntax","compoundUpdate","reName","parent","p","reflectValueHandler","../resolver/css","action\\removeTag.js","removeTagAction","tagContentRange","startLineBounds","findNewlineBounds","startLinePad","getLinePadding","tagContent","unindentString","action\\selectItem.js","findItem","isBackward","extractFn","rangeFn","itemRange","rng","contentLength","prevRange","searchPos","loop","clone","findNextHTMLItem","isFirst","findOpeningTagFromPosition","getOpeningTagFromPosition","getRangeForHTMLItem","findPrevHTMLItem","makePossibleRangesHTML","tokens","attrValueRange","tagName","attrStart","attrName","attrValue","tok","isQuote","classNameRanges","toString","className","stream","stringStream","eatSpace","xmlParser","curRange","matchedRanges","html","startTag","findInnerRanges","nameRange","section","_selectorEnd","makePossibleRangesCSS","valueParts","backUp","skipToPair","fnBody","current","matchedRangeForCSSProperty","nested","a","b","findNextCSSItem","locateRule","getRangeForNextItemInCSS","findPrevCSSItem","getRangeForPrevItemInCSS","selectNextItemAction","selectPreviousItemAction","../assets/stringStream","../parser/xml","action\\selectLine.js","selectLineAction","action\\splitJoinTag.js","joinTag","slash","selfClosing","splitTag","tag_nl","outerContent","matcher","splitJoinTagAction","profileName","curProfile","../assets/profile","action\\toggleComment.js","toggleHTMLComment","genericCommentToggle","toggleCSSComment","cssItemFromPosition","absPos","relPos","reSafeChar","searchComment","from","startToken","endToken","commentStart","commentEnd","hasMatch","contentLen","newContent","commentRange","overlap","escapeForRegexp","unindent","toggleCommentAction","action\\updateImageSize.js","updateImageSizeHTML","xmlElem","xmlEditTree","getImageSizeForSource","size","compoundData","width","height","extend","updateImageSizeCSS","src","callback","fileContent","getImageSize","updateImageSizeAction","../editTree/xml","action\\updateTag.js","updateAttributes","abbrNode","classNames","attribute","replaceCounter","counter","addClass","removeClass","attributeList","attr","tagAttr","updateTagAction","getUpdatedTag","tree","children","node","el","action\\wrapWithAbbreviation.js","wrapWithAbbreviationAction","pastedContent","assets\\caniuse.js","intersection","arr1","arr2","smaller","larger","parseDB","optimized","JSON","optimize","vendorsDB","vendors","cssDB","css","erasDB","era","parseVendors","parseCSS","parseEra","out","agents","agent","versions","cats","CSS","kw","stats","eras","getVendorsList","allVendors","getVersionSlice","border-image","css-boxshadow","css3-boxsizing","multicolumn","border-radius","transforms2d","css-hyphens","css-transitions","font-feature","css-animation","css-gradients","css-masks","css-featurequeries","flexbox","calc","object-fit","css-grid","css-repeating-gradients","css-filters","user-select-none","intrinsic-width","css3-tabsize","db","amd","resolvePrefixes","propStats","vendor","v","vendorVesions","./preferences","assets\\elements.js","commonFactory","factories","reAttrs","elem","is","elementName","attrs","isEmpty","ret","is_empty","attributes","isDefault","isImplied","assets\\handlerList.js","HandlerList","_list","splice","listFn","skipValue","h","assets\\htmlMatcher.js","openTag","selfClose","closeTag","comment","createMatcher","memo","matches","reOpenTag","reCloseTag","clean","pattern","findClosingPair","stack","j","found","jl","cmp","contains","_c","innerContent","./range","assets\\logger.js","console","assets\\preferences.js","toBoolean","isValueObj","obj","defaults","_dbgDefaults","_dbgPreferences","description","k","set","getDict","json","exportModified","_startTest","_stopTest","assets\\profile.js","OutputProfile","defaultProfile","stringCase","caseValue","createProfile","createDefaultProfiles","compact_bool","place_cursor","extraFilters","tag_case","attr_case","attr_quotes","tag_nl_leaf","inline_break","filters","attributeName","attributeQuote","cursor","isBoolean","boolAttrs","allowCompactBoolean","plain","./resources","assets\\range.js","op","Range","min","max","delta","union","loc","left","right","isRange","assets\\resources.js","each","normalizeCaretPlaceholder","replaceUnescapedSymbol","parseItem","elements","parseAbbreviation","reTag","normalizeName","expandSnippetsDefinition","stringScore","systemSettings","userSettings","resolvers","voc","_section","subsection","getMatchedResource","findSnippet","getVariable","getSection","setVariable","variables","hasSyntax","addResolver","removeResolver","subsections","topSection","names","matchedItem","some","sectionName","n","fuzzyFindSnippet","minScore","fuzzyFindMatches","parsedValue","getAllSnippets","score","nk","cacheKey","sectionKey","stackItem","getNewline","setNewline","resolve","../assets/logger","../vendor/stringScore","./elements","./handlerList","assets\\stringStream.js","StringStream","string","_length","eol","sol","peek","eat","eatWhile","skipToEnd","skipTo","skipString","braceCount","skipQuoted","noBackup","quote","consume","caseInsensitive","cased","assets\\tabStops.js","startPlaceholderNum","tabstopIndex","defaultOptions","replaceCarets","escape","tabstop","variable","extract","placeholders","carets","marks","placeholder","group","processText","buf","lastIx","mark","ph","tabstops","upgrade","maxNum","variablesResolver","placeholderMemo","varName","varValue","replaceVariables","vars","resolver","p1","newValue","resetTabstopIndex","abbrOutputProcessor","tsOptions","./stringStream","assets\\tokenIterator.js","TokenIterator","_position","hasNext","_i","_il","position","itemNext","itemPrev","nextUntil","t","editTree\\base.js","EditContainer","_children","_positions","initialize","EditElement","nameToken","valueToken","_name","_value","klass","_pos","isAbsolute","_updateSource","update","recursiveUpdate","indexes","element","fullRange","values","valuePosition","createToken","../vendor/klass","editTree\\css.js","trimWhitespaceInRange","mask","WHITESPACE_REMOVE_FROM_START","WHITESPACE_REMOVE_FROM_END","reSpaceStart","reSpaceEnd","consumeSingleProperty","it","ws","white","line","isAtProperty","lastNewline","sep","consumeProperties","extractPropertiesFromSource","CSSEditElement","editTree","nameText","valueText","endText","cssParser","tokenIterator","styleBefore","styleSeparator","CSSEditContainer","toSource","allRules","findAllRules","currentRule","topLevelRules","tr","selectorRange","contentStart","_contentStart","sectionOffset","_saveStyle","styles","pick","_end","isUpdating","allItems","isIncomplete","constructor","__super__","bounds","cssProp","../assets/tokenIterator","../parser/css","./base","editTree\\xml.js","styleQuote","XMLEditContainer","attrToken","XMLEditElement","classVal","reClass","extractTag","filter\\bem.js","getSeparators","modifier","bemParse","abbreviationUtils","isSnippet","__bem","block","normalizeClassName","reBlockName","processClassName","flatten","shortSymbol","repeatString","transformClassName","separators","modifiers","blockModifiers","entityType","reSep","depth","cleanName","shouldRunHtmlFilter","htmlFilter","../utils/abbreviation","./html","filter\\comment.js","addComments","templateBefore","templateAfter","trigger","padding","before","after","nodeBefore","nodeAfter","abbrUtils","isBlock","template","../utils/template","./main","filter\\css.js","isVeryFirstChild","index","level","filter\\escape.js","escapeChars","charMap","<",">","&","filter\\format.js","getIndentation","hasBlockSibling","hasBlockChildren","shouldAddLineBreak","shouldFormatInline","shouldBreakChild","nodeCount","child","isTextNode","isInline","isRoot","processSnippet","shouldBreakInsideInline","processTag","isUnary","forceNl","hasTagsInContent","filter\\haml.js","condenseDataAttrs","reData","stringifyAttrs","attrQuote","makeAttributesString","otherAttrs","formatFilter","./format","filter\\html.js","../assets/tabStops","filter\\jade.js","processTagContent","reNl","reIndentedText","reSpace","filter\\jsx.js","attrMap","class","for","_attributes","filter\\main.js","registeredFilters","haml","jade","jsx","slim","xsl","bem","s","composeList","additionalFilters","./bem","./comment","./css","./escape","./haml","./jade","./jsx","./singleLine","./slim","./trim","./xsl","filter\\singleLine.js","rePad","filter\\slim.js","getAttrWrapper","attrWrap","filter\\trim.js","filter\\xsl.js","trimAttribute","tags","xsl:variable","xsl:with-param","generator\\lorem.js","randint","to","round","random","sample","count","iterations","randIx","choice","sentence","words","insertCommas","totalCommas","word","paragraph","lang","wordCount","startWithCommon","langs","totalWords","en","sp","ru","addLang","preprocessor","allowCommon","findAll","wordCound","isRepeating","parser\\abbreviation.js","AbbreviationNode","abbreviation","_text","repeatCount","hasImplicitRepeat","_data","stripped","multiplier","root","context","addChild","loopProtector","inner","_setRepeat","pairs","isMarker","isAllowedChar","setAbbreviation","splitAttributes","attrSet","unquote","extractAttributes","reAttrName","DEFAULT_ATTR_NAME","parseAttributes","#",".","nameEnd","reWord","optimizeAttributes","lookup","la","extractText","unroll","maxCount","updateProperty","squash","isGroup","charCode","charCodeAt","lorem","procPastedContent","procTagName","procResourceMatcher","procAttributes","procHref","reValidName","[","(","{","spliceFn","preprocessors","postprocessors","outputProcessors","amount","state","elemName","vals","attrNames","abbrText","abbrAttrs","insertChildContent","keepVariable","hasEmptyChildren","hasImplicitName","isElement","deepestChild","mod","postprocessor","attrLookup","defaultSyntax","outputTree","filtersList","addPreprocessor","removeFilter","addPostprocessor","removePostprocessor","addOutputProcessor","removeOutputProcessor","../filter/main","../generator/lorem","./processor/attributes","./processor/href","./processor/pastedContent","./processor/resourceMatcher","./processor/tagName","parser\\css.js","isNameChar","cc","isDigit","tokener","session","getPosInfo","w","errPos","chnum","fullLine","formattedLine","chunkSize","hint","raiseError","message","error","errObj","walker","cnext","eatString","q","brace","stop","identifier","pre","nondigit","point","isOp","tokenize","init","opsa","opsmatcha","ops","opsmatch","matchattr","lex","toks","parser\\processor\\attributes.js","resolveDefaultAttrs","attrList","defaultAttrValue","defaultAttr","findDefault","findImplied","findEmpty","oldVal","newVal","../../utils/common","parser\\processor\\href.js","pc","reUrl","reEmail","reProto","../../assets/preferences","./pastedContent","parser\\processor\\pastedContent.js","locateOutputPlaceholder","outputPlaceholder","replaceOutputPlaceholders","hasOutputPlaceholder","insertPastedContent","overwrite","nodesWithPlaceholders","unshift","deepest","../../assets/range","../../assets/stringStream","../../utils/abbreviation","parser\\processor\\resourceMatcher.js","matchResources","elemType","curContent","subtree","repeatedChildren","../../assets/elements","../../assets/resources","parser\\processor\\tagName.js","resolveNodeNames","../../resolver/tagName","parser\\xml.js","inText","chain","inBlock","doctype","inTag","ok","inAttribute","style","terminator","pass","curState","cont","pushContext","startOfLine","noIndent","Kludges","doNotIndent","hasOwnProperty","prev","indented","popContext","endtag","implicitlyClosed","setStyle","endclosetag","autoSelfClosers","maybePopContext","callee","nextTagName","parentTagName","contextGrabbers","attvalue","allowMissing","attvaluemaybe","allowUnquoted","startState","comb","plugin\\file.js","bts","bytes","fromCharCode","isURL","_transport","fs","http","https","_parseParams","params","_read","req","bufs","totalLength","finished","on","chunk","abort","fd","openSync","bytesRead","readFileSync","dirname","existsSync","stat","isFile","writeFile","resolver\\css.js","isSingleProperty","snippet","normalizeValue","normalizeHexColor","getKeyword","hex","opacity","repeat","color","toRgba","aliases","getUnit","isValidKeyword","keyword","hasPrefix","supports","findVendorPrefixes","findInternalPrefixes","noAutofill","prefixMap","obsolete","addPrefix","prefixObj","getSyntaxPreference","formatProperty","transformSnippet","isImportant","getProperties","addon","without","resolvePrefixedValues","snippetObj","transformName","properties","descTemplate","descAddonTemplate","props","webkit","moz","ms","o","supportsPrefix","expandToSnippet","prefixed","listPrefixes","getPrefix","removePrefix","extractPrefixes","findValuesInAbbreviation","keywords","lastPart","parseValues","extractValues","abbrValues","unitlessProps","unit","autoInsertPrefixes","prefixData","valuesData","abbrData","endsWith","splitSnippet","propName","pads","getStringsPads","../assets/caniuse","resolver\\cssGradient.js","resolvePropertyName","getGradientPrefixes","getPropertiesForGradient","gradients","propertyName","omitDir","gradient","colorStops","insertGradientsIntoCSSValue","oldWebkit","omitDefaultDirection","stringifyOldWebkit","stringify","matchedPart","similarPropertyNames","similarProps","pasteGradient","alignVendor","propsToInsert","valuePads","namePads","isValidCaretPosition","linearGradient","findGradients","isLinearGradient","gradientsFromCSSProperty","grd","cssProperty","ruleStart","ruleEnd","insertPos","_gradients","resolvedName","expandGradientOutsideValue","pad","fakeCSS","localGradients","localValue","dfn","./gradient/linear","resolver\\gradient\\linear.js","LinearGradient","cur","reDeg","reKeyword","addColorStop","resolveDirection","normalizeSpace","dir","top","bottom","directions","stringifyDirection","oldStyle","reNewStyle","oldWebkitDirection","bottom left","top left","top right","bottom right","to top","to top right","to right","to bottom right","to bottom","to bottom left","to left","to top left","defaultDirections","reLinearGradient","parseColorStop","colorStop","cs","_fillImpliedPositions","toFixed","cs2","resolver\\tagName.js","elementTypes","empty","blockLevel","inlineLevel","elementMap","ul","ol","table","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","getMapping","isInlineLevel","isTypeOf","isBlockLevel","isEmptyElement","addMapping","removeMapping","addElementToCollection","collection","col","getCollection","removeElementFromCollection","snippets.json","locale","charset","indentation","newline","@i","@import","@m","@media","@f","@f+","@kf","anim","anim-","animdel","animdir","animdir:n","animdir:r","animdir:a","animdir:ar","animdur","animfm","animfm:f","animfm:b","animfm:bt","animfm:bh","animic","animic:i","animn","animps","animps:p","animps:r","animtf","animtf:e","animtf:ei","animtf:eo","animtf:eio","animtf:l","animtf:cb","ap","!","pos:s","pos:a","pos:r","pos:f","t:a","r:a","b:a","l","l:a","z","z:a","fl","fl:n","fl:l","fl:r","cl","cl:n","cl:l","cl:r","cl:b","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","d","d:n","d:b","d:f","d:if","d:i","d:ib","d:ib+","d:li","d:ri","d:cp","d:tb","d:itb","d:tbcp","d:tbcl","d:tbclg","d:tbhg","d:tbfg","d:tbr","d:tbrg","d:tbc","d:rb","d:rbb","d:rbbg","d:rbt","d:rbtg","v:v","v:h","v:c","ov","ov:v","ov:h","ov:s","ov:a","ovx","ovx:v","ovx:h","ovx:s","ovx:a","ovy","ovy:v","ovy:h","ovy:s","ovy:a","ovs","ovs:a","ovs:s","ovs:p","ovs:m","ovs:mq","zoo","zm","cp","cp:a","cp:r","bxz","bxz:cb","bxz:bb","bxsh","bxsh:r","bxsh:ra","bxsh:n","m:a","mt","mt:a","mr","mr:a","mb","mb:a","ml","ml:a","pt","pr","pb","pl","w:a","h:a","maw","maw:n","mah","mah:n","miw","mih","mar","mir","ori","ori:l","ori:p","ol:n","olo","olw","olw:tn","olw:m","olw:tc","ols","ols:n","ols:dt","ols:ds","ols:s","ols:db","ols:g","ols:r","ols:i","ols:o","olc","olc:i","bfv","bfv:h","bfv:v","bd","bd+","bd:n","bdbk","bdbk:c","bdcl","bdcl:c","bdcl:s","bdc","bdc:t","bdi","bdi:n","bdti","bdti:n","bdri","bdri:n","bdbi","bdbi:n","bdli","bdli:n","bdci","bdci:n","bdci:c","bdtli","bdtli:n","bdtli:c","bdtri","bdtri:n","bdtri:c","bdbri","bdbri:n","bdbri:c","bdbli","bdbli:n","bdbli:c","bdf","bdf:c","bdf:r","bdf:sc","bdf:st","bdf:ow","bdf:of","bdf:sp","bdlen","bdlen:a","bdsp","bds","bds:n","bds:h","bds:dt","bds:ds","bds:s","bds:db","bds:dtds","bds:dtdtds","bds:w","bds:g","bds:r","bds:i","bds:o","bdw","bdtw","bdrw","bdbw","bdlw","bdt","bt","bdt+","bdt:n","bdts","bdts:n","bdtc","bdtc:t","bdr","br","bdr+","bdr:n","bdrst","bdrst:n","bdrc","bdrc:t","bdb","bb","bdb+","bdb:n","bdbs","bdbs:n","bdbc","bdbc:t","bdl","bl","bdl+","bdl:n","bdls","bdls:n","bdlc","bdlc:t","bdrs","bdtrrs","bdtlrs","bdbrrs","bdblrs","bg","bg+","bg:n","bg:ie","bgc","bgc:t","bgi","bgi:n","bgr","bgr:n","bgr:x","bgr:y","bgr:sp","bgr:rd","bga","bga:f","bga:s","bgp","bgpx","bgpy","bgbk","bgbk:bb","bgbk:eb","bgbk:c","bgcp","bgcp:bb","bgcp:pb","bgcp:cb","bgcp:nc","bgo","bgo:pb","bgo:bb","bgo:cb","bgsz","bgsz:a","bgsz:ct","bgsz:cv","c:r","c:ra","cm","cnt","cnt:n","cnt:oq","cnt:noq","cnt:cq","cnt:ncq","cnt:a","cnt:c","cnt:cs","tbl","tbl:a","tbl:f","cps","cps:t","cps:b","ec","ec:s","ec:h","lis","lis:n","lisp","lisp:i","lisp:o","list:n","list:d","list:c","list:s","list:dc","list:dclz","list:lr","list:ur","lisi","lisi:n","q:n","q:ru","q:en","ct","ct:n","ct:oq","ct:noq","ct:cq","ct:ncq","ct:a","ct:c","ct:cs","coi","cor","va","va:sup","va:t","va:tt","va:m","va:bl","va:b","va:tb","va:sub","ta","ta:l","ta:c","ta:r","ta:j","ta-lst","tal:a","tal:l","tal:c","tal:r","td","td:n","td:u","td:o","td:l","te","te:n","te:ac","te:dt","te:c","te:ds","te:b","te:a","th","th:a","th:f","th:t","th:m","ti","ti:-","tj","tj:a","tj:iw","tj:ii","tj:ic","tj:d","tj:k","tj:t","tov","tov:e","tov:c","to+","to:n","tr:n","tt","tt:n","tt:c","tt:u","tt:l","tw","tw:n","tw:no","tw:u","tw:s","tsh","tsh:r","tsh:ra","tsh+","tsh:n","trf","trf:skx","trf:sky","trf:sc","trf:scx","trf:scy","trf:scz","trf:sc3","trf:r","trf:rx","trf:ry","trf:rz","trf:t","trf:tx","trf:ty","trf:tz","trf:t3","trfo","trfs","trs","trsde","trsdu","trsp","trstf","lh","whs","whs:n","whs:p","whs:nw","whs:pw","whs:pl","whsc","whsc:n","whsc:k","whsc:l","whsc:bs","whsc:ba","wob","wob:n","wob:k","wob:ba","wos","wow","wow:nm","wow:n","wow:u","wow:s","wow:b","wm","wm:lrt","wm:lrb","wm:rlt","wm:rlb","wm:tbr","wm:tbl","wm:btl","wm:btr","lts","lts-n","f+","fw","fw:n","fw:b","fw:br","fw:lr","fs:n","fs:i","fs:o","fv","fv:n","fv:sc","fz","fza","fza:n","ff","ff:s","ff:ss","ff:c","ff:f","ff:m","ff:a","ff:t","ff:v","fef","fef:n","fef:eg","fef:eb","fef:o","fem","femp","femp:b","femp:a","fems","fems:n","fems:ac","fems:dt","fems:c","fems:ds","fsm","fsm:a","fsm:n","fsm:aw","fst","fst:n","fst:uc","fst:ec","fst:c","fst:sc","fst:se","fst:e","fst:ee","fst:ue","op+","op:ie","op:ms","rsz","rsz:n","rsz:b","rsz:h","rsz:v","cur:a","cur:d","cur:c","cur:ha","cur:he","cur:m","cur:p","cur:t","fxd","fxd:r","fxd:rr","fxd:c","fxd:cr","fxw","fxw:n","fxw:w","fxw:wr","fxf","jc","jc:fs","jc:fe","jc:c","jc:sb","jc:sa","ai","ai:fs","ai:fe","ai:c","ai:b","ai:s","ac","ac:fs","ac:fe","ac:c","ac:sb","ac:sa","ac:s","ord","fxg","fxsh","fxb","fx","as","as:a","as:fs","as:fe","as:c","as:b","as:s","pgbb","pgbb:au","pgbb:al","pgbb:l","pgbb:r","pgbi","pgbi:au","pgbi:av","pgba","pgba:au","pgba:al","pgba:l","pgba:r","orp","us","wid","wfsm","wfsm:a","wfsm:s","wfsm:sa","wfsm:n","!!!","!!!4t","!!!4s","!!!xt","!!!xs","!!!xxs","cc:ie6","cc:ie","cc:noie","abbreviations","a:link","a:mail","acr|acronym","base","basefont","frame","hr","bdo","bdo:r","bdo:l","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","link:im|link:import","meta","meta:utf","meta:win","meta:edge","meta:vp","meta:compat","meta:redirect","script","script:src","img","img:s|img:srcset","img:z|img:sizes","picture","src|source","src:sc|source:src","src:s|source:srcset","src:m|source:media","src:t|source:type","src:z|source:sizes","src:mt|source:media:type","src:mz|source:media:sizes","src:zt|source:sizes:type","iframe","embed","param","area","area:d","area:c","area:r","area:p","form","form:get","form:post","input","inp","input:h|input:hidden","input:t|input:text","input:search","input:email","input:url","input:p|input:password","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:tel","input:number","input:color","input:c|input:checkbox","input:r|input:radio","input:range","input:f|input:file","input:s|input:submit","input:i|input:image","input:b|input:button","isindex","input:reset","select:d|select:disabled","opt|option","textarea","marquee","menu:c|menu:context","menu:t|menu:toolbar","html:xml","keygen","command","btn:s|button:s|button:submit","btn:r|button:r|button:reset","btn:d|button:d|button:disabled","fst:d|fset:d|fieldset:d|fieldset:disabled","bq","fig","figc","pic","ifr","emb","cap","colg","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","doc","doc4","ri:d|ri:dpr","ri:v|ri:viewport","ri:a|ri:art","ri:t|ri:type","html:4t","html:4s","html:xt","html:xs","html:xxs","html:5","ol+","ul+","dl+","map+","table+","colgroup+","colg+","tr+","select+","optgroup+","optg+","pic+","xml","extends","svg","svgdoc","!svg","ag","agd","agi","anim|animate","am","at","c-p","df","e|ellipse","fff","ffn","ffs","ffu","fo","g","gl","glr","hk","i|image","lg","marker","md","mg","mp","patt","pg","rg","scr","sb","txt","tp","ts","u|use","vk","tm|tmatch","tn|tname","api","imp","wh|xsl:when","ot","if","par","pare","var","vare","wp","co","for|each","tex","com","msg","fall","nam","pres","strip","proc","choose+","scss","sass","less","stylus","styl","utils\\abbreviation.js","matchesTag","childContent","appendIfNoChild","childVariableReplaced","output","getLinePaddingFromPosition","../assets/elements","../resolver/tagName","utils\\action.js","abbreviationParser","gif","png","jpg","jpeg","htm","curOffset","startIndex","groupCount","textCount","endsWithTag","nextByte","allowedSyntaxes","tagTree","exprStart","exprEnd","detectSyntax","isStyle","isInlineCSS","detectProfile","isXHTML","search","styleTagRange","styleAttrRange","./common","./cssSections","utils\\base64.js","chars","chr1","chr2","chr3","enc1","enc2","enc3","enc4","cdp1","cdp2","cdp3","o1","o2","o3","h1","h2","h3","h4","bits","tmpArr","utils\\comments.js","reHasComment","ch2","replaceRanges","replaceWith","utils\\common.js","caretPlaceholder","removeEmpty","howMany","strings","lengths","reduce","symbol","sl","matchCount","curSl","replaceData","total","matchNum","decrement","unescapeText","setCaretPlaceholder","specials","fraction","noRepeat","fragments","repl","copy","copyIsArray","target","undefined","comparator","sliceIx","utils\\cssSections.js","getId","idCounter","maxId","CSSSection","nextSibling","previousSibling","_source","_content","commentsUtils","reSpaceTrim","lastChild","matchDeep","allRanges","sanitize","saveRule","extractSelector","matchBracesRanges","endPos","selector","rules","subrange","ctxRule","sectionTree","insert","./comments","utils\\editor.js","isInsideTag","getProfileName","getCurrentLine","normalize","tabs","space","utils\\math.js","F","Token","type_","index_","prio_","number_","TNUMBER","TOP1","TOP2","TVAR","TFUNCALL","Expression","ops1","ops2","functions","escapeValue","escapable","lastIndex","sub","mul","div","neg","fac","pyt","sqrt","Parser","success","errormsg","expression","tokennumber","tokenprio","tokenindex","tmpprio","sin","cos","tan","asin","acos","atan","ceil","-","exp","+","*","/","%","^","pow",",","||","atan2","consts","E","PI","\b","\t","\n","\f","\r","'","\\","simplify","n1","n2","nstack","newexpression","L","substitute","expritem","replitem","toJS","toJSFunction","Function","operstack","tokenstack","expected","noperators","isOperator","isSign","isNegativeSign","addfunc","isComment","error_parsing","isNumber","isString","isLeftParenth","isRightParenth","isComma","isConst","consttoken","isOp2","isOp1","isVar","vartoken","isWhite","tmp","column","operator","unescape","buffer","escaping","codePoint","startpos","isPositiveSign","utils\\template.js","parseArgs","parseFunctionCall","fnName","evalArg","arg","fnArgs","vendor\\klass.js","inherits","protoProps","staticProps","ctor","classProps","vendor\\stringScore.js","fuzziness","start_of_string_bonus","abbreviation_score","final_score","character_score","index_in_string","index_c_lowercase","index_c_uppercase","min_index","total_character_score","abbreviation_length","string_length","fuzzies","window","emmet","318","getLens","validLen","byteLength","lens","placeHoldersLen","_byteLength","toByteArray","Arr","curByte","revLookup","tripletToBase64","encodeChunk","uint8","fromByteArray","extraBytes","len2","Uint8Array","319","kMaxLength","TYPED_ARRAY_SUPPORT","createBuffer","RangeError","__proto__","encodingOrOffset","allocUnsafe","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","alloc","fill","encoding","checked","isEncoding","actual","write","fromArrayLike","array","byteOffset","isBuffer","isnan","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","arrayIndexOf","lastIndexOf","indexSize","readUInt16BE","arrLength","valLength","foundIndex","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","firstByte","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","toHex","checkOffset","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","units","Infinity","leadSurrogate","byteArray","hi","lo","dst","INSPECT_MAX_BYTES","foo","subarray","poolSize","_augment","Symbol","species","defineProperty","configurable","allocUnsafeSlow","_isBuffer","compare","y","swap16","swap32","swap64","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","sliceLen","readUIntLE","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","624","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","rt","LN2","625"],"mappings":"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","file":"static/js/24.a6c7df8eec4fa04a41d9.js","sourcesContent":["webpackJsonp([24],{\n\n/***/ 181:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;!function(e){var val=e(); if(true)module.exports=val;if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (val),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.emmet=val}}(function(){var define,module,exports;return (function outer (modules, cache, entry) {\r\n    // Save the require from previous bundle to this closure if any\r\n    var previousRequire = typeof require == \"function\" && require;\r\n\r\n    function newRequire(name, jumped){\r\n        if(!cache[name]) {\r\n            if(!modules[name]) {\r\n                // if we cannot find the the module within our internal map or\r\n                // cache jump to the current global require ie. the last bundle\r\n                // that was added to the page.\r\n                var currentRequire = typeof require == \"function\" && require;\r\n                if (!jumped && currentRequire) return require(name, true);\r\n\r\n                // If there are other bundles on this page the require from the\r\n                // previous one is saved to 'previousRequire'. Repeat this as\r\n                // many times as there are bundles until the module is found or\r\n                // we exhaust the require chain.\r\n                if (previousRequire) return require(name, true);\r\n                var err = new Error('Cannot find module \\'' + name + '\\'');\r\n                err.code = 'MODULE_NOT_FOUND';\r\n                throw err;\r\n            }\r\n            var m = cache[name] = {exports:{}};\r\n            modules[name][0].call(m.exports, function(x){\r\n                var id = modules[name][1][x];\r\n                return newRequire(id ? id : x);\r\n            },m,m.exports,outer,modules,cache,entry);\r\n        }\r\n        return cache[name].exports;\r\n    }\r\n    for(var i=0;i<entry.length;i++) newRequire(entry[i]);\r\n\r\n    // Override the current require with this new one\r\n    return newRequire;\r\n})\r\n({\"./bundles/snippets.js\":[function(require,module,exports){\r\n/**\r\n * Bundler, used in builder script to statically\r\n * include snippets.json into bundle\r\n */\r\nvar res = require('../lib/assets/resources');\r\nvar snippets = require('../lib/snippets.json');\r\nres.setVocabulary(snippets, 'system');\r\n\r\n},{\"../lib/assets/resources\":\"assets\\\\resources.js\",\"../lib/snippets.json\":\"snippets.json\"}],\"./lib/emmet.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar global = typeof self != 'undefined' ? self : this;\r\n\r\n\tvar utils = require('./utils/common');\r\n\tvar actions = require('./action/main');\r\n\tvar parser = require('./parser/abbreviation');\r\n\tvar file = require('./plugin/file');\r\n\r\n\tvar preferences = require('./assets/preferences');\r\n\tvar resources = require('./assets/resources');\r\n\tvar profile = require('./assets/profile');\r\n\tvar ciu = require('./assets/caniuse');\r\n\tvar logger = require('./assets/logger');\r\n\r\n\tvar sliceFn = Array.prototype.slice;\r\n\r\n\t/**\r\n\t * Returns file name part from path\r\n\t * @param {String} path Path to file\r\n\t * @return {String}\r\n\t */\r\n\tfunction getFileName(path) {\r\n\t\tvar re = /([\\w\\.\\-]+)$/i;\r\n\t\tvar m = re.exec(path);\r\n\t\treturn m ? m[1] : '';\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes profile definition: converts some\r\n\t * properties to valid data types\r\n\t * @param {Object} profile\r\n\t * @return {Object}\r\n\t */\r\n\tfunction normalizeProfile(profile) {\r\n\t\tif (typeof profile === 'object') {\r\n\t\t\tif ('indent' in profile) {\r\n\t\t\t\tprofile.indent = !!profile.indent;\r\n\t\t\t}\r\n\r\n\t\t\tif ('self_closing_tag' in profile) {\r\n\t\t\t\tif (typeof profile.self_closing_tag === 'number') {\r\n\t\t\t\t\tprofile.self_closing_tag = !!profile.self_closing_tag;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn profile;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * The essential function that expands Emmet abbreviation\r\n\t\t * @param {String} abbr Abbreviation to parse\r\n\t\t * @param {String} syntax Abbreviation's context syntax\r\n\t\t * @param {String} profile Output profile (or its name)\r\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\r\n\t\t * written\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\r\n\t\t\treturn parser.expand(abbr, {\r\n\t\t\t\tsyntax: syntax,\r\n\t\t\t\tprofile: profile,\r\n\t\t\t\tcontextNode: contextNode\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Runs given action\r\n\t\t * @param  {String} name Action name\r\n\t\t * @param  {IEmmetEditor} editor Editor instance\r\n\t\t * @return {Boolean} Returns true if action was performed successfully\r\n\t\t */\r\n\t\trun: function(name) {\r\n\t\t\treturn actions.run.apply(actions, sliceFn.call(arguments, 0));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads Emmet extensions. Extensions are simple .js files that\r\n\t\t * uses Emmet modules and resources to create new actions, modify\r\n\t\t * existing ones etc.\r\n\t\t * @param {Array} fileList List of absolute paths to files in extensions\r\n\t\t * folder. Back-end app should not filter this list (e.g. by extension)\r\n\t\t * but return it \"as-is\" so bootstrap can decide how to load contents\r\n\t\t * of each file.\r\n\t\t * This method requires a <code>file</code> module of <code>IEmmetFile</code>\r\n\t\t * interface to be implemented.\r\n\t\t * @memberOf bootstrap\r\n\t\t */\r\n\t\tloadExtensions: function(fileList) {\r\n\t\t\tvar payload = {};\r\n\t\t\tvar userSnippets = null;\r\n\t\t\tvar that = this;\r\n\r\n\t\t\t// make sure file list contians only valid extension files\r\n\t\t\tfileList = fileList.filter(function(f) {\r\n\t\t\t\tvar ext = file.getExt(f);\r\n\t\t\t\treturn ext === 'json' || ext === 'js';\r\n\t\t\t});\r\n\r\n\t\t\tvar reader = (file.readText || file.read).bind(file);\r\n\t\t\tvar next = function() {\r\n\t\t\t\tif (fileList.length) {\r\n\t\t\t\t\tvar f = fileList.shift();\r\n\t\t\t\t\treader(f, function(err, content) {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\tlogger.log('Unable to read \"' + f + '\" file: '+ err);\r\n\t\t\t\t\t\t\treturn next();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tswitch (file.getExt(f)) {\r\n\t\t\t\t\t\t\tcase 'js':\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\teval(content);\r\n\t\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\t\tlogger.log('Unable to eval \"' + f + '\" file: '+ e);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 'json':\r\n\t\t\t\t\t\t\t\tvar fileName = getFileName(f).toLowerCase().replace(/\\.json$/, '');\r\n\t\t\t\t\t\t\t\tcontent = utils.parseJSON(content);\r\n\t\t\t\t\t\t\t\tif (/^snippets/.test(fileName)) {\r\n\t\t\t\t\t\t\t\t\tif (fileName === 'snippets') {\r\n\t\t\t\t\t\t\t\t\t\t// data in snippets.json is more important to user\r\n\t\t\t\t\t\t\t\t\t\tuserSnippets = content;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tpayload.snippets = utils.deepMerge(payload.snippets || {}, content);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tpayload[fileName] = content;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnext();\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// complete\r\n\t\t\t\t\tif (userSnippets) {\r\n\t\t\t\t\t\tpayload.snippets = utils.deepMerge(payload.snippets || {}, userSnippets);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthat.loadUserData(payload);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tnext();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads preferences from JSON object (or string representation of JSON)\r\n\t\t * @param {Object} data\r\n\t\t * @returns\r\n\t\t */\r\n\t\tloadPreferences: function(data) {\r\n\t\t\tpreferences.load(utils.parseJSON(data));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads user snippets and abbreviations. It doesn’t replace current\r\n\t\t * user resource vocabulary but merges it with passed one. If you need\r\n\t\t * to <i>replaces</i> user snippets you should call\r\n\t\t * <code>resetSnippets()</code> method first\r\n\t\t */\r\n\t\tloadSnippets: function(data) {\r\n\t\t\tdata = utils.parseJSON(data);\r\n\r\n\t\t\tvar userData = resources.getVocabulary('user') || {};\r\n\t\t\tresources.setVocabulary(utils.deepMerge(userData, data), 'user');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Helper function that loads default snippets, defined in project’s\r\n\t\t * <i>snippets.json</i>\r\n\t\t * @param {Object} data\r\n\t\t */\r\n\t\tloadSystemSnippets: function(data) {\r\n\t\t\tresources.setVocabulary(utils.parseJSON(data), 'system');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Helper function that loads Can I Use database\r\n\t\t * @param {Object} data\r\n\t\t */\r\n\t\tloadCIU: function(data) {\r\n\t\t\tciu.load(utils.parseJSON(data));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes all user-defined snippets\r\n\t\t */\r\n\t\tresetSnippets: function() {\r\n\t\t\tresources.setVocabulary({}, 'user');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Helper function that loads all user data (snippets and preferences)\r\n\t\t * defined as a single JSON object. This is useful for loading data\r\n\t\t * stored in a common storage, for example <code>NSUserDefaults</code>\r\n\t\t * @param {Object} data\r\n\t\t */\r\n\t\tloadUserData: function(data) {\r\n\t\t\tdata = utils.parseJSON(data);\r\n\t\t\tif (data.snippets) {\r\n\t\t\t\tthis.loadSnippets(data.snippets);\r\n\t\t\t}\r\n\r\n\t\t\tif (data.preferences) {\r\n\t\t\t\tthis.loadPreferences(data.preferences);\r\n\t\t\t}\r\n\r\n\t\t\tif (data.profiles) {\r\n\t\t\t\tthis.loadProfiles(data.profiles);\r\n\t\t\t}\r\n\r\n\t\t\tif (data.caniuse) {\r\n\t\t\t\tthis.loadCIU(data.caniuse);\r\n\t\t\t}\r\n\r\n\t\t\tvar profiles = data.syntaxProfiles || data.syntaxprofiles;\r\n\t\t\tif (profiles) {\r\n\t\t\t\tthis.loadSyntaxProfiles(profiles);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Resets all user-defined data: preferences, snippets etc.\r\n\t\t * @returns\r\n\t\t */\r\n\t\tresetUserData: function() {\r\n\t\t\tthis.resetSnippets();\r\n\t\t\tpreferences.reset();\r\n\t\t\tprofile.reset();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Load syntax-specific output profiles. These are essentially\r\n\t\t * an extension to syntax snippets\r\n\t\t * @param {Object} profiles Dictionary of profiles\r\n\t\t */\r\n\t\tloadSyntaxProfiles: function(profiles) {\r\n\t\t\tprofiles = utils.parseJSON(profiles);\r\n\t\t\tvar snippets = {};\r\n\t\t\tObject.keys(profiles).forEach(function(syntax) {\r\n\t\t\t\tvar options = profiles[syntax];\r\n\t\t\t\tif (!(syntax in snippets)) {\r\n\t\t\t\t\tsnippets[syntax] = {};\r\n\t\t\t\t}\r\n\t\t\t\tsnippets[syntax].profile = normalizeProfile(options);\r\n\t\t\t});\r\n\r\n\t\t\tthis.loadSnippets(snippets);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Load named profiles\r\n\t\t * @param {Object} profiles\r\n\t\t */\r\n\t\tloadProfiles: function(profiles) {\r\n\t\t\tprofiles = utils.parseJSON(profiles);\r\n\t\t\tObject.keys(profiles).forEach(function(name) {\r\n\t\t\t\tprofile.create(name, normalizeProfile(profiles[name]));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t// expose some useful data for plugin authors\r\n\t\tactions: actions,\r\n\t\tparser: parser,\r\n\t\tfile: file,\r\n\t\tpreferences: preferences,\r\n\t\tresources: resources,\r\n\t\tprofile: profile,\r\n\t\ttabStops: require('./assets/tabStops'),\r\n\t\thtmlMatcher: require('./assets/htmlMatcher'),\r\n\t\tutils: {\r\n\t\t\tcommon: utils,\r\n\t\t\taction: require('./utils/action'),\r\n\t\t\teditor: require('./utils/editor')\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"./action/main\":\"action\\\\main.js\",\"./assets/caniuse\":\"assets\\\\caniuse.js\",\"./assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"./assets/logger\":\"assets\\\\logger.js\",\"./assets/preferences\":\"assets\\\\preferences.js\",\"./assets/profile\":\"assets\\\\profile.js\",\"./assets/resources\":\"assets\\\\resources.js\",\"./assets/tabStops\":\"assets\\\\tabStops.js\",\"./parser/abbreviation\":\"parser\\\\abbreviation.js\",\"./plugin/file\":\"plugin\\\\file.js\",\"./utils/action\":\"utils\\\\action.js\",\"./utils/common\":\"utils\\\\common.js\",\"./utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\balance.js\":[function(require,module,exports){\r\n/**\r\n * HTML pair matching (balancing) actions\r\n * @constructor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar range = require('../assets/range');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar cssSections = require('../utils/cssSections');\r\n\tvar lastMatch = null;\r\n\r\n\tfunction last(arr) {\r\n\t\treturn arr[arr.length - 1];\r\n\t}\r\n\r\n\tfunction balanceHTML(editor, direction) {\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar content = info.content;\r\n\t\tvar sel = range(editor.getSelectionRange());\r\n\t\t\r\n\t\t// validate previous match\r\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\r\n\t\t\tlastMatch = null;\r\n\t\t}\r\n\t\t\r\n\t\tif (lastMatch && sel.length()) {\r\n\t\t\tif (direction == 'in') {\r\n\t\t\t\t// user has previously selected tag and wants to move inward\r\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\r\n\t\t\t\t\t// unary tag was selected, can't move inward\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\r\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar narrowed = utils.narrowToNonSpace(content, lastMatch.innerRange);\r\n\t\t\t\t\t\tlastMatch = htmlMatcher.find(content, narrowed.start + 1);\r\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\r\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (\r\n\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \r\n\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \r\n\t\t\t\t\t&& sel.equal(lastMatch.range)) {\r\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastMatch = htmlMatcher.find(content, sel.start);\r\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\r\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlastMatch = htmlMatcher.find(content, sel.start);\r\n\t\t}\r\n\r\n\t\tif (lastMatch) {\r\n\t\t\tif (lastMatch.innerRange.equal(sel)) {\r\n\t\t\t\tlastMatch.range = lastMatch.outerRange;\r\n\t\t\t}\r\n\r\n\t\t\tif (!lastMatch.range.equal(sel)) {\r\n\t\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlastMatch = null;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction rangesForCSSRule(rule, pos) {\r\n\t\t// find all possible ranges\r\n\t\tvar ranges = [rule.range(true)];\r\n\r\n\t\t// braces content\r\n\t\tranges.push(rule.valueRange(true));\r\n\r\n\t\t// find nested sections\r\n\t\tvar nestedSections = cssSections.nestedSectionsInRule(rule);\r\n\r\n\t\t// real content, e.g. from first property name to\r\n\t\t// last property value\r\n\t\tvar items = rule.list();\r\n\t\tif (items.length || nestedSections.length) {\r\n\t\t\tvar start = Number.POSITIVE_INFINITY, end = -1;\r\n\t\t\tif (items.length) {\r\n\t\t\t\tstart = items[0].namePosition(true);\r\n\t\t\t\tend = last(items).range(true).end;\r\n\t\t\t}\r\n\r\n\t\t\tif (nestedSections.length) {\r\n\t\t\t\tif (nestedSections[0].start < start) {\r\n\t\t\t\t\tstart = nestedSections[0].start;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (last(nestedSections).end > end) {\r\n\t\t\t\t\tend = last(nestedSections).end;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tranges.push(range.create2(start, end));\r\n\t\t}\r\n\r\n\t\tranges = ranges.concat(nestedSections);\r\n\r\n\t\tvar prop = cssEditTree.propertyFromPosition(rule, pos) || items[0];\r\n\t\tif (prop) {\r\n\t\t\tranges.push(prop.range(true));\r\n\t\t\tvar valueRange = prop.valueRange(true);\r\n\t\t\tif (!prop.end()) {\r\n\t\t\t\tvalueRange._unterminated = true;\r\n\t\t\t}\r\n\t\t\tranges.push(valueRange);\r\n\t\t}\r\n\r\n\t\treturn ranges;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all possible selection ranges for given caret position\r\n\t * @param  {String} content CSS content\r\n\t * @param  {Number} pos     Caret position(where to start searching)\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getCSSRanges(content, pos) {\r\n\t\tvar rule;\r\n\t\tif (typeof content === 'string') {\r\n\t\t\tvar ruleRange = cssSections.matchEnclosingRule(content, pos);\r\n\t\t\tif (ruleRange) {\r\n\t\t\t\trule = cssEditTree.parse(ruleRange.substring(content), {\r\n\t\t\t\t\toffset: ruleRange.start\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// passed parsed CSS rule\r\n\t\t\trule = content;\r\n\t\t}\r\n\r\n\t\tif (!rule) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// find all possible ranges\r\n\t\tvar ranges = rangesForCSSRule(rule, pos);\r\n\r\n\t\t// remove empty ranges\r\n\t\tranges = ranges.filter(function(item) {\r\n\t\t\treturn !!item.length;\r\n\t\t});\r\n\r\n\t\treturn utils.unique(ranges, function(item) {\r\n\t\t\treturn item.valueOf();\r\n\t\t});\r\n\t}\r\n\r\n\tfunction balanceCSS(editor, direction) {\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar content = info.content;\r\n\t\tvar sel = range(editor.getSelectionRange());\r\n\r\n\t\tvar ranges = getCSSRanges(info.content, sel.start);\r\n\t\tif (!ranges && sel.length()) {\r\n\t\t\t// possible reason: user has already selected\r\n\t\t\t// CSS rule from last match\r\n\t\t\ttry {\r\n\t\t\t\tvar rule = cssEditTree.parse(sel.substring(info.content), {\r\n\t\t\t\t\toffset: sel.start\r\n\t\t\t\t});\r\n\t\t\t\tranges = getCSSRanges(rule, sel.start);\r\n\t\t\t} catch(e) {}\r\n\t\t}\r\n\r\n\t\tif (!ranges) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tranges = range.sort(ranges, true);\r\n\r\n\t\t// edge case: find match that equals current selection,\r\n\t\t// in case if user moves inward after selecting full CSS rule\r\n\t\tvar bestMatch = utils.find(ranges, function(r) {\r\n\t\t\treturn r.equal(sel);\r\n\t\t});\r\n\r\n\t\tif (!bestMatch) {\r\n\t\t\tbestMatch = utils.find(ranges, function(r) {\r\n\t\t\t\t// Check for edge case: caret right after CSS value\r\n\t\t\t\t// but it doesn‘t contains terminating semicolon.\r\n\t\t\t\t// In this case we have to check full value range\r\n\t\t\t\treturn r._unterminated ? r.include(sel.start) : r.inside(sel.start);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!bestMatch) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// if best match equals to current selection, move index\r\n\t\t// one position up or down, depending on direction\r\n\t\tvar bestMatchIx = ranges.indexOf(bestMatch);\r\n\t\tif (bestMatch.equal(sel)) {\r\n\t\t\tbestMatchIx += direction == 'out' ? 1 : -1;\r\n\t\t}\r\n\r\n\t\tif (bestMatchIx < 0 || bestMatchIx >= ranges.length) {\r\n\t\t\tif (bestMatchIx >= ranges.length && direction == 'out') {\r\n\t\t\t\tpos = bestMatch.start - 1;\r\n\r\n\t\t\t\tvar outerRanges = getCSSRanges(content, pos);\r\n\t\t\t\tif (outerRanges) {\r\n\t\t\t\t\tbestMatch = last(outerRanges.filter(function(r) {\r\n\t\t\t\t\t\treturn r.inside(pos);\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t} else if (bestMatchIx < 0 && direction == 'in') {\r\n\t\t\t\tbestMatch = null;\r\n\t\t\t} else {\r\n\t\t\t\tbestMatch = null;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tbestMatch = ranges[bestMatchIx];\t\r\n\t\t}\r\n\r\n\t\tif (bestMatch) {\r\n\t\t\teditor.createSelection(bestMatch.start, bestMatch.end);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Find and select HTML tag pair\r\n\t\t * @param {IEmmetEditor} editor Editor instance\r\n\t\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \r\n\t\t * Default is 'out'\r\n\t\t */\r\n\t\tbalance: function(editor, direction) {\r\n\t\t\tdirection = String((direction || 'out').toLowerCase());\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\tif (actionUtils.isSupportedCSS(info.syntax)) {\r\n\t\t\t\treturn balanceCSS(editor, direction);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn balanceHTML(editor, direction);\r\n\t\t},\r\n\r\n\t\tbalanceInwardAction: function(editor) {\r\n\t\t\treturn this.balance(editor, 'in');\r\n\t\t},\r\n\r\n\t\tbalanceOutwardAction: function(editor) {\r\n\t\t\treturn this.balance(editor, 'out');\t\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Moves caret to matching opening or closing tag\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t */\r\n\t\tgoToMatchingPairAction: function(editor) {\r\n\t\t\tvar content = String(editor.getContent());\r\n\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\t\r\n\t\t\tif (content.charAt(caretPos) == '<') \r\n\t\t\t\t// looks like caret is outside of tag pair  \r\n\t\t\t\tcaretPos++;\r\n\t\t\t\t\r\n\t\t\tvar tag = htmlMatcher.tag(content, caretPos);\r\n\t\t\tif (tag && tag.close) { // exclude unary tags\r\n\t\t\t\tif (tag.open.range.inside(caretPos)) {\r\n\t\t\t\t\teditor.setCaretPos(tag.close.range.start);\r\n\t\t\t\t} else {\r\n\t\t\t\t\teditor.setCaretPos(tag.open.range.start);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\base64.js\":[function(require,module,exports){\r\n/**\r\n * Encodes/decodes image under cursor to/from base64\r\n * @param {IEmmetEditor} editor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar file = require('../plugin/file');\r\n\tvar base64 = require('../utils/base64');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar editorUtils = require('../utils/editor');\r\n\r\n\t/**\r\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\r\n\t * position. If <code>pos</code> is omitted, search from beginning of text \r\n\t * @param {String} token Token to test\r\n\t * @param {String} text Where to search\r\n\t * @param {Number} pos Position where to start search\r\n\t * @return {Boolean}\r\n\t * @since 0.65\r\n\t */\r\n\tfunction startsWith(token, text, pos) {\r\n\t\tpos = pos || 0;\r\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\r\n\t}\r\n\r\n\t/**\r\n\t * Encodes image to base64\r\n\t * \r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} imgPath Path to image\r\n\t * @param {Number} pos Caret position where image is located in the editor\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction encodeToBase64(editor, imgPath, pos) {\r\n\t\tvar editorFile = editor.getFilePath();\r\n\t\tvar defaultMimeType = 'application/octet-stream';\r\n\r\n\t\tif (editorFile === null) {\r\n\t\t\tthrow \"You should save your file before using this action\";\r\n\t\t}\r\n\r\n\t\t// locate real image path\r\n\t\tfile.locateFile(editorFile, imgPath, function(realImgPath) {\r\n\t\t\tif (realImgPath === null) {\r\n\t\t\t\tthrow \"Can't find \" + imgPath + ' file';\r\n\t\t\t}\r\n\r\n\t\t\tfile.read(realImgPath, function(err, content) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar b64 = base64.encode(String(content));\r\n\t\t\t\tif (!b64) {\r\n\t\t\t\t\tthrow \"Can't encode file content to base64\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\r\n\t\t\t\t\t';base64,' + b64;\r\n\r\n\t\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Decodes base64 string back to file.\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} filePath to new image\r\n\t * @param {String} data Base64-encoded file content\r\n\t * @param {Number} pos Caret position where image is located in the editor\r\n\t */\r\n\tfunction decodeFromBase64(editor, filePath, data, pos) {\r\n\t\t// ask user to enter path to file\r\n\t\tfilePath = filePath || String(editor.prompt('Enter path to file (absolute or relative)'));\r\n\t\tif (!filePath) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar editorFile = editor.getFilePath();\r\n\t\tfile.createPath(editorFile, filePath, function(err, absPath) {\r\n\t\t\tif (err || !absPath) {\r\n\t\t\t\tthrow \"Can't save file\";\r\n\t\t\t}\r\n\r\n\t\t\tvar content = data.replace(/^data\\:.+?;.+?,/, '');\r\n\t\t\tfile.save(absPath, base64.decode(content), function(err) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tthrow 'Unable to save ' + absPath + ': ' + err;\r\n\t\t\t\t}\r\n\r\n\t\t\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Action to encode or decode file to data:url\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tencodeDecodeDataUrlAction: function(editor, filepath) {\r\n\t\t\tvar data = String(editor.getSelection());\r\n\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\r\n\t\t\tif (!data) {\r\n\t\t\t\t// no selection, try to find image bounds from current caret position\r\n\t\t\t\tvar text = info.content, m;\r\n\t\t\t\twhile (caretPos-- >= 0) {\r\n\t\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\r\n\t\t\t\t\t\tif ((m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/))) {\r\n\t\t\t\t\t\t\tdata = m[3];\r\n\t\t\t\t\t\t\tcaretPos += m[1].length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\r\n\t\t\t\t\t\tif ((m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/))) {\r\n\t\t\t\t\t\t\tdata = m[3];\r\n\t\t\t\t\t\t\tcaretPos += m[1].length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (data) {\r\n\t\t\t\tif (startsWith('data:', data)) {\r\n\t\t\t\t\treturn decodeFromBase64(editor, filepath, data, caretPos);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn encodeToBase64(editor, data, caretPos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../plugin/file\":\"plugin\\\\file.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/base64\":\"utils\\\\base64.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\editPoints.js\":[function(require,module,exports){\r\n/**\r\n * Move between next/prev edit points. 'Edit points' are places between tags \r\n * and quotes of empty attributes in html\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * Search for new caret insertion point\r\n\t * @param {IEmmetEditor} editor Editor instance\r\n\t * @param {Number} inc Search increment: -1 — search left, 1 — search right\r\n\t * @param {Number} offset Initial offset relative to current caret position\r\n\t * @return {Number} Returns -1 if insertion point wasn't found\r\n\t */\r\n\tfunction findNewEditPoint(editor, inc, offset) {\r\n\t\tinc = inc || 1;\r\n\t\toffset = offset || 0;\r\n\t\t\r\n\t\tvar curPoint = editor.getCaretPos() + offset;\r\n\t\tvar content = String(editor.getContent());\r\n\t\tvar maxLen = content.length;\r\n\t\tvar nextPoint = -1;\r\n\t\tvar reEmptyLine = /^\\s+$/;\r\n\t\t\r\n\t\tfunction getLine(ix) {\r\n\t\t\tvar start = ix;\r\n\t\t\twhile (start >= 0) {\r\n\t\t\t\tvar c = content.charAt(start);\r\n\t\t\t\tif (c == '\\n' || c == '\\r')\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tstart--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn content.substring(start, ix);\r\n\t\t}\r\n\t\t\t\r\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\r\n\t\t\tcurPoint += inc;\r\n\t\t\tvar curChar = content.charAt(curPoint);\r\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\r\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\r\n\t\t\t\t\r\n\t\t\tswitch (curChar) {\r\n\t\t\t\tcase '\"':\r\n\t\t\t\tcase '\\'':\r\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\r\n\t\t\t\t\t\t// empty attribute\r\n\t\t\t\t\t\tnextPoint = curPoint + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '>':\r\n\t\t\t\t\tif (nextChar == '<') {\r\n\t\t\t\t\t\t// between tags\r\n\t\t\t\t\t\tnextPoint = curPoint + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n\t\t\t\t\t// empty line\r\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\r\n\t\t\t\t\t\tnextPoint = curPoint;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (nextPoint != -1)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\treturn nextPoint;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Move to previous edit point\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tpreviousEditPointAction: function(editor, syntax, profile) {\r\n\t\t\tvar curPos = editor.getCaretPos();\r\n\t\t\tvar newPoint = findNewEditPoint(editor, -1);\r\n\t\t\t\t\r\n\t\t\tif (newPoint == curPos)\r\n\t\t\t\t// we're still in the same point, try searching from the other place\r\n\t\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\r\n\t\t\t\r\n\t\t\tif (newPoint != -1) {\r\n\t\t\t\teditor.setCaretPos(newPoint);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Move to next edit point\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tnextEditPointAction: function(editor, syntax, profile) {\r\n\t\t\tvar newPoint = findNewEditPoint(editor, 1);\r\n\t\t\tif (newPoint != -1) {\r\n\t\t\t\teditor.setCaretPos(newPoint);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"action\\\\evaluateMath.js\":[function(require,module,exports){\r\n/**\r\n * Evaluates simple math expression under caret\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar utils = require('../utils/common');\r\n\tvar math = require('../utils/math');\r\n\tvar range = require('../assets/range');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Evaluates math expression under the caret\r\n\t\t * @param  {IEmmetEditor} editor\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tevaluateMathAction: function(editor) {\r\n\t\t\tvar content = editor.getContent();\r\n\t\t\tvar chars = '.+-*/\\\\';\r\n\t\t\t\r\n\t\t\t/** @type Range */\r\n\t\t\tvar sel = range(editor.getSelectionRange());\r\n\t\t\tif (!sel.length()) {\r\n\t\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\r\n\t\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (sel && sel.length()) {\r\n\t\t\t\tvar expr = sel.substring(content);\r\n\t\t\t\t\r\n\t\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \r\n\t\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'round($1/$2)');\r\n\t\t\t\t\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar result = utils.prettifyNumber(math.evaluate(expr));\r\n\t\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\r\n\t\t\t\t\teditor.setCaretPos(sel.start + result.length);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} catch (e) {}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/math\":\"utils\\\\math.js\"}],\"action\\\\expandAbbreviation.js\":[function(require,module,exports){\r\n/**\r\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \r\n * position and replaces it with formatted output. \r\n * <br><br>\r\n * This behavior can be overridden with custom handlers which can perform \r\n * different actions when 'Expand Abbreviation' action is called.\r\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\r\n * definitions registers its own expand abbreviation handler.  \r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar handlerList = require('../assets/handlerList');\r\n\tvar range = require('../assets/range');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar cssGradient = require('../resolver/cssGradient');\r\n\tvar parser = require('../parser/abbreviation');\r\n\r\n\t/**\r\n\t * Search for abbreviation in editor from current caret position\r\n\t * @param {IEmmetEditor} editor Editor instance\r\n\t * @return {String}\r\n\t */\r\n\tfunction findAbbreviation(editor) {\r\n\t\tvar r = range(editor.getSelectionRange());\r\n\t\tvar content = String(editor.getContent());\r\n\t\tif (r.length()) {\r\n\t\t\t// abbreviation is selected by user\r\n\t\t\treturn r.substring(content);\r\n\t\t}\r\n\t\t\r\n\t\t// search for new abbreviation from current caret position\r\n\t\tvar curLine = editor.getCurrentLineRange();\r\n\t\treturn actionUtils.extractAbbreviation(content.substring(curLine.start, r.start));\r\n\t}\r\n\r\n\t/**\r\n\t * @type HandlerList List of registered handlers\r\n\t */\r\n\tvar handlers = handlerList.create();\r\n\r\n\t// XXX setup default expand handlers\r\n\t\r\n\t/**\r\n\t * Extracts abbreviation from current caret \r\n\t * position and replaces it with formatted output \r\n\t * @param {IEmmetEditor} editor Editor instance\r\n\t * @param {String} syntax Syntax type (html, css, etc.)\r\n\t * @param {String} profile Output profile name (html, xml, xhtml)\r\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \r\n\t * successfully\r\n\t */\r\n\thandlers.add(function(editor, syntax, profile) {\r\n\t\tvar caretPos = editor.getSelectionRange().end;\r\n\t\tvar abbr = findAbbreviation(editor);\r\n\t\t\t\r\n\t\tif (abbr) {\r\n\t\t\tvar content = parser.expand(abbr, {\r\n\t\t\t\tsyntax: syntax, \r\n\t\t\t\tprofile: profile, \r\n\t\t\t\tcontextNode: actionUtils.captureContext(editor)\r\n\t\t\t});\r\n\r\n\t\t\tif (content) {\r\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\r\n\t\t\t\tvar replaceTo = caretPos;\r\n\r\n\t\t\t\t// a special case for CSS: if editor already contains\r\n\t\t\t\t// semicolon right after current caret position — replace it too\r\n\t\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\r\n\t\t\t\tif (cssSyntaxes && ~cssSyntaxes.indexOf(syntax)) {\r\n\t\t\t\t\tvar curContent = editor.getContent();\r\n\t\t\t\t\tif (curContent.charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\r\n\t\t\t\t\t\treplaceTo++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}, {order: -1});\r\n\thandlers.add(cssGradient.expandAbbreviationHandler.bind(cssGradient));\r\n\t\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * The actual “Expand Abbreviation“ action routine\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\texpandAbbreviationAction: function(editor, syntax, profile) {\r\n\t\t\tvar args = utils.toArray(arguments);\r\n\t\t\t\r\n\t\t\t// normalize incoming arguments\r\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\r\n\t\t\targs[1] = info.syntax;\r\n\t\t\targs[2] = info.profile;\r\n\t\t\t\r\n\t\t\treturn handlers.exec(false, args);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A special case of “Expand Abbreviation“ action, invoked by Tab key.\r\n\t\t * In this case if abbreviation wasn’t expanded successfully or there’s a selecetion, \r\n\t\t * the current line/selection will be indented. \r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\texpandAbbreviationWithTabAction: function(editor, syntax, profile) {\r\n\t\t\tvar sel = editor.getSelection();\r\n\t\t\tvar indent = '\\t';\r\n\r\n\t\t\t// if something is selected in editor,\r\n\t\t\t// we should indent the selected content\r\n\t\t\tif (sel) {\r\n\t\t\t\tvar selRange = range(editor.getSelectionRange());\r\n\t\t\t\tvar content = utils.padString(sel, indent);\r\n\t\t\t\t\r\n\t\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\r\n\t\t\t\tvar replaceRange = range(editor.getCaretPos(), selRange.length());\r\n\t\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\r\n\t\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\r\n\t\t\t// nothing selected, try to expand\r\n\t\t\tif (!this.expandAbbreviationAction(editor, syntax, profile)) {\r\n\t\t\t\teditor.replaceContent(indent, editor.getCaretPos());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t\r\n\t\t_defaultHandler: function(editor, syntax, profile) {\r\n\t\t\tvar caretPos = editor.getSelectionRange().end;\r\n\t\t\tvar abbr = this.findAbbreviation(editor);\r\n\t\t\t\t\r\n\t\t\tif (abbr) {\r\n\t\t\t\tvar ctx = actionUtils.captureContext(editor);\r\n\t\t\t\tvar content = parser.expand(abbr, syntax, profile, ctx);\r\n\t\t\t\tif (content) {\r\n\t\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds custom expand abbreviation handler. The passed function should \r\n\t\t * return <code>true</code> if it was performed successfully, \r\n\t\t * <code>false</code> otherwise.\r\n\t\t * \r\n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\r\n\t\t * in order they were added\r\n\t\t * @memberOf expandAbbreviation\r\n\t\t * @param {Function} fn\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\taddHandler: function(fn, options) {\r\n\t\t\thandlers.add(fn, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered handler\r\n\t\t * @returns\r\n\t\t */\r\n\t\tremoveHandler: function(fn) {\r\n\t\t\thandlers.remove(fn);\r\n\t\t},\r\n\t\t\r\n\t\tfindAbbreviation: findAbbreviation\r\n\t};\r\n});\r\n},{\"../assets/handlerList\":\"assets\\\\handlerList.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../resolver/cssGradient\":\"resolver\\\\cssGradient.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\incrementDecrement.js\":[function(require,module,exports){\r\n/**\r\n * Increment/decrement number under cursor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar actionUtils = require('../utils/action');\r\n\r\n\t/**\r\n\t * Returns length of integer part of number\r\n\t * @param {String} num\r\n\t */\r\n\tfunction intLength(num) {\r\n\t\tnum = num.replace(/^\\-/, '');\r\n\t\tif (~num.indexOf('.')) {\r\n\t\t\treturn num.split('.')[0].length;\r\n\t\t}\r\n\t\t\r\n\t\treturn num.length;\r\n\t}\r\n\r\n\treturn {\r\n\t\tincrement01Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, .1);\r\n\t\t},\r\n\r\n\t\tincrement1Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, 1);\r\n\t\t},\r\n\r\n\t\tincrement10Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, 10);\r\n\t\t},\r\n\r\n\t\tdecrement01Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, -.1);\r\n\t\t},\r\n\r\n\t\tdecrement1Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, -1);\r\n\t\t},\r\n\r\n\t\tdecrement10Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, -10);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Default method to increment/decrement number under\r\n\t\t * caret with given step\r\n\t\t * @param  {IEmmetEditor} editor\r\n\t\t * @param  {Number} step\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tincrementNumber: function(editor, step) {\r\n\t\t\tvar hasSign = false;\r\n\t\t\tvar hasDecimal = false;\r\n\t\t\t\t\r\n\t\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\r\n\t\t\t\tif (utils.isNumeric(ch))\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tif (ch == '.') {\r\n\t\t\t\t\t// make sure that next character is numeric too\r\n\t\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (ch == '-')\r\n\t\t\t\t\treturn hasSign ? false : hasSign = true;\r\n\t\t\t\t\t\r\n\t\t\t\treturn false;\r\n\t\t\t});\r\n\t\t\t\t\r\n\t\t\tif (r && r.length()) {\r\n\t\t\t\tvar strNum = r.substring(String(editor.getContent()));\r\n\t\t\t\tvar num = parseFloat(strNum);\r\n\t\t\t\tif (!isNaN(num)) {\r\n\t\t\t\t\tnum = utils.prettifyNumber(num + step);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do we have zero-padded number?\r\n\t\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\r\n\t\t\t\t\t\tvar minus = '';\r\n\t\t\t\t\t\tif (RegExp.$1) {\r\n\t\t\t\t\t\t\tminus = '-';\r\n\t\t\t\t\t\t\tnum = num.substring(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar parts = num.split('.');\r\n\t\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\r\n\t\t\t\t\t\tnum = minus + parts.join('.');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\teditor.replaceContent(num, r.start, r.end);\r\n\t\t\t\t\teditor.createSelection(r.start, r.start + num.length);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"action\\\\lineBreaks.js\":[function(require,module,exports){\r\n/**\r\n * Actions to insert line breaks. Some simple editors (like browser's \r\n * &lt;textarea&gt;, for example) do not provide such simple things\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar utils = require('../utils/common');\r\n\tvar resources = require('../assets/resources');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar editorUtils = require('../utils/editor');\r\n\r\n\tvar xmlSyntaxes = ['html', 'xml', 'xsl'];\r\n\r\n\t// setup default preferences\r\n\tprefs.define('css.closeBraceIndentation', '\\n',\r\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \r\n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\r\n\t\t\t+ 'This preference’s value will be automatically inserted before '\r\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\r\n\t\t\t+ '(e.g. when “Insert formatted linebreak” action will be performed ' \r\n\t\t\t+ 'in CSS file). If you’re such user, you may want to write put a value ' \r\n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Inserts newline character with proper indentation. This action is used in\r\n\t\t * editors that doesn't have indentation control (like textarea element) to \r\n\t\t * provide proper indentation for inserted newlines\r\n\t\t * @param {IEmmetEditor} editor Editor instance\r\n\t\t */\r\n\t\tinsertLineBreakAction: function(editor) {\r\n\t\t\tif (!this.insertLineBreakOnlyAction(editor)) {\r\n\t\t\t\tvar curPadding = editorUtils.getCurrentLinePadding(editor);\r\n\t\t\t\tvar content = String(editor.getContent());\r\n\t\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\t\tvar len = content.length;\r\n\t\t\t\tvar nl = '\\n';\r\n\t\t\t\t\t\r\n\t\t\t\t// check out next line padding\r\n\t\t\t\tvar lineRange = editor.getCurrentLineRange();\r\n\t\t\t\tvar nextPadding = '';\r\n\t\t\t\t\t\r\n\t\t\t\tfor (var i = lineRange.end, ch; i < len; i++) {\r\n\t\t\t\t\tch = content.charAt(i);\r\n\t\t\t\t\tif (ch == ' ' || ch == '\\t')\r\n\t\t\t\t\t\tnextPadding += ch;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (nextPadding.length > curPadding.length) {\r\n\t\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\teditor.replaceContent(nl, caretPos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Inserts newline character with proper indentation in specific positions only.\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @return {Boolean} Returns <code>true</code> if line break was inserted \r\n\t\t */\r\n\t\tinsertLineBreakOnlyAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\tvar nl = '\\n';\r\n\t\t\tvar pad = '\\t';\r\n\t\t\t\r\n\t\t\tif (~xmlSyntaxes.indexOf(info.syntax)) {\r\n\t\t\t\t// let's see if we're breaking newly created tag\r\n\t\t\t\tvar tag = htmlMatcher.tag(info.content, caretPos);\r\n\t\t\t\tif (tag && !tag.innerRange.length()) {\r\n\t\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else if (info.syntax == 'css') {\r\n\t\t\t\t/** @type String */\r\n\t\t\t\tvar content = info.content;\r\n\t\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\r\n\t\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\r\n\t\t\t\t\tif (!hasCloseBrace) {\r\n\t\t\t\t\t\t// do we really need special formatting here?\r\n\t\t\t\t\t\t// check if this is really a newly created rule,\r\n\t\t\t\t\t\t// look ahead for a closing brace\r\n\t\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\r\n\t\t\t\t\t\t\tch = content.charAt(i);\r\n\t\t\t\t\t\t\tif (ch == '{') {\r\n\t\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (ch == '}') {\r\n\t\t\t\t\t\t\t\t// not a new rule, just add indentation\r\n\t\t\t\t\t\t\t\tappend = '';\r\n\t\t\t\t\t\t\t\thasCloseBrace = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!hasCloseBrace) {\r\n\t\t\t\t\t\tappend += '}';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// defining rule set\r\n\t\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\r\n\t\t\t\t\teditor.replaceContent(insValue, caretPos);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\main.js\":[function(require,module,exports){\r\n/**\r\n * Module describes and performs Emmet actions. The actions themselves are\r\n * defined in <i>actions</i> folder\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\r\n\t// all registered actions\r\n\tvar actions = {};\r\n\r\n\t// load all default actions\r\n\tvar actionModules = {\r\n\t\tbase64: require('./base64'),\r\n\t\teditPoints: require('./editPoints'),\r\n\t\tevaluateMath: require('./evaluateMath'),\r\n\t\texpandAbbreviation: require('./expandAbbreviation'),\r\n\t\tincrementDecrement: require('./incrementDecrement'),\r\n\t\tlineBreaks: require('./lineBreaks'),\r\n\t\tbalance: require('./balance'),\r\n\t\tmergeLines: require('./mergeLines'),\r\n\t\treflectCSSValue: require('./reflectCSSValue'),\r\n\t\tremoveTag: require('./removeTag'),\r\n\t\tselectItem: require('./selectItem'),\r\n\t\tselectLine: require('./selectLine'),\r\n\t\tsplitJoinTag: require('./splitJoinTag'),\r\n\t\ttoggleComment: require('./toggleComment'),\r\n\t\tupdateImageSize: require('./updateImageSize'),\r\n\t\twrapWithAbbreviation: require('./wrapWithAbbreviation'),\r\n\t\tupdateTag: require('./updateTag')\r\n\t};\r\n\r\n\tfunction addAction(name, fn, options) {\r\n\t\tname = name.toLowerCase();\r\n\t\toptions = options || {};\r\n\t\t\r\n\t\tif (typeof options === 'string') {\r\n\t\t\toptions = {label: options};\r\n\t\t}\r\n\r\n\t\tif (!options.label) {\r\n\t\t\toptions.label = humanizeActionName(name);\r\n\t\t}\r\n\t\t\r\n\t\tactions[name] = {\r\n\t\t\tname: name,\r\n\t\t\tfn: fn,\r\n\t\t\toptions: options\r\n\t\t};\r\n\t}\r\n\t\r\n\t/**\r\n\t * “Humanizes” action name, makes it more readable for people\r\n\t * @param {String} name Action name (like 'expand_abbreviation')\r\n\t * @return Humanized name (like 'Expand Abbreviation')\r\n\t */\r\n\tfunction humanizeActionName(name) {\r\n\t\treturn utils.trim(name.charAt(0).toUpperCase() \r\n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\r\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\r\n\t\t\t}));\r\n\t}\r\n\r\n\tvar bind = function(name, method) {\r\n\t\tvar m = actionModules[name];\r\n\t\treturn m[method].bind(m);\r\n\t};\r\n\r\n\t// XXX register default actions\r\n\taddAction('encode_decode_data_url', bind('base64', 'encodeDecodeDataUrlAction'), 'Encode\\\\Decode data:URL image');\r\n\taddAction('prev_edit_point', bind('editPoints', 'previousEditPointAction'), 'Previous Edit Point');\r\n\taddAction('next_edit_point', bind('editPoints', 'nextEditPointAction'), 'Next Edit Point');\r\n\taddAction('evaluate_math_expression', bind('evaluateMath', 'evaluateMathAction'), 'Numbers/Evaluate Math Expression');\r\n\taddAction('expand_abbreviation_with_tab', bind('expandAbbreviation', 'expandAbbreviationWithTabAction'), {hidden: true});\r\n\taddAction('expand_abbreviation', bind('expandAbbreviation', 'expandAbbreviationAction'), 'Expand Abbreviation');\r\n\taddAction('insert_formatted_line_break_only', bind('lineBreaks', 'insertLineBreakOnlyAction'), {hidden: true});\r\n\taddAction('insert_formatted_line_break', bind('lineBreaks', 'insertLineBreakAction'), {hidden: true});\r\n\taddAction('balance_inward', bind('balance', 'balanceInwardAction'), 'Balance (inward)');\r\n\taddAction('balance_outward', bind('balance', 'balanceOutwardAction'), 'Balance (outward)');\r\n\taddAction('matching_pair', bind('balance', 'goToMatchingPairAction'), 'HTML/Go To Matching Tag Pair');\r\n\taddAction('merge_lines', bind('mergeLines', 'mergeLinesAction'), 'Merge Lines');\r\n\taddAction('reflect_css_value', bind('reflectCSSValue', 'reflectCSSValueAction'), 'CSS/Reflect Value');\r\n\taddAction('remove_tag', bind('removeTag', 'removeTagAction'), 'HTML/Remove Tag');\r\n\taddAction('select_next_item', bind('selectItem', 'selectNextItemAction'), 'Select Next Item');\r\n\taddAction('select_previous_item', bind('selectItem', 'selectPreviousItemAction'), 'Select Previous Item');\r\n\taddAction('split_join_tag', bind('splitJoinTag', 'splitJoinTagAction'), 'HTML/Split\\\\Join Tag Declaration');\r\n\taddAction('toggle_comment', bind('toggleComment', 'toggleCommentAction'), 'Toggle Comment');\r\n\taddAction('update_image_size', bind('updateImageSize', 'updateImageSizeAction'), 'Update Image Size');\r\n\taddAction('wrap_with_abbreviation', bind('wrapWithAbbreviation', 'wrapWithAbbreviationAction'), 'Wrap With Abbreviation');\r\n\taddAction('update_tag', bind('updateTag', 'updateTagAction'), 'HTML/Update Tag');\r\n\r\n\t[1, -1, 10, -10, 0.1, -0.1].forEach(function(num) {\r\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\r\n\t\tvar suffix = String(Math.abs(num)).replace('.', '').substring(0, 2);\r\n\t\tvar actionId = prefix + '_number_by_' + suffix;\r\n\t\tvar actionMethod = prefix + suffix + 'Action';\r\n\t\tvar actionLabel = 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num);\r\n\t\taddAction(actionId, bind('incrementDecrement', actionMethod), actionLabel);\r\n\t});\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Registers new action\r\n\t\t * @param {String} name Action name\r\n\t\t * @param {Function} fn Action function\r\n\t\t * @param {Object} options Custom action options:<br>\r\n\t\t * <b>label</b> : (<code>String</code>) – Human-readable action name. \r\n\t\t * May contain '/' symbols as submenu separators<br>\r\n\t\t * <b>hidden</b> : (<code>Boolean</code>) – Indicates whether action\r\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\r\n\t\t */\r\n\t\tadd: addAction,\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns action object\r\n\t\t * @param {String} name Action name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\treturn actions[name.toLowerCase()];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Runs Emmet action. For list of available actions and their\r\n\t\t * arguments see <i>actions</i> folder.\r\n\t\t * @param {String} name Action name \r\n\t\t * @param {Array} args Additional arguments. It may be array of arguments\r\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\r\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\r\n\t\t * means action was performed successfully.\r\n\t\t * @example\r\n\t\t * require('action/main').run('expand_abbreviation', editor);  \r\n\t\t * require('action/main').run('wrap_with_abbreviation', [editor, 'div']);  \r\n\t\t */\r\n\t\trun: function(name, args) {\r\n\t\t\tif (!Array.isArray(args)) {\r\n\t\t\t\targs = utils.toArray(arguments, 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar action = this.get(name);\r\n\t\t\tif (!action) {\r\n\t\t\t\tthrow new Error('Action \"' + name + '\" is not defined');\r\n\t\t\t}\r\n\r\n\t\t\treturn action.fn.apply(action, args);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all registered actions as object\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetAll: function() {\r\n\t\t\treturn actions;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all registered actions as array\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetList: function() {\r\n\t\t\tvar all = this.getAll();\r\n\t\t\treturn Object.keys(all).map(function(key) {\r\n\t\t\t\treturn all[key];\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\r\n\t\t * it will be splitted by '/' symbol into submenus (for example: \r\n\t\t * CSS/Reflect Value) and grouped with other items\r\n\t\t * @param {Array} skipActions List of action identifiers that should be \r\n\t\t * skipped from menu\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetMenu: function(skipActions) {\r\n\t\t\tvar result = [];\r\n\t\t\tskipActions = skipActions || [];\r\n\t\t\tthis.getList().forEach(function(action) {\r\n\t\t\t\tif (action.options.hidden || ~skipActions.indexOf(action.name))\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t\tvar actionName = humanizeActionName(action.name);\r\n\t\t\t\tvar ctx = result;\r\n\t\t\t\tif (action.options.label) {\r\n\t\t\t\t\tvar parts = action.options.label.split('/');\r\n\t\t\t\t\tactionName = parts.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// create submenus, if needed\r\n\t\t\t\t\tvar menuName, submenu;\r\n\t\t\t\t\twhile ((menuName = parts.shift())) {\r\n\t\t\t\t\t\tsubmenu = utils.find(ctx, function(item) {\r\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!submenu) {\r\n\t\t\t\t\t\t\tsubmenu = {\r\n\t\t\t\t\t\t\t\tname: menuName,\r\n\t\t\t\t\t\t\t\ttype: 'submenu',\r\n\t\t\t\t\t\t\t\titems: []\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tctx.push(submenu);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tctx = submenu.items;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tctx.push({\r\n\t\t\t\t\ttype: 'action',\r\n\t\t\t\t\tname: action.name,\r\n\t\t\t\t\tlabel: actionName\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns action name associated with menu item title\r\n\t\t * @param {String} title\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetActionNameForMenuTitle: function(title, menu) {\r\n\t\t\treturn utils.find(menu || this.getMenu(), function(val) {\r\n\t\t\t\tif (val.type == 'action') {\r\n\t\t\t\t\tif (val.label == title || val.name == title) {\r\n\t\t\t\t\t\treturn val.name;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.getActionNameForMenuTitle(title, val.items);\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./balance\":\"action\\\\balance.js\",\"./base64\":\"action\\\\base64.js\",\"./editPoints\":\"action\\\\editPoints.js\",\"./evaluateMath\":\"action\\\\evaluateMath.js\",\"./expandAbbreviation\":\"action\\\\expandAbbreviation.js\",\"./incrementDecrement\":\"action\\\\incrementDecrement.js\",\"./lineBreaks\":\"action\\\\lineBreaks.js\",\"./mergeLines\":\"action\\\\mergeLines.js\",\"./reflectCSSValue\":\"action\\\\reflectCSSValue.js\",\"./removeTag\":\"action\\\\removeTag.js\",\"./selectItem\":\"action\\\\selectItem.js\",\"./selectLine\":\"action\\\\selectLine.js\",\"./splitJoinTag\":\"action\\\\splitJoinTag.js\",\"./toggleComment\":\"action\\\\toggleComment.js\",\"./updateImageSize\":\"action\\\\updateImageSize.js\",\"./updateTag\":\"action\\\\updateTag.js\",\"./wrapWithAbbreviation\":\"action\\\\wrapWithAbbreviation.js\"}],\"action\\\\mergeLines.js\":[function(require,module,exports){\r\n/**\r\n * Merges selected lines or lines between XHTML tag pairs\r\n * @param {Function} require\r\n * @param {Underscore} _\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar range = require('../assets/range');\r\n\r\n\treturn {\r\n\t\tmergeLinesAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\r\n\t\t\tvar selection = range(editor.getSelectionRange());\r\n\t\t\tif (!selection.length()) {\r\n\t\t\t\t// find matching tag\r\n\t\t\t\tvar pair = htmlMatcher.find(info.content, editor.getCaretPos());\r\n\t\t\t\tif (pair) {\r\n\t\t\t\t\tselection = pair.outerRange;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (selection.length()) {\r\n\t\t\t\t// got range, merge lines\r\n\t\t\t\tvar text =  selection.substring(info.content);\r\n\t\t\t\tvar lines = utils.splitByLines(text);\r\n\t\t\t\t\r\n\t\t\t\tfor (var i = 1; i < lines.length; i++) {\r\n\t\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\r\n\t\t\t\tvar textLen = text.length;\r\n\t\t\t\ttext = utils.escapeText(text);\r\n\t\t\t\teditor.replaceContent(text, selection.start, selection.end);\r\n\t\t\t\teditor.createSelection(selection.start, selection.start + textLen);\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\reflectCSSValue.js\":[function(require,module,exports){\r\n/**\r\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \r\n * rules with vendor prefixes\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar handlerList = require('../assets/handlerList');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar cssResolver = require('../resolver/css');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar utils = require('../utils/common');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar cssGradient = require('../resolver/cssGradient');\r\n\r\n\tprefs.define('css.reflect.oldIEOpacity', false, 'Support IE6/7/8 opacity notation, e.g. <code>filter:alpha(opacity=...)</code>.\\\r\n\t\tNote that CSS3 and SVG also provides <code>filter</code> property so this option is disabled by default.')\r\n\r\n\t/**\r\n\t * @type HandlerList List of registered handlers\r\n\t */\r\n\tvar handlers = handlerList.create();\r\n\t\r\n\tfunction doCSSReflection(editor) {\r\n\t\tvar outputInfo = editorUtils.outputInfo(editor);\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\r\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\r\n\t\tif (!cssRule) return;\r\n\t\t\r\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\r\n\t\t// no property under cursor, nothing to reflect\r\n\t\tif (!property) return;\r\n\t\t\r\n\t\tvar oldRule = cssRule.source;\r\n\t\tvar offset = cssRule.options.offset;\r\n\t\tvar caretDelta = caretPos - offset - property.range().start;\r\n\t\t\r\n\t\thandlers.exec(false, [property]);\r\n\t\t\r\n\t\tif (oldRule !== cssRule.source) {\r\n\t\t\treturn {\r\n\t\t\t\tdata:  cssRule.source,\r\n\t\t\t\tstart: offset,\r\n\t\t\t\tend:   offset + oldRule.length,\r\n\t\t\t\tcaret: offset + property.range().start + caretDelta\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns regexp that should match reflected CSS property names\r\n\t * @param {String} name Current CSS property name\r\n\t * @return {RegExp}\r\n\t */\r\n\tfunction getReflectedCSSName(name) {\r\n\t\tname = cssEditTree.baseName(name);\r\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\r\n\t\t\r\n\t\tif ((name == 'opacity' || name == 'filter') && prefs.get('css.reflect.oldIEOpacity')) {\r\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\r\n\t\t} else if ((m = name.match(/^border-radius-(top|bottom)(left|right)/))) {\r\n\t\t\t// Mozilla-style border radius\r\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\r\n\t\t} else if ((m = name.match(/^border-(top|bottom)-(left|right)-radius/))) { \r\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\r\n\t\t}\r\n\t\t\r\n\t\treturn new RegExp(vendorPrefix + name + '$');\r\n\t}\r\n\r\n\t/**\r\n\t * Reflects inner CSS properites in given value\r\n\t * agains name‘s vendor prefix. In other words, it tries\r\n\t * to modify `transform 0.2s linear` value for `-webkit-transition`\r\n\t * property\r\n\t * @param  {String} name  Reciever CSS property name\r\n\t * @param  {String} value New property value\r\n\t * @return {String}\r\n\t */\r\n\tfunction reflectValueParts(name, value) {\r\n\t\t// detects and updates vendor-specific properties in value,\r\n\t\t// e.g. -webkit-transition: -webkit-transform\r\n\t\t\r\n\t\tvar reVendor = /^\\-(\\w+)\\-/;\r\n\t\tvar propPrefix = reVendor.test(name) ? RegExp.$1.toLowerCase() : '';\r\n\t\tvar parts = cssEditTree.findParts(value);\r\n\r\n\t\tparts.reverse();\r\n\t\tparts.forEach(function(part) {\r\n\t\t\tvar partValue = part.substring(value).replace(reVendor, '');\r\n\t\t\tvar prefixes = cssResolver.vendorPrefixes(partValue);\r\n\t\t\tif (prefixes) {\r\n\t\t\t\t// if prefixes are not null then given value can\r\n\t\t\t\t// be resolved against Can I Use database and may or\r\n\t\t\t\t// may not contain prefixed variant\r\n\t\t\t\tif (propPrefix && ~prefixes.indexOf(propPrefix)) {\r\n\t\t\t\t\tpartValue = '-' + propPrefix + '-' + partValue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue = utils.replaceSubstring(value, partValue, part);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn value;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\r\n\t * @param {CSSProperty} donor Donor CSS property from which value should\r\n\t * be reflected\r\n\t * @param {CSSProperty} receiver Property that should receive reflected \r\n\t * value from donor\r\n\t */\r\n\tfunction reflectValue(donor, receiver) {\r\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \r\n\t\t\t\treceiver.name(), receiver.value());\r\n\t\t\r\n\t\tvalue = reflectValueParts(receiver.name(), value);\r\n\t\treceiver.value(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns value that should be reflected for <code>refName</code> CSS property\r\n\t * from <code>curName</code> property. This function is used for special cases,\r\n\t * when the same result must be achieved with different properties for different\r\n\t * browsers. For example: opаcity:0.5; → filter:alpha(opacity=50);<br><br>\r\n\t * \r\n\t * This function does value conversion between different CSS properties\r\n\t * \r\n\t * @param {String} curName Current CSS property name\r\n\t * @param {String} curValue Current CSS property value\r\n\t * @param {String} refName Receiver CSS property's name \r\n\t * @param {String} refValue Receiver CSS property's value\r\n\t * @return {String} New value for receiver property\r\n\t */\r\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\r\n\t\tcurName = cssEditTree.baseName(curName);\r\n\t\trefName = cssEditTree.baseName(refName);\r\n\t\t\r\n\t\tif (curName == 'opacity' && refName == 'filter') {\r\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\r\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\r\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\r\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1], 10) / 100) : refValue;\r\n\t\t}\r\n\t\t\r\n\t\treturn curValue;\r\n\t}\r\n\t\r\n\tmodule = module || {};\r\n\tmodule.exports = {\r\n\t\treflectCSSValueAction: function(editor) {\r\n\t\t\tif (editor.getSyntax() != 'css') {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn actionUtils.compoundUpdate(editor, doCSSReflection(editor));\r\n\t\t},\r\n\r\n\t\t_defaultHandler: function(property) {\r\n\t\t\tvar reName = getReflectedCSSName(property.name());\r\n\t\t\tproperty.parent.list().forEach(function(p) {\r\n\t\t\t\tif (reName.test(p.name())) {\r\n\t\t\t\t\treflectValue(property, p);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds custom reflect handler. The passed function will receive matched\r\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\r\n\t\t * return <code>true</code> if it was performed successfully (handled \r\n\t\t * reflection), <code>false</code> otherwise.\r\n\t\t * @param {Function} fn\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\taddHandler: function(fn, options) {\r\n\t\t\thandlers.add(fn, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered handler\r\n\t\t * @returns\r\n\t\t */\r\n\t\tremoveHandler: function(fn) {\r\n\t\t\thandlers.remove(fn);\r\n\t\t}\r\n\t};\r\n\r\n\t// XXX add default handlers\r\n\thandlers.add(module.exports._defaultHandler.bind(module.exports), {order: -1});\r\n\thandlers.add(cssGradient.reflectValueHandler.bind(cssGradient));\r\n\r\n\treturn module.exports;\r\n});\r\n},{\"../assets/handlerList\":\"assets\\\\handlerList.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../resolver/css\":\"resolver\\\\css.js\",\"../resolver/cssGradient\":\"resolver\\\\cssGradient.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\removeTag.js\":[function(require,module,exports){\r\n/**\r\n * Gracefully removes tag under cursor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\r\n\treturn {\r\n\t\tremoveTagAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\t\r\n\t\t\t// search for tag\r\n\t\t\tvar tag = htmlMatcher.tag(info.content, editor.getCaretPos());\r\n\t\t\tif (tag) {\r\n\t\t\t\tif (!tag.close) {\r\n\t\t\t\t\t// simply remove unary tag\r\n\t\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// remove tag and its newlines\r\n\t\t\t\t\t/** @type Range */\r\n\t\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\r\n\t\t\t\t\t/** @type Range */\r\n\t\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\r\n\t\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\r\n\t\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\r\n\t\t\t\t\t\r\n\t\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\r\n\t\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\selectItem.js\":[function(require,module,exports){\r\n/**\r\n * Actions that use stream parsers and tokenizers for traversing:\r\n * -- Search for next/previous items in HTML\r\n * -- Search for next/previous items in CSS\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar xmlParser = require('../parser/xml');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar cssSections = require('../utils/cssSections');\r\n\r\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\r\n\r\n\t/**\r\n\t * Generic function for searching for items to select\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\r\n\t * @param {Function} extractFn Function that extracts item content\r\n\t * @param {Function} rangeFn Function that search for next token range\r\n\t */\r\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\r\n\t\tvar content = editorUtils.outputInfo(editor).content;\r\n\t\t\r\n\t\tvar contentLength = content.length;\r\n\t\tvar itemRange, rng;\r\n\t\t/** @type Range */\r\n\t\tvar prevRange = range(-1, 0);\r\n\t\t/** @type Range */\r\n\t\tvar sel = range(editor.getSelectionRange());\r\n\t\t\r\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\r\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\r\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\r\n\t\t\t\tif (prevRange.equal(itemRange)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tprevRange = itemRange.clone();\r\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\r\n\t\t\t\t\r\n\t\t\t\tif (rng) {\r\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsearchPos += isBackward ? -1 : 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// XXX HTML section\r\n\t\r\n\t/**\r\n\t * Find next HTML item\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction findNextHTMLItem(editor) {\r\n\t\tvar isFirst = true;\r\n\t\treturn findItem(editor, false, function(content, searchPos){\r\n\t\t\tif (isFirst) {\r\n\t\t\t\tisFirst = false;\r\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\r\n\t\t\t} else {\r\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\r\n\t\t\t}\r\n\t\t}, function(tag, offset, selRange) {\r\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Find previous HTML item\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction findPrevHTMLItem(editor) {\r\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\r\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates possible selection ranges for HTML tag\r\n\t * @param {String} source Original HTML source for tokens\r\n\t * @param {Array} tokens List of HTML tokens\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\r\n\t\toffset = offset || 0;\r\n\t\tvar result = [];\r\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\r\n\t\ttokens.forEach(function(tok) {\r\n\t\t\tswitch (tok.type) {\r\n\t\t\t\tcase 'tag':\r\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\r\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\r\n\t\t\t\t\t\t// add tag name\r\n\t\t\t\t\t\tresult.push(range({\r\n\t\t\t\t\t\t\tstart: tok.start + 1, \r\n\t\t\t\t\t\t\tend: tok.end\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'attribute':\r\n\t\t\t\t\tattrStart = tok.start;\r\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\t// attribute value\r\n\t\t\t\t\t// push full attribute first\r\n\t\t\t\t\tresult.push(range(attrStart, tok.end - attrStart));\r\n\t\t\t\t\t\r\n\t\t\t\t\tattrValueRange = range(tok);\r\n\t\t\t\t\tattrValue = attrValueRange.substring(source);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// is this a quoted attribute?\r\n\t\t\t\t\tif (isQuote(attrValue.charAt(0)))\r\n\t\t\t\t\t\tattrValueRange.start++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (isQuote(attrValue.charAt(attrValue.length - 1)))\r\n\t\t\t\t\t\tattrValueRange.end--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult.push(attrValueRange);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (attrName == 'class') {\r\n\t\t\t\t\t\tresult = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// offset ranges\r\n\t\tresult = result.filter(function(item) {\r\n\t\t\tif (item.length()) {\r\n\t\t\t\titem.shift(offset);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// remove duplicates\r\n\t\treturn utils.unique(result, function(item) {\r\n\t\t\treturn item.toString();\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns ranges of class names in \"class\" attribute value\r\n\t * @param {String} className\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction classNameRanges(className, offset) {\r\n\t\toffset = offset || 0;\r\n\t\tvar result = [];\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(className);\r\n\t\t\r\n\t\t// skip whitespace\r\n\t\tstream.eatSpace();\r\n\t\tstream.start = stream.pos;\r\n\t\t\r\n\t\tvar ch;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\r\n\t\t\t\tresult.push(range(stream.start + offset, stream.pos - stream.start - 1));\r\n\t\t\t\tstream.eatSpace();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tresult.push(range(stream.start + offset, stream.pos - stream.start));\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns best HTML tag range match for current selection\r\n\t * @param {String} tag Tag declaration\r\n\t * @param {Number} offset Tag's position index inside content\r\n\t * @param {Range} selRange Selection range\r\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\r\n\t */\r\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\r\n\t\tvar ranges = makePossibleRangesHTML(tag, xmlParser.parse(tag), offset);\r\n\t\t\r\n\t\tif (isBackward)\r\n\t\t\tranges.reverse();\r\n\t\t\r\n\t\t// try to find selected range\r\n\t\tvar curRange = utils.find(ranges, function(r) {\r\n\t\t\treturn r.equal(selRange);\r\n\t\t});\r\n\t\t\r\n\t\tif (curRange) {\r\n\t\t\tvar ix = ranges.indexOf(curRange);\r\n\t\t\tif (ix < ranges.length - 1)\r\n\t\t\t\treturn ranges[ix + 1];\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\t// no selected range, find nearest one\r\n\t\tif (isBackward)\r\n\t\t\t// search backward\r\n\t\t\treturn utils.find(ranges, function(r) {\r\n\t\t\t\treturn r.start < selRange.start;\r\n\t\t\t});\r\n\t\t\r\n\t\t// search forward\r\n\t\t// to deal with overlapping ranges (like full attribute definition\r\n\t\t// and attribute value) let's find range under caret first\r\n\t\tif (!curRange) {\r\n\t\t\tvar matchedRanges = ranges.filter(function(r) {\r\n\t\t\t\treturn r.inside(selRange.end);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (matchedRanges.length > 1)\r\n\t\t\t\treturn matchedRanges[1];\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn utils.find(ranges, function(r) {\r\n\t\t\treturn r.end > selRange.end;\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Search for opening tag in content, starting at specified position\r\n\t * @param {String} html Where to search tag\r\n\t * @param {Number} pos Character index where to start searching\r\n\t * @return {Range} Returns range if valid opening tag was found,\r\n\t * <code>null</code> otherwise\r\n\t */\r\n\tfunction findOpeningTagFromPosition(html, pos) {\r\n\t\tvar tag;\r\n\t\twhile (pos >= 0) {\r\n\t\t\tif ((tag = getOpeningTagFromPosition(html, pos)))\r\n\t\t\t\treturn tag;\r\n\t\t\tpos--;\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param {String} html Where to search tag\r\n\t * @param {Number} pos Character index where to start searching\r\n\t * @return {Range} Returns range if valid opening tag was found,\r\n\t * <code>null</code> otherwise\r\n\t */\r\n\tfunction getOpeningTagFromPosition(html, pos) {\r\n\t\tvar m;\r\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\r\n\t\t\treturn range(pos, m[0]);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction isQuote(ch) {\r\n\t\treturn ch == '\"' || ch == \"'\";\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all ranges inside given rule, available for selection\r\n\t * @param  {CSSEditContainer} rule\r\n\t * @return {Array}\r\n\t */\r\n\tfunction findInnerRanges(rule) {\r\n\t\t// rule selector\r\n\t\tvar ranges = [rule.nameRange(true)];\r\n\r\n\t\t// find nested sections, keep selectors only\r\n\t\tvar nestedSections = cssSections.nestedSectionsInRule(rule);\r\n\t\tnestedSections.forEach(function(section) {\r\n\t\t\tranges.push(range.create2(section.start, section._selectorEnd));\r\n\t\t});\r\n\r\n\t\t// add full property ranges and values\r\n\t\trule.list().forEach(function(property) {\r\n\t\t\tranges = ranges.concat(makePossibleRangesCSS(property));\r\n\t\t});\r\n\r\n\t\tranges = range.sort(ranges);\r\n\r\n\t\t// optimize result: remove empty ranges and duplicates\r\n\t\tranges = ranges.filter(function(item) {\r\n\t\t\treturn !!item.length();\r\n\t\t});\r\n\t\treturn utils.unique(ranges, function(item) {\r\n\t\t\treturn item.toString();\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Makes all possible selection ranges for specified CSS property\r\n\t * @param {CSSProperty} property\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction makePossibleRangesCSS(property) {\r\n\t\t// find all possible ranges, sorted by position and size\r\n\t\tvar valueRange = property.valueRange(true);\r\n\t\tvar result = [property.range(true), valueRange];\r\n\t\t\r\n\t\t// locate parts of complex values.\r\n\t\t// some examples:\r\n\t\t// – 1px solid red: 3 parts\r\n\t\t// – arial, sans-serif: enumeration, 2 parts\r\n\t\t// – url(image.png): function value part\r\n\t\tvar value = property.value();\r\n\t\tproperty.valueParts().forEach(function(r) {\r\n\t\t\t// add absolute range\r\n\t\t\tvar clone = r.clone();\r\n\t\t\tresult.push(clone.shift(valueRange.start));\r\n\t\t\t\r\n\t\t\t/** @type StringStream */\r\n\t\t\tvar stream = stringStream.create(r.substring(value));\r\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\r\n\t\t\t\t// we have a function, find values in it.\r\n\t\t\t\t// but first add function contents\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tstream.skipToPair('(', ')');\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tvar fnBody = stream.current();\r\n\t\t\t\tresult.push(range(clone.start + stream.start, fnBody));\r\n\t\t\t\t\r\n\t\t\t\t// find parts\r\n\t\t\t\tcssEditTree.findParts(fnBody).forEach(function(part) {\r\n\t\t\t\t\tresult.push(range(clone.start + stream.start + part.start, part.substring(fnBody)));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Tries to find matched CSS property and nearest range for selection\r\n\t * @param {CSSRule} rule\r\n\t * @param {Range} selRange\r\n\t * @param {Boolean} isBackward\r\n\t * @returns {Range}\r\n\t */\r\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\r\n\t\tvar ranges = findInnerRanges(rule);\r\n\t\tif (isBackward) {\r\n\t\t\tranges.reverse();\r\n\t\t}\r\n\t\t\r\n\t\t// return next to selected range, if possible\r\n\t\tvar r = utils.find(ranges, function(item) {\r\n\t\t\treturn item.equal(selRange);\r\n\t\t});\r\n\r\n\t\tif (r) {\r\n\t\t\treturn ranges[ranges.indexOf(r) + 1];\r\n\t\t}\r\n\r\n\t\t// find matched and (possibly) overlapping ranges\r\n\t\tvar nested = ranges.filter(function(item) {\r\n\t\t\treturn item.inside(selRange.end);\r\n\t\t});\r\n\r\n\t\tif (nested.length) {\r\n\t\t\treturn nested.sort(function(a, b) {\r\n\t\t\t\treturn a.length() - b.length();\r\n\t\t\t})[0];\r\n\t\t}\r\n\r\n\t\t// return range next to caret\r\n\t\tvar test = \r\n\t\tr = utils.find(ranges, isBackward \r\n\t\t\t? function(item) {return item.end < selRange.start;}\r\n\t\t\t: function(item) {return item.end > selRange.start;}\r\n\t\t);\r\n\r\n\t\tif (!r) {\r\n\t\t\t// can’t find anything, just pick first one\r\n\t\t\tr = ranges[0];\r\n\t\t}\r\n\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tfunction findNextCSSItem(editor) {\r\n\t\treturn findItem(editor, false, cssSections.locateRule.bind(cssSections), getRangeForNextItemInCSS);\r\n\t}\r\n\t\r\n\tfunction findPrevCSSItem(editor) {\r\n\t\treturn findItem(editor, true, cssSections.locateRule.bind(cssSections), getRangeForPrevItemInCSS);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns range for item to be selected in CSS after current caret \r\n\t * (selection) position\r\n\t * @param {String} rule CSS rule declaration\r\n\t * @param {Number} offset Rule's position index inside content\r\n\t * @param {Range} selRange Selection range\r\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\r\n\t */\r\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\r\n\t\tvar tree = cssEditTree.parse(rule, {\r\n\t\t\toffset: offset\r\n\t\t});\r\n\r\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns range for item to be selected in CSS before current caret \r\n\t * (selection) position\r\n\t * @param {String} rule CSS rule declaration\r\n\t * @param {Number} offset Rule's position index inside content\r\n\t * @param {Range} selRange Selection range\r\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\r\n\t */\r\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\r\n\t\tvar tree = cssEditTree.parse(rule, {\r\n\t\t\toffset: offset\r\n\t\t});\r\n\r\n\t\treturn matchedRangeForCSSProperty(tree, selRange, true);\r\n\t}\r\n\r\n\treturn {\r\n\t\tselectNextItemAction: function(editor) {\r\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\r\n\t\t\t\treturn findNextCSSItem(editor);\r\n\t\t\t} else {\r\n\t\t\t\treturn findNextHTMLItem(editor);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tselectPreviousItemAction: function(editor) {\r\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\r\n\t\t\t\treturn findPrevCSSItem(editor);\r\n\t\t\t} else {\r\n\t\t\t\treturn findPrevHTMLItem(editor);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../parser/xml\":\"parser\\\\xml.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\selectLine.js\":[function(require,module,exports){\r\n/**\r\n * Select current line (for simple editors like browser's &lt;textarea&gt;)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\treturn {\r\n\t\tselectLineAction: function(editor) {\r\n\t\t\tvar range = editor.getCurrentLineRange();\r\n\t\t\teditor.createSelection(range.start, range.end);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"action\\\\splitJoinTag.js\":[function(require,module,exports){\r\n/**\r\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\r\n * &lt;div&gt;&lt;/div&gt; → &lt;div /&gt; : join<br>\r\n * &lt;div /&gt; → &lt;div&gt;&lt;/div&gt; : split\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar resources = require('../assets/resources');\r\n\tvar matcher = require('../assets/htmlMatcher');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar profile = require('../assets/profile');\r\n\r\n\t/**\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {Object} profile\r\n\t * @param {Object} tag\r\n\t */\r\n\tfunction joinTag(editor, profile, tag) {\r\n\t\t// empty closing slash is a nonsense for this action\r\n\t\tvar slash = profile.selfClosing() || ' /';\r\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\r\n\t\t\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\r\n\t\t// update caret position\r\n\t\tif (content.length + tag.outerRange.start < caretPos) {\r\n\t\t\tcaretPos = content.length + tag.outerRange.start;\r\n\t\t}\r\n\t\t\r\n\t\tcontent = utils.escapeText(content);\r\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\r\n\t\teditor.setCaretPos(caretPos);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction splitTag(editor, profile, tag) {\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\r\n\t\t// define tag content depending on profile\r\n\t\tvar tagContent = (profile.tag_nl === true) ? '\\n\\t\\n' : '';\r\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\r\n\t\tcaretPos = tag.outerRange.start + content.length;\r\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\r\n\t\t\r\n\t\tcontent = utils.escapeText(content);\r\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\r\n\t\teditor.setCaretPos(caretPos);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn {\r\n\t\tsplitJoinTagAction: function(editor, profileName) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor, null, profileName);\r\n\t\t\tvar curProfile = profile.get(info.profile);\r\n\t\t\t\r\n\t\t\t// find tag at current position\r\n\t\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\r\n\t\t\tif (tag) {\r\n\t\t\t\treturn tag.close \r\n\t\t\t\t\t? joinTag(editor, curProfile, tag) \r\n\t\t\t\t\t: splitTag(editor, curProfile, tag);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\toggleComment.js\":[function(require,module,exports){\r\n/**\r\n * Toggles HTML and CSS comments depending on current caret context. Unlike\r\n * the same action in most editors, this action toggles comment on currently\r\n * matched item—HTML tag or CSS selector—when nothing is selected.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\r\n\t/**\r\n\t * Toggle HTML comment on current selection or tag\r\n\t * @param {IEmmetEditor} editor\r\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\r\n\t */\r\n\tfunction toggleHTMLComment(editor) {\r\n\t\t/** @type Range */\r\n\t\tvar r = range(editor.getSelectionRange());\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\t\r\n\t\tif (!r.length()) {\r\n\t\t\t// no selection, find matching tag\r\n\t\t\tvar tag = htmlMatcher.tag(info.content, editor.getCaretPos());\r\n\t\t\tif (tag) { // found pair\r\n\t\t\t\tr = tag.outerRange;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn genericCommentToggle(editor, '<!--', '-->', r);\r\n\t}\r\n\r\n\t/**\r\n\t * Simple CSS commenting\r\n\t * @param {IEmmetEditor} editor\r\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\r\n\t */\r\n\tfunction toggleCSSComment(editor) {\r\n\t\t/** @type Range */\r\n\t\tvar rng = range(editor.getSelectionRange());\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\t\r\n\t\tif (!rng.length()) {\r\n\t\t\t// no selection, try to get current rule\r\n\t\t\t/** @type CSSRule */\r\n\t\t\tvar rule = cssEditTree.parseFromPosition(info.content, editor.getCaretPos());\r\n\t\t\tif (rule) {\r\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\r\n\t\t\t\trng = property \r\n\t\t\t\t\t? property.range(true) \r\n\t\t\t\t\t: range(rule.nameRange(true).start, rule.source);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (!rng.length()) {\r\n\t\t\t// still no selection, get current line\r\n\t\t\trng = range(editor.getCurrentLineRange());\r\n\t\t\tutils.narrowToNonSpace(info.content, rng);\r\n\t\t}\r\n\t\t\r\n\t\treturn genericCommentToggle(editor, '/*', '*/', rng);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns CSS property from <code>rule</code> that matches passed position\r\n\t * @param {EditContainer} rule\r\n\t * @param {Number} absPos\r\n\t * @returns {EditElement}\r\n\t */\r\n\tfunction cssItemFromPosition(rule, absPos) {\r\n\t\t// do not use default EditContainer.itemFromPosition() here, because\r\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\r\n\t\tvar relPos = absPos - (rule.options.offset || 0);\r\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\r\n\t\treturn utils.find(rule.list(), function(item) {\r\n\t\t\tif (item.range().end === relPos) {\r\n\t\t\t\t// at the end of property, but outside of it\r\n\t\t\t\t// if there’s a space character at current position,\r\n\t\t\t\t// use current property\r\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn item.range().inside(relPos);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\r\n\t * @param {String} text Where to search\r\n\t * @param {Number} from Search start index\r\n\t * @param {String} start_token Comment start string\r\n\t * @param {String} end_token Comment end string\r\n\t * @return {Range} Returns null if comment wasn't found\r\n\t */\r\n\tfunction searchComment(text, from, startToken, endToken) {\r\n\t\tvar commentStart = -1;\r\n\t\tvar commentEnd = -1;\r\n\t\t\r\n\t\tvar hasMatch = function(str, start) {\r\n\t\t\treturn text.substr(start, str.length) == str;\r\n\t\t};\r\n\t\t\t\r\n\t\t// search for comment start\r\n\t\twhile (from--) {\r\n\t\t\tif (hasMatch(startToken, from)) {\r\n\t\t\t\tcommentStart = from;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (commentStart != -1) {\r\n\t\t\t// search for comment end\r\n\t\t\tfrom = commentStart;\r\n\t\t\tvar contentLen = text.length;\r\n\t\t\twhile (contentLen >= from++) {\r\n\t\t\t\tif (hasMatch(endToken, from)) {\r\n\t\t\t\t\tcommentEnd = from + endToken.length;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn (commentStart != -1 && commentEnd != -1) \r\n\t\t\t? range(commentStart, commentEnd - commentStart) \r\n\t\t\t: null;\r\n\t}\r\n\r\n\t/**\r\n\t * Generic comment toggling routine\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} commentStart Comment start token\r\n\t * @param {String} commentEnd Comment end token\r\n\t * @param {Range} range Selection range\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\r\n\t\tvar content = editorUtils.outputInfo(editor).content;\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\tvar newContent = null;\r\n\t\t\t\r\n\t\t/**\r\n\t\t * Remove comment markers from string\r\n\t\t * @param {Sting} str\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tfunction removeComment(str) {\r\n\t\t\treturn str\r\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\r\n\t\t\t\t\tcaretPos -= str.length;\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\r\n\t\t}\r\n\t\t\r\n\t\t// first, we need to make sure that this substring is not inside \r\n\t\t// comment\r\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\r\n\t\tif (commentRange && commentRange.overlap(range)) {\r\n\t\t\t// we're inside comment, remove it\r\n\t\t\trange = commentRange;\r\n\t\t\tnewContent = removeComment(range.substring(content));\r\n\t\t} else {\r\n\t\t\t// should add comment\r\n\t\t\t// make sure that there's no comment inside selection\r\n\t\t\tnewContent = commentStart + ' ' +\r\n\t\t\t\trange.substring(content)\r\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\r\n\t\t\t\t' ' + commentEnd;\r\n\t\t\t\t\r\n\t\t\t// adjust caret position\r\n\t\t\tcaretPos += commentStart.length + 1;\r\n\t\t}\r\n\r\n\t\t// replace editor content\r\n\t\tif (newContent !== null) {\r\n\t\t\tnewContent = utils.escapeText(newContent);\r\n\t\t\teditor.setCaretPos(range.start);\r\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\r\n\t\t\teditor.setCaretPos(caretPos);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Toggle comment on current editor's selection or HTML tag/CSS rule\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t */\r\n\t\ttoggleCommentAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\tif (actionUtils.isSupportedCSS(info.syntax)) {\r\n\t\t\t\t// in case our editor is good enough and can recognize syntax from \r\n\t\t\t\t// current token, we have to make sure that cursor is not inside\r\n\t\t\t\t// 'style' attribute of html element\r\n\t\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\t\tvar tag = htmlMatcher.tag(info.content, caretPos);\r\n\t\t\t\tif (tag && tag.open.range.inside(caretPos)) {\r\n\t\t\t\t\tinfo.syntax = 'html';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\r\n\t\t\tif (~cssSyntaxes.indexOf(info.syntax)) {\r\n\t\t\t\treturn toggleCSSComment(editor);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn toggleHTMLComment(editor);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\updateImageSize.js\":[function(require,module,exports){\r\n/**\r\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\r\n * CSS rule\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar base64 = require('../utils/base64');\r\n\tvar file = require('../plugin/file');\r\n\r\n\t/**\r\n\t * Updates image size of &lt;img src=\"\"&gt; tag\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction updateImageSizeHTML(editor) {\r\n\t\tvar offset = editor.getCaretPos();\r\n\r\n\t\t// find tag from current caret position\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar xmlElem = xmlEditTree.parseFromPosition(info.content, offset, true);\r\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\r\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\r\n\t\t\t\tif (size) {\r\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\r\n\t\t\t\t\txmlElem.value('width', size.width);\r\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\r\n\r\n\t\t\t\t\tactionUtils.compoundUpdate(editor, utils.extend(compoundData, {\r\n\t\t\t\t\t\tdata: xmlElem.toString(),\r\n\t\t\t\t\t\tcaret: offset\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates image size of CSS property\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction updateImageSizeCSS(editor) {\r\n\t\tvar offset = editor.getCaretPos();\r\n\r\n\t\t// find tag from current caret position\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar cssRule = cssEditTree.parseFromPosition(info.content, offset, true);\r\n\t\tif (cssRule) {\r\n\t\t\t// check if there is property with image under caret\r\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\r\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\r\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\r\n\t\t\t\t\tif (size) {\r\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\r\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\r\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\r\n\r\n\t\t\t\t\t\tactionUtils.compoundUpdate(editor, utils.extend(compoundData, {\r\n\t\t\t\t\t\t\tdata: cssRule.toString(),\r\n\t\t\t\t\t\t\tcaret: offset\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns image dimensions for source\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} src Image source (path or data:url)\r\n\t */\r\n\tfunction getImageSizeForSource(editor, src, callback) {\r\n\t\tvar fileContent;\r\n\t\tif (src) {\r\n\t\t\t// check if it is data:url\r\n\t\t\tif (/^data:/.test(src)) {\r\n\t\t\t\tfileContent = base64.decode( src.replace(/^data\\:.+?;.+?,/, '') );\r\n\t\t\t\treturn callback(actionUtils.getImageSize(fileContent));\r\n\t\t\t}\r\n\r\n\t\t\tvar filePath = editor.getFilePath();\r\n\t\t\tfile.locateFile(filePath, src, function(absPath) {\r\n\t\t\t\tif (absPath === null) {\r\n\t\t\t\t\tthrow \"Can't find \" + src + ' file';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfile.read(absPath, function(err, content) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent = String(content);\r\n\t\t\t\t\tcallback(actionUtils.getImageSize(content));\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tupdateImageSizeAction: function(editor) {\r\n\t\t\t// this action will definitely won’t work in SASS dialect,\r\n\t\t\t// but may work in SCSS or LESS\r\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\r\n\t\t\t\tupdateImageSizeCSS(editor);\r\n\t\t\t} else {\r\n\t\t\t\tupdateImageSizeHTML(editor);\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../editTree/css\":\"editTree\\\\css.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../plugin/file\":\"plugin\\\\file.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/base64\":\"utils\\\\base64.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\updateTag.js\":[function(require,module,exports){\r\n/**\r\n * Update Tag action: allows users to update existing HTML tags and add/remove\r\n * attributes or even tag name\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar utils = require('../utils/common');\r\n\tvar parser = require('../parser/abbreviation');\r\n\r\n\tfunction updateAttributes(tag, abbrNode, ix) {\r\n\t\tvar classNames = (abbrNode.attribute('class') || '').split(/\\s+/g);\r\n\t\tif (ix) {\r\n\t\t\tclassNames.push('+' + abbrNode.name());\r\n\t\t}\r\n\r\n\t\tvar r = function(str) {\r\n\t\t\treturn utils.replaceCounter(str, abbrNode.counter);\r\n\t\t};\r\n\r\n\t\t// update class\r\n\t\tclassNames.forEach(function(className) {\r\n\t\t\tif (!className) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tclassName = r(className);\r\n\t\t\tvar ch = className.charAt(0);\r\n\t\t\tif (ch == '+') {\r\n\t\t\t\ttag.addClass(className.substr(1));\r\n\t\t\t} else if (ch == '-') {\r\n\t\t\t\ttag.removeClass(className.substr(1));\r\n\t\t\t} else {\r\n\t\t\t\ttag.value('class', className);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// update attributes\r\n\t\tabbrNode.attributeList().forEach(function(attr) {\r\n\t\t\tif (attr.name.toLowerCase() == 'class') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar ch = attr.name.charAt(0);\r\n\t\t\tif (ch == '+') {\r\n\t\t\t\tvar attrName = attr.name.substr(1);\r\n\t\t\t\tvar tagAttr = tag.get(attrName);\r\n\t\t\t\tif (tagAttr) {\r\n\t\t\t\t\ttagAttr.value(tagAttr.value() + r(attr.value));\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttag.value(attrName, r(attr.value));\r\n\t\t\t\t}\r\n\t\t\t} else if (ch == '-') {\r\n\t\t\t\ttag.remove(attr.name.substr(1));\r\n\t\t\t} else {\r\n\t\t\t\ttag.value(attr.name, r(attr.value));\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Matches HTML tag under caret and updates its definition\r\n\t\t * according to given abbreviation\r\n\t\t * @param {IEmmetEditor} Editor instance\r\n\t\t * @param {String} abbr Abbreviation to update with\r\n\t\t */\r\n\t\tupdateTagAction: function(editor, abbr) {\r\n\t\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\r\n\r\n\t\t\tif (!abbr) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar content = editor.getContent();\r\n\t\t\tvar ctx = actionUtils.captureContext(editor);\r\n\t\t\tvar tag = this.getUpdatedTag(abbr, ctx, content);\r\n\r\n\t\t\tif (!tag) {\r\n\t\t\t\t// nothing to update\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// check if tag name was updated\r\n\t\t\tif (tag.name() != ctx.name && ctx.match.close) {\r\n\t\t\t\teditor.replaceContent('</' + tag.name() + '>', ctx.match.close.range.start, ctx.match.close.range.end, true);\r\n\t\t\t}\r\n\r\n\t\t\teditor.replaceContent(tag.source, ctx.match.open.range.start, ctx.match.open.range.end, true);\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns XMLEditContainer node with updated tag structure\r\n\t\t * of existing tag context.\r\n\t\t * This data can be used to modify existing tag\r\n\t\t * @param  {String} abbr    Abbreviation\r\n\t\t * @param  {Object} ctx     Tag to be updated (captured with `htmlMatcher`)\r\n\t\t * @param  {String} content Original editor content\r\n\t\t * @return {XMLEditContainer}\r\n\t\t */\r\n\t\tgetUpdatedTag: function(abbr, ctx, content, options) {\r\n\t\t\tif (!ctx) {\r\n\t\t\t\t// nothing to update\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar tree = parser.parse(abbr, options || {});\r\n\r\n\t\t\t// for this action some characters in abbreviation has special\r\n\t\t\t// meaning. For example, `.-c2` means “remove `c2` class from\r\n\t\t\t// element” and `.+c3` means “append class `c3` to exising one.\r\n\t\t\t// \r\n\t\t\t// But `.+c3` abbreviation will actually produce two elements:\r\n\t\t\t// <div class=\"\"> and <c3>. Thus, we have to walk on each element\r\n\t\t\t// of parsed tree and use their definitions to update current element\r\n\t\t\tvar tag = xmlEditTree.parse(ctx.match.open.range.substring(content), {\r\n\t\t\t\toffset: ctx.match.outerRange.start\r\n\t\t\t});\r\n\r\n\t\t\ttree.children.forEach(function(node, i) {\r\n\t\t\t\tupdateAttributes(tag, node, i);\r\n\t\t\t});\r\n\r\n\t\t\t// if tag name was resolved by implicit tag name resolver,\r\n\t\t\t// then user omitted it in abbreviation and wants to keep\r\n\t\t\t// original tag name\r\n\t\t\tvar el = tree.children[0];\r\n\t\t\tif (!el.data('nameResolved')) {\r\n\t\t\t\ttag.name(el.name());\r\n\t\t\t}\r\n\r\n\t\t\treturn tag;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\wrapWithAbbreviation.js\":[function(require,module,exports){\r\n/**\r\n * Action that wraps content with abbreviation. For convenience, action is \r\n * defined as reusable module\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar parser = require('../parser/abbreviation');\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Wraps content with abbreviation\r\n\t\t * @param {IEmmetEditor} Editor instance\r\n\t\t * @param {String} abbr Abbreviation to wrap with\r\n\t\t * @param {String} syntax Syntax type (html, css, etc.)\r\n\t\t * @param {String} profile Output profile name (html, xml, xhtml)\r\n\t\t */\r\n\t\twrapWithAbbreviationAction: function(editor, abbr, syntax, profile) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\r\n\t\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\r\n\t\t\t\r\n\t\t\tif (!abbr) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tabbr = String(abbr);\r\n\t\t\t\r\n\t\t\tvar r = range(editor.getSelectionRange());\r\n\t\t\t\r\n\t\t\tif (!r.length()) {\r\n\t\t\t\t// no selection, find tag pair\r\n\t\t\t\tvar match = htmlMatcher.tag(info.content, r.start);\r\n\t\t\t\tif (!match) {  // nothing to wrap\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tr = utils.narrowToNonSpace(info.content, match.range);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar newContent = utils.escapeText(r.substring(info.content));\r\n\t\t\tvar result = parser.expand(abbr, {\r\n\t\t\t\tpastedContent: editorUtils.unindent(editor, newContent),\r\n\t\t\t\tsyntax: info.syntax,\r\n\t\t\t\tprofile: info.profile,\r\n\t\t\t\tcontextNode: actionUtils.captureContext(editor)\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (result) {\r\n\t\t\t\teditor.replaceContent(result, r.start, r.end);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"assets\\\\caniuse.js\":[function(require,module,exports){\r\n/**\r\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\r\n * Contains convenient method to get access for snippets with respect of\r\n * inheritance. Also provides ability to store data in different vocabularies\r\n * ('system' and 'user') for fast and safe resource update\r\n * @author Sergey Chikuyonok (serge.che@gmail.com)\r\n * @link http://chikuyonok.ru\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('./preferences');\r\n\tvar utils = require('../utils/common');\r\n\r\n\tprefs.define('caniuse.enabled', true, 'Enable support of Can I Use database. When enabled,\\\r\n\t\tCSS abbreviation resolver will look at Can I Use database first before detecting\\\r\n\t\tCSS properties that should be resolved');\r\n\r\n\tprefs.define('caniuse.vendors', 'all', 'A comma-separated list vendor identifiers\\\r\n\t\t(as described in Can I Use database) that should be supported\\\r\n\t\twhen resolving vendor-prefixed properties. Set value to <code>all</code>\\\r\n\t\tto support all available properties');\r\n\r\n\tprefs.define('caniuse.era', 'e-2', 'Browser era, as defined in Can I Use database.\\\r\n\t\tExamples: <code>e0</code> (current version), <code>e1</code> (near future)\\\r\n\t\t<code>e-2</code> (2 versions back) and so on.');\r\n\r\n\tvar cssSections = {\r\n\t\t'border-image': ['border-image'],\r\n\t\t'css-boxshadow': ['box-shadow'],\r\n\t\t'css3-boxsizing': ['box-sizing'],\r\n\t\t'multicolumn': ['column-width', 'column-count', 'columns', 'column-gap', 'column-rule-color', 'column-rule-style', 'column-rule-width', 'column-rule', 'column-span', 'column-fill'],\r\n\t\t'border-radius': ['border-radius', 'border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius'],\r\n\t\t'transforms2d': ['transform'],\r\n\t\t'css-hyphens': ['hyphens'],\r\n\t\t'css-transitions': ['transition', 'transition-property', 'transition-duration', 'transition-timing-function', 'transition-delay'],\r\n\t\t'font-feature': ['font-feature-settings'],\r\n\t\t'css-animation': ['animation', 'animation-name', 'animation-duration', 'animation-timing-function', 'animation-iteration-count', 'animation-direction', 'animation-play-state', 'animation-delay', 'animation-fill-mode', '@keyframes'],\r\n\t\t'css-gradients': ['linear-gradient'],\r\n\t\t'css-masks': ['mask-image', 'mask-source-type', 'mask-repeat', 'mask-position', 'mask-clip', 'mask-origin', 'mask-size', 'mask', 'mask-type', 'mask-box-image-source', 'mask-box-image-slice', 'mask-box-image-width', 'mask-box-image-outset', 'mask-box-image-repeat', 'mask-box-image', 'clip-path', 'clip-rule'],\r\n\t\t'css-featurequeries': ['@supports'],\r\n\t\t'flexbox': ['flex', 'inline-flex', 'flex-direction', 'flex-wrap', 'flex-flow', 'order', 'flex'],\r\n\t\t'calc': ['calc'],\r\n\t\t'object-fit': ['object-fit', 'object-position'],\r\n\t\t'css-grid': ['grid', 'inline-grid', 'grid-template-rows', 'grid-template-columns', 'grid-template-areas', 'grid-template', 'grid-auto-rows', 'grid-auto-columns', ' grid-auto-flow', 'grid-auto-position', 'grid', ' grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end', 'grid-column', 'grid-row', 'grid-area', 'justify-self', 'justify-items', 'align-self', 'align-items'],\r\n\t\t'css-repeating-gradients': ['repeating-linear-gradient'],\r\n\t\t'css-filters': ['filter'],\r\n\t\t'user-select-none': ['user-select'],\r\n\t\t'intrinsic-width': ['min-content', 'max-content', 'fit-content', 'fill-available'],\r\n\t\t'css3-tabsize': ['tab-size']\r\n\t};\r\n\r\n\t/** @type {Object} The Can I Use database for CSS */\r\n\tvar cssDB = null;\r\n\t/** @type {Object} A list of available vendors (browsers) and their prefixes */\r\n\tvar vendorsDB = null;\r\n\tvar erasDB = null;\r\n\r\n\tfunction intersection(arr1, arr2) {\r\n\t\tvar result = [];\r\n\t\tvar smaller = arr1, larger = arr2;\r\n\t\tif (smaller.length > larger.length) {\r\n\t\t\tsmaller = arr2;\r\n\t\t\tlarger = arr1;\r\n\t\t}\r\n\t\tlarger.forEach(function(item) {\r\n\t\t\tif (~smaller.indexOf(item)) {\r\n\t\t\t\tresult.push(item);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses raw Can I Use database for better lookups\r\n\t * @param  {String} data Raw database\r\n\t * @param  {Boolean} optimized Pass `true` if given `data` is already optimized\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseDB(data, optimized) {\r\n\t\tif (typeof data == 'string') {\r\n\t\t\tdata = JSON.parse(data);\r\n\t\t}\r\n\r\n\t\tif (!optimized) {\r\n\t\t\tdata = optimize(data);\r\n\t\t}\r\n\r\n\t\tvendorsDB = data.vendors;\r\n\t\tcssDB = data.css;\r\n\t\terasDB = data.era;\r\n\t}\r\n\r\n\t/**\r\n\t * Extract required data only from CIU database\r\n\t * @param  {Object} data Raw Can I Use database\r\n\t * @return {Object}      Optimized database\r\n\t */\r\n\tfunction optimize(data) {\r\n\t\tif (typeof data == 'string') {\r\n\t\t\tdata = JSON.parse(data);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvendors: parseVendors(data),\r\n\t\t\tcss: parseCSS(data),\r\n\t\t\tera: parseEra(data)\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Parses vendor data\r\n\t * @param  {Object} data\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseVendors(data) {\r\n\t\tvar out = {};\r\n\t\tObject.keys(data.agents).forEach(function(name) {\r\n\t\t\tvar agent = data.agents[name];\r\n\t\t\tout[name] = {\r\n\t\t\t\tprefix: agent.prefix,\r\n\t\t\t\tversions: agent.versions\r\n\t\t\t};\r\n\t\t});\r\n\t\treturn out;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses CSS data from Can I Use raw database\r\n\t * @param  {Object} data\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseCSS(data) {\r\n\t\tvar out = {};\r\n\t\tvar cssCategories = data.cats.CSS;\r\n\t\tObject.keys(data.data).forEach(function(name) {\r\n\t\t\tvar section = data.data[name];\r\n\t\t\tif (name in cssSections) {\r\n\t\t\t\tcssSections[name].forEach(function(kw) {\r\n\t\t\t\t\tout[kw] = section.stats;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses era data from Can I Use raw database\r\n\t * @param  {Object} data\r\n\t * @return {Array}\r\n\t */\r\n\tfunction parseEra(data) {\r\n\t\t// some runtimes (like Mozilla Rhino) does not preserves\r\n\t\t// key order so we have to sort values manually\r\n\t\treturn Object.keys(data.eras).sort(function(a, b) {\r\n\t\t\treturn parseInt(a.substr(1)) - parseInt(b.substr(1));\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returs list of supported vendors, depending on user preferences\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getVendorsList() {\r\n\t\tvar allVendors = Object.keys(vendorsDB);\r\n\t\tvar vendors = prefs.getArray('caniuse.vendors');\r\n\t\tif (!vendors || vendors[0] == 'all') {\r\n\t\t\treturn allVendors;\r\n\t\t}\r\n\r\n\t\treturn intersection(allVendors, vendors);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns size of version slice as defined by era identifier\r\n\t * @return {Number}\r\n\t */\r\n\tfunction getVersionSlice() {\r\n\t\tvar era = prefs.get('caniuse.era');\r\n\t\tvar ix = erasDB.indexOf(era);\r\n\t\tif (!~ix) {\r\n\t\t\tix = erasDB.indexOf('e-2');\r\n\t\t}\r\n\r\n\t\treturn ix;\r\n\t}\r\n\r\n\t// try to load caniuse database\r\n\t// hide it from Require.JS parser\r\n\tvar db = null;\r\n\t(function(r) {\r\n\t\tif (typeof define === 'undefined' || !define.amd) {\r\n\t\t\ttry {\r\n\t\t\t\tdb = r('caniuse-db/data.json');\r\n\t\t\t} catch(e) {}\r\n\t\t}\r\n\t})(require);\r\n\r\n\tif (db) {\r\n\t\tparseDB(db);\r\n\t}\r\n\r\n\treturn {\r\n\t\tload: parseDB,\r\n\t\toptimize: optimize,\r\n\r\n\t\t/**\r\n\t\t * Resolves prefixes for given property\r\n\t\t * @param {String} property A property to resolve. It can start with `@` symbol\r\n\t\t * (CSS section, like `@keyframes`) or `:` (CSS value, like `flex`)\r\n\t\t * @return {Array} Array of resolved prefixes or <code>null</code>\r\n\t\t * if prefixes can't be resolved. Empty array means property has no vendor\r\n\t\t * prefixes\r\n\t\t */\r\n\t\tresolvePrefixes: function(property) {\r\n\t\t\tif (!prefs.get('caniuse.enabled') || !cssDB || !(property in cssDB)) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar prefixes = [];\r\n\t\t\tvar propStats = cssDB[property];\r\n\t\t\tvar versions = getVersionSlice();\r\n\r\n\t\t\tgetVendorsList().forEach(function(vendor) {\r\n\t\t\t\tvar vendorVesions = vendorsDB[vendor].versions.slice(versions);\r\n\t\t\t\tfor (var i = 0, v; i < vendorVesions.length; i++) {\r\n\t\t\t\t\tv = vendorVesions[i];\r\n\t\t\t\t\tif (!v) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (~propStats[vendor][v].indexOf('x')) {\r\n\t\t\t\t\t\tprefixes.push(vendorsDB[vendor].prefix);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn utils.unique(prefixes).sort(function(a, b) {\r\n\t\t\t\treturn b.length - a.length;\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./preferences\":\"assets\\\\preferences.js\"}],\"assets\\\\elements.js\":[function(require,module,exports){\r\n/**\r\n * Module that contains factories for element types used by Emmet\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar factories = {};\r\n\tvar reAttrs = /([@\\!]?)([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\3/g;\r\n\r\n\t// register resource references\r\n\tfunction commonFactory(value) {\r\n\t\treturn {data: value};\r\n\t}\r\n\r\n\tmodule = module || {};\r\n\tmodule.exports = {\r\n\t\t/**\r\n\t\t * Create new element factory\r\n\t\t * @param {String} name Element identifier\r\n\t\t * @param {Function} factory Function that produces element of specified \r\n\t\t * type. The object generated by this factory is automatically \r\n\t\t * augmented with <code>type</code> property pointing to element\r\n\t\t * <code>name</code>\r\n\t\t * @memberOf elements\r\n\t\t */\r\n\t\tadd: function(name, factory) {\r\n\t\t\tvar that = this;\r\n\t\t\tfactories[name] = function() {\r\n\t\t\t\tvar elem = factory.apply(that, arguments);\r\n\t\t\t\tif (elem)\r\n\t\t\t\t\telem.type = name;\r\n\t\t\t\t\r\n\t\t\t\treturn elem;\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns factory for specified name\r\n\t\t * @param {String} name\r\n\t\t * @returns {Function}\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\treturn factories[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates new element with specified type\r\n\t\t * @param {String} name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tcreate: function(name) {\r\n\t\t\tvar args = [].slice.call(arguments, 1);\r\n\t\t\tvar factory = this.get(name);\r\n\t\t\treturn factory ? factory.apply(this, args) : null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element is of specified type\r\n\t\t * @param {Object} elem\r\n\t\t * @param {String} type\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tis: function(elem, type) {\r\n\t\t\treturn this.type(elem) === type;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns type of element\r\n\t\t * @param  {Object} elem\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\ttype: function(elem) {\r\n\t\t\treturn elem && elem.type;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Element factory\r\n\t * @param {String} elementName Name of output element\r\n\t * @param {String} attrs Attributes definition. You may also pass\r\n\t * <code>Array</code> where each contains object with <code>name</code> \r\n\t * and <code>value</code> properties, or <code>Object</code>\r\n\t * @param {Boolean} isEmpty Is expanded element should be empty\r\n\t */\r\n\tmodule.exports.add('element', function(elementName, attrs, isEmpty) {\r\n\t\tvar ret = {\r\n\t\t\tname: elementName,\r\n\t\t\tis_empty: !!isEmpty\r\n\t\t};\r\n\r\n\t\tif (attrs) {\r\n\t\t\tret.attributes = [];\r\n\t\t\tif (Array.isArray(attrs)) {\r\n\t\t\t\tret.attributes = attrs;\r\n\t\t\t} else if (typeof attrs === 'string') {\r\n\t\t\t\tvar m;\r\n\t\t\t\twhile ((m = reAttrs.exec(attrs))) {\r\n\t\t\t\t\tret.attributes.push({\r\n\t\t\t\t\t\tname: m[2],\r\n\t\t\t\t\t\tvalue: m[4],\r\n\t\t\t\t\t\tisDefault: m[1] == '@',\r\n\t\t\t\t\t\tisImplied: m[1] == '!'\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tret.attributes = Object.keys(attrs).map(function(name) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tname: name, \r\n\t\t\t\t\t\tvalue: attrs[name]\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t});\r\n\t\r\n\tmodule.exports.add('snippet', commonFactory);\r\n\tmodule.exports.add('reference', commonFactory);\r\n\tmodule.exports.add('empty', function() {\r\n\t\treturn {};\r\n\t});\r\n\t\r\n\treturn module.exports;\r\n});\r\n},{}],\"assets\\\\handlerList.js\":[function(require,module,exports){\r\n/**\r\n * Utility module that provides ordered storage of function handlers. \r\n * Many Emmet modules' functionality can be extended/overridden by custom\r\n * function. This modules provides unified storage of handler functions, their \r\n * management and execution\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\t\r\n\t/**\r\n\t * @type HandlerList\r\n\t * @constructor\r\n\t */\r\n\tfunction HandlerList() {\r\n\t\tthis._list = [];\r\n\t}\r\n\t\r\n\tHandlerList.prototype = {\r\n\t\t/**\r\n\t\t * Adds function handler\r\n\t\t * @param {Function} fn Handler\r\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\r\n\t\t * <b>order</b> : (<code>Number</code>) – order in handler list. Handlers\r\n\t\t * with higher order value will be executed earlier.\r\n\t\t */\r\n\t\tadd: function(fn, options) {\r\n\t\t\t// TODO hack for stable sort, remove after fixing `list()`\r\n\t\t\tvar order = this._list.length;\r\n\t\t\tif (options && 'order' in options) {\r\n\t\t\t\torder = options.order * 10000;\r\n\t\t\t}\r\n\t\t\tthis._list.push(utils.extend({}, options, {order: order, fn: fn}));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes handler from list\r\n\t\t * @param {Function} fn\r\n\t\t */\r\n\t\tremove: function(fn) {\r\n\t\t\tvar item = utils.find(this._list, function(item) {\r\n\t\t\t\treturn item.fn === fn;\r\n\t\t\t});\r\n\t\t\tif (item) {\r\n\t\t\t\tthis._list.splice(this._list.indexOf(item), 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns ordered list of handlers. By default, handlers \r\n\t\t * with the same <code>order</code> option returned in reverse order, \r\n\t\t * i.e. the latter function was added into the handlers list, the higher \r\n\t\t * it will be in the returned array \r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlist: function() {\r\n\t\t\t// TODO make stable sort\r\n\t\t\treturn this._list.sort(function(a, b) {\r\n\t\t\t\treturn b.order - a.order;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns ordered list of handler functions\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlistFn: function() {\r\n\t\t\treturn this.list().map(function(item) {\r\n\t\t\t\treturn item.fn;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Executes handler functions in their designated order. If function\r\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \r\n\t\t * handle passed <code>args</code>, the next function will be executed\r\n\t\t * and so on.\r\n\t\t * @param {Object} skipValue If function returns this value, execute \r\n\t\t * next handler.\r\n\t\t * @param {Array} args Arguments to pass to handler function\r\n\t\t * @returns {Boolean} Whether any of registered handlers performed\r\n\t\t * successfully  \r\n\t\t */\r\n\t\texec: function(skipValue, args) {\r\n\t\t\targs = args || [];\r\n\t\t\tvar result = null;\r\n\t\t\tutils.find(this.list(), function(h) {\r\n\t\t\t\tresult = h.fn.apply(h, args);\r\n\t\t\t\tif (result !== skipValue) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Factory method that produces <code>HandlerList</code> instance\r\n\t\t * @returns {HandlerList}\r\n\t\t * @memberOf handlerList\r\n\t\t */\r\n\t\tcreate: function() {\r\n\t\t\treturn new HandlerList();\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"assets\\\\htmlMatcher.js\":[function(require,module,exports){\r\n/**\r\n * HTML matcher: takes string and searches for HTML tag pairs for given position \r\n * \r\n * Unlike “classic” matchers, it parses content from the specified \r\n * position, not from the start, so it may work even outside HTML documents\r\n * (for example, inside strings of programming languages like JavaScript, Python \r\n * etc.)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('./range');\r\n\r\n\t// Regular Expressions for parsing tags and attributes\r\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\r\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\r\n\r\n\tfunction openTag(i, match) {\r\n\t\treturn {\r\n\t\t\tname: match[1],\r\n\t\t\tselfClose: !!match[3],\r\n\t\t\t/** @type Range */\r\n\t\t\trange: range(i, match[0]),\r\n\t\t\ttype: 'open'\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction closeTag(i, match) {\r\n\t\treturn {\r\n\t\t\tname: match[1],\r\n\t\t\t/** @type Range */\r\n\t\t\trange: range(i, match[0]),\r\n\t\t\ttype: 'close'\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction comment(i, match) {\r\n\t\treturn {\r\n\t\t\t/** @type Range */\r\n\t\t\trange: range(i, typeof match == 'number' ? match - i : match[0]),\r\n\t\t\ttype: 'comment'\r\n\t\t};\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates new tag matcher session\r\n\t * @param {String} text\r\n\t */\r\n\tfunction createMatcher(text) {\r\n\t\tvar memo = {}, m;\r\n\t\treturn {\r\n\t\t\t/**\r\n\t\t\t * Test if given position matches opening tag\r\n\t\t\t * @param {Number} i\r\n\t\t\t * @returns {Object} Matched tag object\r\n\t\t\t */\r\n\t\t\topen: function(i) {\r\n\t\t\t\tvar m = this.matches(i);\r\n\t\t\t\treturn m && m.type == 'open' ? m : null;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Test if given position matches closing tag\r\n\t\t\t * @param {Number} i\r\n\t\t\t * @returns {Object} Matched tag object\r\n\t\t\t */\r\n\t\t\tclose: function(i) {\r\n\t\t\t\tvar m = this.matches(i);\r\n\t\t\t\treturn m && m.type == 'close' ? m : null;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Matches either opening or closing tag for given position\r\n\t\t\t * @param i\r\n\t\t\t * @returns\r\n\t\t\t */\r\n\t\t\tmatches: function(i) {\r\n\t\t\t\tvar key = 'p' + i;\r\n\t\t\t\t\r\n\t\t\t\tif (!(key in memo)) {\r\n\t\t\t\t\tmemo[key] = false;\r\n\t\t\t\t\tif (text.charAt(i) == '<') {\r\n\t\t\t\t\t\tvar substr = text.slice(i);\r\n\t\t\t\t\t\tif ((m = substr.match(reOpenTag))) {\r\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\r\n\t\t\t\t\t\t} else if ((m = substr.match(reCloseTag))) {\r\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn memo[key];\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Returns original text\r\n\t\t\t * @returns {String}\r\n\t\t\t */\r\n\t\t\ttext: function() {\r\n\t\t\t\treturn text;\r\n\t\t\t},\r\n\r\n\t\t\tclean: function() {\r\n\t\t\t\tmemo = text = m = null;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction matches(text, pos, pattern) {\r\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Search for closing pair of opening tag\r\n\t * @param {Object} open Open tag instance\r\n\t * @param {Object} matcher Matcher instance\r\n\t */\r\n\tfunction findClosingPair(open, matcher) {\r\n\t\tvar stack = [], tag = null;\r\n\t\tvar text = matcher.text();\r\n\t\t\r\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\r\n\t\t\tif (matches(text, pos, '<!--')) {\r\n\t\t\t\t// skip to end of comment\r\n\t\t\t\tfor (var j = pos; j < len; j++) {\r\n\t\t\t\t\tif (matches(text, j, '-->')) {\r\n\t\t\t\t\t\tpos = j + 3;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ((tag = matcher.matches(pos))) {\r\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\r\n\t\t\t\t\tstack.push(tag.name);\r\n\t\t\t\t} else if (tag.type == 'close') {\r\n\t\t\t\t\tif (!stack.length) { // found valid pair?\r\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if current closing tag matches previously opened one\r\n\t\t\t\t\tif (stack[stack.length - 1] == tag.name) {\r\n\t\t\t\t\t\tstack.pop();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\twhile (stack.length && !found) {\r\n\t\t\t\t\t\t\tvar last = stack.pop();\r\n\t\t\t\t\t\t\tif (last == tag.name) {\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!stack.length && !found) {\r\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpos = tag.range.end - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Main function: search for tag pair in <code>text</code> for given \r\n\t\t * position\r\n\t\t * @memberOf htmlMatcher\r\n\t\t * @param {String} text \r\n\t\t * @param {Number} pos\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tfind: function(text, pos) {\r\n\t\t\tvar matcher = createMatcher(text); \r\n\t\t\tvar open = null, close = null;\r\n\t\t\tvar j, jl;\r\n\t\t\t\r\n\t\t\tfor (var i = pos; i >= 0; i--) {\r\n\t\t\t\tif ((open = matcher.open(i))) {\r\n\t\t\t\t\t// found opening tag\r\n\t\t\t\t\tif (open.selfClose) {\r\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\r\n\t\t\t\t\t\t\t// inside self-closing tag, found match\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// outside self-closing tag, continue\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tclose = findClosingPair(open, matcher);\r\n\t\t\t\t\tif (close) {\r\n\t\t\t\t\t\t// found closing tag.\r\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\r\n\t\t\t\t\t\tif (r.contains(pos)) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (open.range.contains(pos)) {\r\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\topen = null;\r\n\t\t\t\t} else if (matches(text, i, '-->')) {\r\n\t\t\t\t\t// skip back to comment start\r\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\r\n\t\t\t\t\t\t\t// found another comment end, do nothing\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\r\n\t\t\t\t\t\t\ti = j;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (matches(text, i, '<!--')) {\r\n\t\t\t\t\t// we're inside comment, match it\r\n\t\t\t\t\tfor (j = i + 4, jl = text.length; j < jl; j++) {\r\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\r\n\t\t\t\t\t\t\tj += 3;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\topen = comment(i, j);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmatcher.clean();\r\n\r\n\t\t\tif (open) {\r\n\t\t\t\tvar outerRange = null;\r\n\t\t\t\tvar innerRange = null;\r\n\t\t\t\t\r\n\t\t\t\tif (close) {\r\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\r\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\r\n\t\t\t\t} else {\r\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (open.type == 'comment') {\r\n\t\t\t\t\t// adjust positions of inner range for comment\r\n\t\t\t\t\tvar _c = outerRange.substring(text);\r\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\r\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\topen: open,\r\n\t\t\t\t\tclose: close,\r\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\r\n\t\t\t\t\tinnerRange: innerRange,\r\n\t\t\t\t\tinnerContent: function() {\r\n\t\t\t\t\t\treturn this.innerRange.substring(text);\r\n\t\t\t\t\t},\r\n\t\t\t\t\touterRange: outerRange,\r\n\t\t\t\t\touterContent: function() {\r\n\t\t\t\t\t\treturn this.outerRange.substring(text);\r\n\t\t\t\t\t},\r\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\r\n\t\t\t\t\tcontent: function() {\r\n\t\t\t\t\t\treturn this.range.substring(text);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsource: text\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * The same as <code>find()</code> method, but restricts matched result \r\n\t\t * to <code>tag</code> type\r\n\t\t * @param {String} text \r\n\t\t * @param {Number} pos\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\ttag: function(text, pos) {\r\n\t\t\tvar result = this.find(text, pos);\r\n\t\t\tif (result && result.type == 'tag') {\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"./range\":\"assets\\\\range.js\"}],\"assets\\\\logger.js\":[function(require,module,exports){\r\n/**\r\n * Simple logger for Emmet\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\treturn {\r\n\t\tlog: function() {\r\n\t\t\tif (typeof console != 'undefined' && console.log) {\r\n\t\t\t\tconsole.log.apply(console, arguments);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n})\r\n},{}],\"assets\\\\preferences.js\":[function(require,module,exports){\r\n/**\r\n * Common module's preferences storage. This module \r\n * provides general storage for all module preferences, their description and\r\n * default values.<br><br>\r\n * \r\n * This module can also be used to list all available properties to create \r\n * UI for updating properties\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\r\n\tvar preferences = {};\r\n\tvar defaults = {};\r\n\tvar _dbgDefaults = null;\r\n\tvar _dbgPreferences = null;\r\n\r\n\tfunction toBoolean(val) {\r\n\t\tif (typeof val === 'string') {\r\n\t\t\tval = val.toLowerCase();\r\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\r\n\t\t}\r\n\r\n\t\treturn !!val;\r\n\t}\r\n\t\r\n\tfunction isValueObj(obj) {\r\n\t\treturn typeof obj === 'object'\r\n\t\t\t&& !Array.isArray(obj) \r\n\t\t\t&& 'value' in obj \r\n\t\t\t&& Object.keys(obj).length < 3;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Creates new preference item with default value\r\n\t\t * @param {String} name Preference name. You can also pass object\r\n\t\t * with many options\r\n\t\t * @param {Object} value Preference default value\r\n\t\t * @param {String} description Item textual description\r\n\t\t * @memberOf preferences\r\n\t\t */\r\n\t\tdefine: function(name, value, description) {\r\n\t\t\tvar prefs = name;\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\tprefs = {};\r\n\t\t\t\tprefs[name] = {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tdescription: description\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tObject.keys(prefs).forEach(function(k) {\r\n\t\t\t\tvar v = prefs[k];\r\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Updates preference item value. Preference value should be defined\r\n\t\t * first with <code>define</code> method.\r\n\t\t * @param {String} name Preference name. You can also pass object\r\n\t\t * with many options\r\n\t\t * @param {Object} value Preference default value\r\n\t\t * @memberOf preferences\r\n\t\t */\r\n\t\tset: function(name, value) {\r\n\t\t\tvar prefs = name;\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\tprefs = {};\r\n\t\t\t\tprefs[name] = value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tObject.keys(prefs).forEach(function(k) {\r\n\t\t\t\tvar v = prefs[k];\r\n\t\t\t\tif (!(k in defaults)) {\r\n\t\t\t\t\tthrow new Error('Property \"' + k + '\" is not defined. You should define it first with `define` method of current module');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// do not set value if it equals to default value\r\n\t\t\t\tif (v !== defaults[k].value) {\r\n\t\t\t\t\t// make sure we have value of correct type\r\n\t\t\t\t\tswitch (typeof defaults[k].value) {\r\n\t\t\t\t\t\tcase 'boolean':\r\n\t\t\t\t\t\t\tv = toBoolean(v);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'number':\r\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: // convert to string\r\n\t\t\t\t\t\t\tif (v !== null) {\r\n\t\t\t\t\t\t\t\tv += '';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpreferences[k] = v;\r\n\t\t\t\t} else if (k in preferences) {\r\n\t\t\t\t\tdelete preferences[k];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns preference value\r\n\t\t * @param {String} name\r\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \r\n\t\t * not defined\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\tif (name in preferences) {\r\n\t\t\t\treturn preferences[name];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (name in defaults) {\r\n\t\t\t\treturn defaults[name].value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn void 0;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns comma-separated preference value as array of values\r\n\t\t * @param {String} name\r\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \r\n\t\t * not defined, <code>null</code> if string cannot be converted to array\r\n\t\t */\r\n\t\tgetArray: function(name) {\r\n\t\t\tvar val = this.get(name);\r\n\t\t\tif (typeof val === 'undefined' || val === null || val === '')  {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tval = val.split(',').map(utils.trim);\r\n\t\t\tif (!val.length) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn val;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns comma and colon-separated preference value as dictionary\r\n\t\t * @param {String} name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetDict: function(name) {\r\n\t\t\tvar result = {};\r\n\t\t\tthis.getArray(name).forEach(function(val) {\r\n\t\t\t\tvar parts = val.split(':');\r\n\t\t\t\tresult[parts[0]] = parts[1];\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns description of preference item\r\n\t\t * @param {String} name Preference name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tdescription: function(name) {\r\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Completely removes specified preference(s)\r\n\t\t * @param {String} name Preference name (or array of names)\r\n\t\t */\r\n\t\tremove: function(name) {\r\n\t\t\tif (!Array.isArray(name)) {\r\n\t\t\t\tname = [name];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tname.forEach(function(key) {\r\n\t\t\t\tif (key in preferences) {\r\n\t\t\t\t\tdelete preferences[key];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (key in defaults) {\r\n\t\t\t\t\tdelete defaults[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns sorted list of all available properties\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlist: function() {\r\n\t\t\treturn Object.keys(defaults).sort().map(function(key) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvalue: this.get(key),\r\n\t\t\t\t\ttype: typeof defaults[key].value,\r\n\t\t\t\t\tdescription: defaults[key].description\r\n\t\t\t\t};\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Loads user-defined preferences from JSON\r\n\t\t * @param {Object} json\r\n\t\t * @returns\r\n\t\t */\r\n\t\tload: function(json) {\r\n\t\t\tObject.keys(json).forEach(function(key) {\r\n\t\t\t\tthis.set(key, json[key]);\r\n\t\t\t}, this);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns hash of user-modified preferences\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\texportModified: function() {\r\n\t\t\treturn utils.extend({}, preferences);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Reset to defaults\r\n\t\t * @returns\r\n\t\t */\r\n\t\treset: function() {\r\n\t\t\tpreferences = {};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * For unit testing: use empty storage\r\n\t\t */\r\n\t\t_startTest: function() {\r\n\t\t\t_dbgDefaults = defaults;\r\n\t\t\t_dbgPreferences = preferences;\r\n\t\t\tdefaults = {};\r\n\t\t\tpreferences = {};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * For unit testing: restore original storage\r\n\t\t */\r\n\t\t_stopTest: function() {\r\n\t\t\tdefaults = _dbgDefaults;\r\n\t\t\tpreferences = _dbgPreferences;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"assets\\\\profile.js\":[function(require,module,exports){\r\n/**\r\n * Output profile module.\r\n * Profile defines how XHTML output data should look like\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar resources = require('./resources');\r\n\tvar prefs = require('./preferences');\r\n\r\n\tprefs.define('profile.allowCompactBoolean', true, \r\n\t\t'This option can be used to globally disable compact form of boolean ' + \r\n\t\t'attribues (attributes where name and value are equal). With compact' +\r\n\t\t'form enabled, HTML tags can be outputted as <code>&lt;div contenteditable&gt;</code> ' +\r\n\t\t'instead of <code>&lt;div contenteditable=\"contenteditable\"&gt;</code>');\r\n\r\n\tprefs.define('profile.booleanAttributes', '^contenteditable|seamless|async|autofocus|autoplay|checked|controls|defer|disabled|formnovalidate|hidden|ismap|loop|multiple|muted|novalidate|readonly|required|reversed|selected|typemustmatch$', \r\n\t\t'A regular expression for attributes that should be boolean by default.' + \r\n\t\t'If attribute name matches this expression, you don’t have to write dot ' +\r\n\t\t'after attribute name in Emmet abbreviation to mark it as boolean.');\r\n\r\n\tvar profiles = {};\r\n\t\r\n\tvar defaultProfile = {\r\n\t\ttag_case: 'asis',\r\n\t\tattr_case: 'asis',\r\n\t\tattr_quotes: 'double',\r\n\t\t\r\n\t\t// Each tag on new line\r\n\t\ttag_nl: 'decide',\r\n\t\t\r\n\t\t// With tag_nl === true, defines if leaf node (e.g. node with no children)\r\n\t\t// should have formatted line breaks\r\n\t\ttag_nl_leaf: false,\r\n\t\t\r\n\t\tplace_cursor: true,\r\n\t\t\r\n\t\t// Indent tags\r\n\t\tindent: true,\r\n\t\t\r\n\t\t// How many inline elements should be to force line break \r\n\t\t// (set to 0 to disable)\r\n\t\tinline_break: 3,\r\n\r\n\t\t// Produce compact notation of boolean attribues:\r\n\t\t// attributes where name and value are equal.\r\n\t\t// With this option enabled, HTML filter will\r\n\t\t// produce <div contenteditable> instead of <div contenteditable=\"contenteditable\">\r\n\t\tcompact_bool: false,\r\n\t\t\r\n\t\t// Use self-closing style for writing empty elements, e.g. <br /> or <br>\r\n\t\tself_closing_tag: 'xhtml',\r\n\t\t\r\n\t\t// Profile-level output filters, re-defines syntax filters \r\n\t\tfilters: '',\r\n\t\t\r\n\t\t// Additional filters applied to abbreviation.\r\n\t\t// Unlike \"filters\", this preference doesn't override default filters\r\n\t\t// but add the instead every time given profile is chosen\r\n\t\textraFilters: ''\r\n\t};\r\n\t\r\n\t/**\r\n\t * @constructor\r\n\t * @type OutputProfile\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction OutputProfile(options) {\r\n\t\tutils.extend(this, defaultProfile, options);\r\n\t}\r\n\t\r\n\tOutputProfile.prototype = {\r\n\t\t/**\r\n\t\t * Transforms tag name case depending on current profile settings\r\n\t\t * @param {String} name String to transform\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\ttagName: function(name) {\r\n\t\t\treturn stringCase(name, this.tag_case);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Transforms attribute name case depending on current profile settings \r\n\t\t * @param {String} name String to transform\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tattributeName: function(name) {\r\n\t\t\treturn stringCase(name, this.attr_case);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns quote character for current profile\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tattributeQuote: function() {\r\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns self-closing tag symbol for current profile\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tselfClosing: function() {\r\n\t\t\tif (this.self_closing_tag == 'xhtml')\r\n\t\t\t\treturn ' /';\r\n\t\t\t\r\n\t\t\tif (this.self_closing_tag === true)\r\n\t\t\t\treturn '/';\r\n\t\t\t\r\n\t\t\treturn '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns cursor token based on current profile settings\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tcursor: function() {\r\n\t\t\treturn this.place_cursor ? utils.getCaretPlaceholder() : '';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if attribute with given name is boolean,\r\n\t\t * e.g. written as `contenteditable` instead of \r\n\t\t * `contenteditable=\"contenteditable\"`\r\n\t\t * @param  {String}  name Attribute name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisBoolean: function(name, value) {\r\n\t\t\tif (name == value) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar boolAttrs = prefs.get('profile.booleanAttributes');\r\n\t\t\tif (!value && boolAttrs) {\r\n\t\t\t\tboolAttrs = new RegExp(boolAttrs, 'i');\r\n\t\t\t\treturn boolAttrs.test(name);\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if compact boolean attribute record is \r\n\t\t * allowed for current profile\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tallowCompactBoolean: function() {\r\n\t\t\treturn this.compact_bool && prefs.get('profile.allowCompactBoolean');\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Helper function that converts string case depending on \r\n\t * <code>caseValue</code> \r\n\t * @param {String} str String to transform\r\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \r\n\t * <i>upper</i> and <i>leave</i>\r\n\t * @returns {String}\r\n\t */\r\n\tfunction stringCase(str, caseValue) {\r\n\t\tswitch (String(caseValue || '').toLowerCase()) {\r\n\t\t\tcase 'lower':\r\n\t\t\t\treturn str.toLowerCase();\r\n\t\t\tcase 'upper':\r\n\t\t\t\treturn str.toUpperCase();\r\n\t\t}\r\n\t\t\r\n\t\treturn str;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates new output profile\r\n\t * @param {String} name Profile name\r\n\t * @param {Object} options Profile options\r\n\t */\r\n\tfunction createProfile(name, options) {\r\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\r\n\t}\r\n\t\r\n\tfunction createDefaultProfiles() {\r\n\t\tcreateProfile('xhtml');\r\n\t\tcreateProfile('html', {self_closing_tag: false, compact_bool: true});\r\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\r\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\r\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\r\n\t\tcreateProfile('css', {tag_nl: true});\r\n\t\tcreateProfile('css_line', {tag_nl: false});\r\n\t}\r\n\t\r\n\tcreateDefaultProfiles();\r\n\t\r\n\treturn  {\r\n\t\t/**\r\n\t\t * Creates new output profile and adds it into internal dictionary\r\n\t\t * @param {String} name Profile name\r\n\t\t * @param {Object} options Profile options\r\n\t\t * @memberOf emmet.profile\r\n\t\t * @returns {Object} New profile\r\n\t\t */\r\n\t\tcreate: function(name, options) {\r\n\t\t\tif (arguments.length == 2)\r\n\t\t\t\treturn createProfile(name, options);\r\n\t\t\telse\r\n\t\t\t\t// create profile object only\r\n\t\t\t\treturn new OutputProfile(utils.defaults(name || {}, defaultProfile));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns profile by its name. If profile wasn't found, returns\r\n\t\t * 'plain' profile\r\n\t\t * @param {String} name Profile name. Might be profile itself\r\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\r\n\t\t * profile is searched in resources first, then in predefined profiles\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tget: function(name, syntax) {\r\n\t\t\tif (!name && syntax) {\r\n\t\t\t\t// search in user resources first\r\n\t\t\t\tvar profile = resources.findItem(syntax, 'profile');\r\n\t\t\t\tif (profile) {\r\n\t\t\t\t\tname = profile;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!name) {\r\n\t\t\t\treturn profiles.plain;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (name instanceof OutputProfile) {\r\n\t\t\t\treturn name;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof name === 'string' && name.toLowerCase() in profiles) {\r\n\t\t\t\treturn profiles[name.toLowerCase()];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this.create(name);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Deletes profile with specified name\r\n\t\t * @param {String} name Profile name\r\n\t\t */\r\n\t\tremove: function(name) {\r\n\t\t\tname = (name || '').toLowerCase();\r\n\t\t\tif (name in profiles)\r\n\t\t\t\tdelete profiles[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Resets all user-defined profiles\r\n\t\t */\r\n\t\treset: function() {\r\n\t\t\tprofiles = {};\r\n\t\t\tcreateDefaultProfiles();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Helper function that converts string case depending on \r\n\t\t * <code>caseValue</code> \r\n\t\t * @param {String} str String to transform\r\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \r\n\t\t * <i>upper</i> and <i>leave</i>\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tstringCase: stringCase\r\n\t};\r\n});\r\n\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./preferences\":\"assets\\\\preferences.js\",\"./resources\":\"assets\\\\resources.js\"}],\"assets\\\\range.js\":[function(require,module,exports){\r\n/**\r\n * Helper module to work with ranges\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tfunction cmp(a, b, op) {\r\n\t\tswitch (op) {\r\n\t\t\tcase 'eq':\r\n\t\t\tcase '==':\r\n\t\t\t\treturn a === b;\r\n\t\t\tcase 'lt':\r\n\t\t\tcase '<':\r\n\t\t\t\treturn a < b;\r\n\t\t\tcase 'lte':\r\n\t\t\tcase '<=':\r\n\t\t\t\treturn a <= b;\r\n\t\t\tcase 'gt':\r\n\t\t\tcase '>':\r\n\t\t\t\treturn a > b;\r\n\t\t\tcase 'gte':\r\n\t\t\tcase '>=':\r\n\t\t\t\treturn a >= b;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @type Range\r\n\t * @constructor\r\n\t * @param {Object} start\r\n\t * @param {Number} len\r\n\t */\r\n\tfunction Range(start, len) {\r\n\t\tif (typeof start === 'object' && 'start' in start) {\r\n\t\t\t// create range from object stub\r\n\t\t\tthis.start = Math.min(start.start, start.end);\r\n\t\t\tthis.end = Math.max(start.start, start.end);\r\n\t\t} else if (Array.isArray(start)) {\r\n\t\t\tthis.start = start[0];\r\n\t\t\tthis.end = start[1];\r\n\t\t} else {\r\n\t\t\tlen = typeof len === 'string' ? len.length : +len;\r\n\t\t\tthis.start = start;\r\n\t\t\tthis.end = start + len;\r\n\t\t}\r\n\t}\r\n\t\r\n\tRange.prototype = {\r\n\t\tlength: function() {\r\n\t\t\treturn Math.abs(this.end - this.start);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns <code>true</code> if passed range is equals to current one\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tequal: function(range) {\r\n\t\t\treturn this.cmp(range, 'eq', 'eq');\r\n//\t\t\treturn this.start === range.start && this.end === range.end;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Shifts indexes position with passed <code>delta</code>\r\n\t\t * @param {Number} delta\r\n\t\t * @returns {Range} range itself\r\n\t\t */\r\n\t\tshift: function(delta) {\r\n\t\t\tthis.start += delta;\r\n\t\t\tthis.end += delta;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if two ranges are overlapped\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\toverlap: function(range) {\r\n\t\t\treturn range.start <= this.end && range.end >= this.start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds intersection of two ranges\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\r\n\t\t */\r\n\t\tintersection: function(range) {\r\n\t\t\tif (this.overlap(range)) {\r\n\t\t\t\tvar start = Math.max(range.start, this.start);\r\n\t\t\t\tvar end = Math.min(range.end, this.end);\r\n\t\t\t\treturn new Range(start, end - start);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the union of the thow ranges.\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\r\n\t\t */\r\n\t\tunion: function(range) {\r\n\t\t\tif (this.overlap(range)) {\r\n\t\t\t\tvar start = Math.min(range.start, this.start);\r\n\t\t\t\tvar end = Math.max(range.end, this.end);\r\n\t\t\t\treturn new Range(start, end - start);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns a Boolean value that indicates whether a specified position \r\n\t\t * is in a given range.\r\n\t\t * @param {Number} loc\r\n\t\t */\r\n\t\tinside: function(loc) {\r\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\r\n//\t\t\treturn this.start <= loc && this.end > loc;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns a Boolean value that indicates whether a specified position \r\n\t\t * is in a given range, but not equals bounds.\r\n\t\t * @param {Number} loc\r\n\t\t */\r\n\t\tcontains: function(loc) {\r\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current range completely includes specified one\r\n\t\t * @param {Range} r\r\n\t\t * @returns {Boolean} \r\n\t\t */\r\n\t\tinclude: function(r) {\r\n\t\t\treturn this.cmp(r, 'lte', 'gte');\r\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Low-level comparision method\r\n\t\t * @param {Number} loc\r\n\t\t * @param {String} left Left comparison operator\r\n\t\t * @param {String} right Right comaprison operator\r\n\t\t */\r\n\t\tcmp: function(loc, left, right) {\r\n\t\t\tvar a, b;\r\n\t\t\tif (loc instanceof Range) {\r\n\t\t\t\ta = loc.start;\r\n\t\t\t\tb = loc.end;\r\n\t\t\t} else {\r\n\t\t\t\ta = b = loc;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns substring of specified <code>str</code> for current range\r\n\t\t * @param {String} str\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tsubstring: function(str) {\r\n\t\t\treturn this.length() > 0 \r\n\t\t\t\t? str.substring(this.start, this.end) \r\n\t\t\t\t: '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates copy of current range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tclone: function() {\r\n\t\t\treturn new Range(this.start, this.length());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\ttoArray: function() {\r\n\t\t\treturn [this.start, this.end];\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\r\n\t\tvalueOf: function() {\r\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Creates new range object instance\r\n\t * @param {Object} start Range start or array with 'start' and 'end'\r\n\t * as two first indexes or object with 'start' and 'end' properties\r\n\t * @param {Number} len Range length or string to produce range from\r\n\t * @returns {Range}\r\n\t */\r\n\tmodule.exports = function(start, len) {\r\n\t\tif (typeof start == 'undefined' || start === null)\r\n\t\t\treturn null;\r\n\t\t\t\r\n\t\tif (start instanceof Range)\r\n\t\t\treturn start;\r\n\t\t\r\n\t\tif (typeof start == 'object' && 'start' in start && 'end' in start) {\r\n\t\t\tlen = start.end - start.start;\r\n\t\t\tstart = start.start;\r\n\t\t}\r\n\t\t\t\r\n\t\treturn new Range(start, len);\r\n\t};\r\n\r\n\tmodule.exports.create = module.exports;\r\n\r\n\tmodule.exports.isRange = function(val) {\r\n\t\treturn val instanceof Range;\r\n\t};\r\n\r\n\t/**\r\n\t * <code>Range</code> object factory, the same as <code>this.create()</code>\r\n\t * but last argument represents end of range, not length\r\n\t * @returns {Range}\r\n\t */\r\n\tmodule.exports.create2 = function(start, end) {\r\n\t\tif (typeof start === 'number' && typeof end === 'number') {\r\n\t\t\tend -= start;\r\n\t\t}\r\n\t\t\r\n\t\treturn this.create(start, end);\r\n\t};\r\n\r\n\t/**\r\n\t * Helper function that sorts ranges in order as they\r\n\t * appear in text\r\n\t * @param  {Array} ranges\r\n\t * @return {Array}\r\n\t */\r\n\tmodule.exports.sort = function(ranges, reverse) {\r\n\t\tranges = ranges.sort(function(a, b) {\r\n\t\t\tif (a.start === b.start) {\r\n\t\t\t\treturn b.end - a.end;\r\n\t\t\t}\r\n\r\n\t\t\treturn a.start - b.start;\r\n\t\t});\r\n\r\n\t\treverse && ranges.reverse();\r\n\t\treturn ranges;\r\n\t};\r\n\r\n\treturn module.exports;\r\n});\r\n},{}],\"assets\\\\resources.js\":[function(require,module,exports){\r\n/**\r\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\r\n * Contains convenient method to get access for snippets with respect of\r\n * inheritance. Also provides ability to store data in different vocabularies\r\n * ('system' and 'user') for fast and safe resource update\r\n * @author Sergey Chikuyonok (serge.che@gmail.com)\r\n * @link http://chikuyonok.ru\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar handlerList = require('./handlerList');\r\n\tvar utils = require('../utils/common');\r\n\tvar elements = require('./elements');\r\n\tvar logger = require('../assets/logger');\r\n\tvar stringScore = require('../vendor/stringScore');\r\n\tvar cssResolver = require('../resolver/css');\r\n\r\n\tvar VOC_SYSTEM = 'system';\r\n\tvar VOC_USER = 'user';\r\n\r\n\tvar cache = {};\r\n\r\n\t/** Regular expression for XML tag matching */\r\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[@\\!]?[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\r\n\r\n\tvar systemSettings = {};\r\n\tvar userSettings = {};\r\n\r\n\t/** @type HandlerList List of registered abbreviation resolvers */\r\n\tvar resolvers = handlerList.create();\r\n\r\n\tfunction each(obj, fn) {\r\n\t\tif (!obj) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tObject.keys(obj).forEach(function(key) {\r\n\t\t\tfn(obj[key], key);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes caret plceholder in passed text: replaces | character with\r\n\t * default caret placeholder\r\n\t * @param {String} text\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeCaretPlaceholder(text) {\r\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\r\n\t}\r\n\r\n\tfunction parseItem(name, value, type) {\r\n\t\tvalue = normalizeCaretPlaceholder(value);\r\n\r\n\t\tif (type == 'snippets') {\r\n\t\t\treturn elements.create('snippet', value);\r\n\t\t}\r\n\r\n\t\tif (type == 'abbreviations') {\r\n\t\t\treturn parseAbbreviation(name, value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Parses single abbreviation\r\n\t * @param {String} key Abbreviation name\r\n\t * @param {String} value Abbreviation value\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseAbbreviation(key, value) {\r\n\t\tkey = utils.trim(key);\r\n\t\tvar m;\r\n\t\tif ((m = reTag.exec(value))) {\r\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\r\n\t\t} else {\r\n\t\t\t// assume it's reference to another abbreviation\r\n\t\t\treturn elements.create('reference', value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes snippet key name for better fuzzy search\r\n\t * @param {String} str\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeName(str) {\r\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\r\n\t}\r\n\r\n\tfunction expandSnippetsDefinition(snippets) {\r\n\t\tvar out = {};\r\n\t\teach(snippets, function(val, key) {\r\n\t\t\tvar items = key.split('|');\r\n\t\t\t// do not use iterators for better performance\r\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\r\n\t\t\t\tout[items[i]] = val;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tutils.extend(exports, {\r\n\t\t/**\r\n\t\t * Sets new unparsed data for specified settings vocabulary\r\n\t\t * @param {Object} data\r\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\r\n\t\t * @memberOf resources\r\n\t\t */\r\n\t\tsetVocabulary: function(data, type) {\r\n\t\t\tcache = {};\r\n\r\n\t\t\t// sections like \"snippets\" and \"abbreviations\" could have\r\n\t\t\t// definitions like `\"f|fs\": \"fieldset\"` which is the same as distinct\r\n\t\t\t// \"f\" and \"fs\" keys both equals to \"fieldset\".\r\n\t\t\t// We should parse these definitions first\r\n\t\t\tvar voc = {};\r\n\t\t\teach(data, function(section, syntax) {\r\n\t\t\t\tvar _section = {};\r\n\t\t\t\teach(section, function(subsection, name) {\r\n\t\t\t\t\tif (name == 'abbreviations' || name == 'snippets') {\r\n\t\t\t\t\t\tsubsection = expandSnippetsDefinition(subsection);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_section[name] = subsection;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tvoc[syntax] = _section;\r\n\t\t\t});\r\n\r\n\r\n\t\t\tif (type == VOC_SYSTEM) {\r\n\t\t\t\tsystemSettings = voc;\r\n\t\t\t} else {\r\n\t\t\t\tuserSettings = voc;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns resource vocabulary by its name\r\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\r\n\t\t * @return {Object}\r\n\t\t */\r\n\t\tgetVocabulary: function(name) {\r\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed\r\n\t\t * abbreviation\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @param {String} syntax\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetMatchedResource: function(node, syntax) {\r\n\t\t\treturn resolvers.exec(null, utils.toArray(arguments))\r\n\t\t\t\t|| this.findSnippet(syntax, node.name());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns variable value\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetVariable: function(name) {\r\n\t\t\treturn (this.getSection('variables') || {})[name];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Store runtime variable in user storage\r\n\t\t * @param {String} name Variable name\r\n\t\t * @param {String} value Variable value\r\n\t\t */\r\n\t\tsetVariable: function(name, value){\r\n\t\t\tvar voc = this.getVocabulary('user') || {};\r\n\t\t\tif (!('variables' in voc))\r\n\t\t\t\tvoc.variables = {};\r\n\r\n\t\t\tvoc.variables[name] = value;\r\n\t\t\tthis.setVocabulary(voc, 'user');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if there are resources for specified syntax\r\n\t\t * @param {String} syntax\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\thasSyntax: function(syntax) {\r\n\t\t\treturn syntax in this.getVocabulary(VOC_USER)\r\n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Registers new abbreviation resolver.\r\n\t\t * @param {Function} fn Abbreviation resolver which will receive\r\n\t\t * abbreviation as first argument and should return parsed abbreviation\r\n\t\t * object if abbreviation has handled successfully, <code>null</code>\r\n\t\t * otherwise\r\n\t\t * @param {Object} options Options list as described in\r\n\t\t * {@link HandlerList#add()} method\r\n\t\t */\r\n\t\taddResolver: function(fn, options) {\r\n\t\t\tresolvers.add(fn, options);\r\n\t\t},\r\n\r\n\t\tremoveResolver: function(fn) {\r\n\t\t\tresolvers.remove(fn);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns actual section data, merged from both\r\n\t\t * system and user data\r\n\t\t * @param {String} name Section name (syntax)\r\n\t\t * @param {String} ...args Subsections\r\n\t\t * @returns\r\n\t\t */\r\n\t\tgetSection: function(name) {\r\n\t\t\tif (!name)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tif (!(name in cache)) {\r\n\t\t\t\tcache[name] = utils.deepMerge({}, systemSettings[name], userSettings[name]);\r\n\t\t\t}\r\n\r\n\t\t\tvar data = cache[name], subsections = utils.toArray(arguments, 1), key;\r\n\t\t\twhile (data && (key = subsections.shift())) {\r\n\t\t\t\tif (key in data) {\r\n\t\t\t\t\tdata = data[key];\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\r\n\t\t * with respect of `extends` attribute\r\n\t\t * @param {String} topSection Top section name (syntax)\r\n\t\t * @param {String} subsection Inner section name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tfindItem: function(topSection, subsection) {\r\n\t\t\tvar data = this.getSection(topSection);\r\n\t\t\twhile (data) {\r\n\t\t\t\tif (subsection in data)\r\n\t\t\t\t\treturn data[subsection];\r\n\r\n\t\t\t\tdata = this.getSection(data['extends']);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Recursively searches for a snippet definition inside syntax section.\r\n\t\t * Definition is searched inside `snippets` and `abbreviations`\r\n\t\t * subsections\r\n\t\t * @param {String} syntax Top-level section name (syntax)\r\n\t\t * @param {String} name Snippet name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tfindSnippet: function(syntax, name, memo) {\r\n\t\t\tif (!syntax || !name)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tmemo = memo || [];\r\n\r\n\t\t\tvar names = [name];\r\n\t\t\t// create automatic aliases to properties with colons,\r\n\t\t\t// e.g. pos-a == pos:a\r\n\t\t\tif (~name.indexOf('-')) {\r\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\r\n\t\t\t}\r\n\r\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\r\n\t\t\t['snippets', 'abbreviations'].some(function(sectionName) {\r\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\r\n\t\t\t\tif (data) {\r\n\t\t\t\t\treturn names.some(function(n) {\r\n\t\t\t\t\t\tif (data[n]) {\r\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\r\n\t\t\tmemo.push(syntax);\r\n\t\t\tif (!matchedItem && data['extends'] && !~memo.indexOf(data['extends'])) {\r\n\t\t\t\t// try to find item in parent syntax section\r\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\r\n\t\t\t}\r\n\r\n\t\t\treturn matchedItem;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Performs fuzzy search of snippet definition\r\n\t\t * @param {String} syntax Top-level section name (syntax)\r\n\t\t * @param {String} name Snippet name\r\n\t\t * @returns\r\n\t\t */\r\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\r\n\t\t\tvar result = this.fuzzyFindMatches(syntax, name, minScore)[0];\r\n\t\t\tif (result) {\r\n\t\t\t\treturn result.value.parsedValue;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfuzzyFindMatches: function(syntax, name, minScore) {\r\n\t\t\tminScore = minScore || 0.3;\r\n\t\t\tname = normalizeName(name);\r\n\t\t\tvar snippets = this.getAllSnippets(syntax);\r\n\r\n\t\t\treturn Object.keys(snippets)\r\n\t\t\t\t.map(function(key) {\r\n\t\t\t\t\tvar value = snippets[key];\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tkey: key,\r\n\t\t\t\t\t\tscore: stringScore.score(value.nk, name, 0.1),\r\n\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t};\r\n\t\t\t\t})\r\n\t\t\t\t.filter(function(item) {\r\n\t\t\t\t\treturn item.score >= minScore;\r\n\t\t\t\t})\r\n\t\t\t\t.sort(function(a, b) {\r\n\t\t\t\t\treturn a.score - b.score;\r\n\t\t\t\t})\r\n\t\t\t\t.reverse();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns plain dictionary of all available abbreviations and snippets\r\n\t\t * for specified syntax with respect of inheritance\r\n\t\t * @param {String} syntax\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetAllSnippets: function(syntax) {\r\n\t\t\tvar cacheKey = 'all-' + syntax;\r\n\t\t\tif (!cache[cacheKey]) {\r\n\t\t\t\tvar stack = [], sectionKey = syntax;\r\n\t\t\t\tvar memo = [];\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar section = this.getSection(sectionKey);\r\n\t\t\t\t\tif (!section)\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t['snippets', 'abbreviations'].forEach(function(sectionName) {\r\n\t\t\t\t\t\tvar stackItem = {};\r\n\t\t\t\t\t\teach(section[sectionName] || null, function(v, k) {\r\n\t\t\t\t\t\t\tstackItem[k] = {\r\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\r\n\t\t\t\t\t\t\t\tvalue: v,\r\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\r\n\t\t\t\t\t\t\t\ttype: sectionName\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tstack.push(stackItem);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tmemo.push(sectionKey);\r\n\t\t\t\t\tsectionKey = section['extends'];\r\n\t\t\t\t} while (sectionKey && !~memo.indexOf(sectionKey));\r\n\r\n\r\n\t\t\t\tcache[cacheKey] = utils.extend.apply(utils, stack.reverse());\r\n\t\t\t}\r\n\r\n\t\t\treturn cache[cacheKey];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns newline character\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetNewline: function() {\r\n\t\t\tvar nl = this.getVariable('newline');\r\n\t\t\treturn typeof nl === 'string' ? nl : '\\n';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets new newline character that will be used in output\r\n\t\t * @param {String} str\r\n\t\t */\r\n\t\tsetNewline: function(str) {\r\n\t\t\tthis.setVariable('newline', str);\r\n\t\t\tthis.setVariable('nl', str);\r\n\t\t}\r\n\t});\r\n\r\n\t// XXX add default resolvers\r\n\texports.addResolver(cssResolver.resolve.bind(cssResolver));\r\n\r\n\t// try to load snippets\r\n\t// hide it from Require.JS parser\r\n\t(function(r) {\r\n\t\tif (typeof define === 'undefined' || !define.amd) {\r\n\t\t\ttry {\r\n\t\t\t\texports.setVocabulary(r('../snippets.json'), VOC_SYSTEM);\r\n\t\t\t} catch (e) {}\r\n\t\t}\r\n\t})(require);\r\n\r\n\r\n\treturn exports;\r\n});\r\n\r\n},{\"../assets/logger\":\"assets\\\\logger.js\",\"../resolver/css\":\"resolver\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../vendor/stringScore\":\"vendor\\\\stringScore.js\",\"./elements\":\"assets\\\\elements.js\",\"./handlerList\":\"assets\\\\handlerList.js\"}],\"assets\\\\stringStream.js\":[function(require,module,exports){\r\n/**\r\n * A trimmed version of CodeMirror's StringStream module for string parsing\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * @type StringStream\r\n\t * @constructor\r\n\t * @param {String} string Assuming that bound string should be\r\n\t * immutable\r\n\t */\r\n\tfunction StringStream(string) {\r\n\t\tthis.pos = this.start = 0;\r\n\t\tthis.string = string;\r\n\t\tthis._length = string.length;\r\n\t}\r\n\t\r\n\tStringStream.prototype = {\r\n\t\t/**\r\n\t\t * Returns true only if the stream is at the end of the line.\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\teol: function() {\r\n\t\t\treturn this.pos >= this._length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns true only if the stream is at the start of the line\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tsol: function() {\r\n\t\t\treturn this.pos === 0;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the next character in the stream without advancing it. \r\n\t\t * Will return <code>undefined</code> at the end of the line.\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tpeek: function() {\r\n\t\t\treturn this.string.charAt(this.pos);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the next character in the stream and advances it.\r\n\t\t * Also returns <code>undefined</code> when no more characters are available.\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tnext: function() {\r\n\t\t\tif (this.pos < this._length)\r\n\t\t\t\treturn this.string.charAt(this.pos++);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * match can be a character, a regular expression, or a function that\r\n\t\t * takes a character and returns a boolean. If the next character in the\r\n\t\t * stream 'matches' the given argument, it is consumed and returned.\r\n\t\t * Otherwise, undefined is returned.\r\n\t\t * @param {Object} match\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\teat: function(match) {\r\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\r\n\t\t\tif (typeof match == \"string\")\r\n\t\t\t\tok = ch == match;\r\n\t\t\telse\r\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\r\n\t\t\t\r\n\t\t\tif (ok) {\r\n\t\t\t\t++this.pos;\r\n\t\t\t\treturn ch;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\r\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\r\n\t\t * @param {Object} match\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\teatWhile: function(match) {\r\n\t\t\tvar start = this.pos;\r\n\t\t\twhile (this.eat(match)) {}\r\n\t\t\treturn this.pos > start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\teatSpace: function() {\r\n\t\t\tvar start = this.pos;\r\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\r\n\t\t\t\t++this.pos;\r\n\t\t\treturn this.pos > start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Moves the position to the end of the line.\r\n\t\t */\r\n\t\tskipToEnd: function() {\r\n\t\t\tthis.pos = this._length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Skips to the next occurrence of the given character, if found on the\r\n\t\t * current line (doesn't advance the stream if the character does not\r\n\t\t * occur on the line). Returns true if the character was found.\r\n\t\t * @param {String} ch\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tskipTo: function(ch) {\r\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\r\n\t\t\tif (found > -1) {\r\n\t\t\t\tthis.pos = found;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\r\n\t\t * character, considering possible pair nesting. This function is used\r\n\t\t * to consume pair of characters, like opening and closing braces\r\n\t\t * @param {String} open\r\n\t\t * @param {String} close\r\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\r\n\t\t * consumed\r\n\t\t */\r\n\t\tskipToPair: function(open, close, skipString) {\r\n\t\t\tvar braceCount = 0, ch;\r\n\t\t\tvar pos = this.pos, len = this._length;\r\n\t\t\twhile (pos < len) {\r\n\t\t\t\tch = this.string.charAt(pos++);\r\n\t\t\t\tif (ch == open) {\r\n\t\t\t\t\tbraceCount++;\r\n\t\t\t\t} else if (ch == close) {\r\n\t\t\t\t\tbraceCount--;\r\n\t\t\t\t\tif (braceCount < 1) {\r\n\t\t\t\t\t\tthis.pos = pos;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (skipString && (ch == '\"' || ch == \"'\")) {\r\n\t\t\t\t\tthis.skipString(ch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A helper function which, in case of either single or\r\n\t\t * double quote was found in current position, skips entire\r\n\t\t * string (quoted value)\r\n\t\t * @return {Boolean} Wether quoted string was skipped\r\n\t\t */\r\n\t\tskipQuoted: function(noBackup) {\r\n\t\t\tvar ch = this.string.charAt(noBackup ? this.pos : this.pos - 1);\r\n\t\t\tif (ch === '\"' || ch === \"'\") {\r\n\t\t\t\tif (noBackup) {\r\n\t\t\t\t\tthis.pos++;\r\n\t\t\t\t}\r\n\t\t\t\treturn this.skipString(ch);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A custom function to skip string literal, e.g. a \"double-quoted\"\r\n\t\t * or 'single-quoted' value\r\n\t\t * @param  {String} quote An opening quote\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tskipString: function(quote) {\r\n\t\t\tvar pos = this.pos, len = this._length, ch;\r\n\t\t\twhile (pos < len) {\r\n\t\t\t\tch = this.string.charAt(pos++);\r\n\t\t\t\tif (ch == '\\\\') {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (ch == quote) {\r\n\t\t\t\t\tthis.pos = pos;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Backs up the stream n characters. Backing it up further than the\r\n\t\t * start of the current token will cause things to break, so be careful.\r\n\t\t * @param {Number} n\r\n\t\t */\r\n\t\tbackUp : function(n) {\r\n\t\t\tthis.pos -= n;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Act like a multi-character <code>eat</code>—if <code>consume</code> is true or\r\n\t\t * not given—or a look-ahead that doesn't update the stream position—if\r\n\t\t * it is false. <code>pattern</code> can be either a string or a\r\n\t\t * regular expression starting with ^. When it is a string,\r\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\r\n\t\t * case-insensitive. When successfully matching a regular expression,\r\n\t\t * the returned value will be the array returned by <code>match</code>,\r\n\t\t * in case you need to extract matched groups.\r\n\t\t * \r\n\t\t * @param {RegExp} pattern\r\n\t\t * @param {Boolean} consume\r\n\t\t * @param {Boolean} caseInsensitive\r\n\t\t * @returns\r\n\t\t */\r\n\t\tmatch: function(pattern, consume, caseInsensitive) {\r\n\t\t\tif (typeof pattern == \"string\") {\r\n\t\t\t\tvar cased = caseInsensitive\r\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\r\n\t\t\t\t\t: function(str) {return str;};\r\n\t\t\t\t\r\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\r\n\t\t\t\t\tif (consume !== false)\r\n\t\t\t\t\t\tthis.pos += pattern.length;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\r\n\t\t\t\tif (match && consume !== false)\r\n\t\t\t\t\tthis.pos += match[0].length;\r\n\t\t\t\treturn match;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Get the string between the start of the current token and the \r\n\t\t * current stream position.\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tcurrent: function(backUp) {\r\n\t\t\treturn this.string.slice(this.start, this.pos - (backUp ? 1 : 0));\r\n\t\t}\r\n\t};\r\n\r\n\tmodule.exports = function(string) {\r\n\t\treturn new StringStream(string);\r\n\t};\r\n\r\n\t/** @deprecated */\r\n\tmodule.exports.create = module.exports;\r\n\treturn module.exports;\r\n});\r\n},{}],\"assets\\\\tabStops.js\":[function(require,module,exports){\r\n/**\r\n * Utility module for handling tabstops tokens generated by Emmet's \r\n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\r\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \r\n * occurrences, replace them with tokens suitable for your editor of choice and \r\n * return object with processed text and list of found tabstops and their ranges.\r\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \r\n * sorted array with plain objects.\r\n * \r\n * Placeholders with the same are meant to be <i>linked</i> in your editor.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar stringStream = require('./stringStream');\r\n\tvar resources = require('./resources');\r\n\r\n\t/**\r\n\t * Global placeholder value, automatically incremented by \r\n\t * <code>variablesResolver()</code> function\r\n\t */\r\n\tvar startPlaceholderNum = 100;\r\n\tvar tabstopIndex = 0;\r\n\t\r\n\tvar defaultOptions = {\r\n\t\treplaceCarets: false,\r\n\t\tescape: function(ch) {\r\n\t\t\treturn '\\\\' + ch;\r\n\t\t},\r\n\t\ttabstop: function(data) {\r\n\t\t\treturn data.token;\r\n\t\t},\r\n\t\tvariable: function(data) {\r\n\t\t\treturn data.token;\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\r\n\t\t * and returns a processed version of <code>text</code> with expanded \r\n\t\t * placeholders and list of tabstops found.\r\n\t\t * @param {String} text Text to process\r\n\t\t * @param {Object} options List of processor options:<br>\r\n\t\t * \r\n\t\t * <b>replaceCarets</b> : <code>Boolean</code> — replace all default\r\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\r\n\t\t * \r\n\t\t * <b>escape</b> : <code>Function</code> — function that handle escaped\r\n\t\t * characters (mostly '$'). By default, it returns the character itself \r\n\t\t * to be displayed as is in output, but sometimes you will use \r\n\t\t * <code>extract</code> method as intermediate solution for further \r\n\t\t * processing and want to keep character escaped. Thus, you should override\r\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\r\n\t\t * \r\n\t\t * <b>tabstop</b> : <code>Function</code> – a tabstop handler. Receives \r\n\t\t * a single argument – an object describing token: its position, number \r\n\t\t * group, placeholder and token itself. Should return a replacement \r\n\t\t * string that will appear in final output\r\n\t\t * \r\n\t\t * <b>variable</b> : <code>Function</code> – variable handler. Receives \r\n\t\t * a single argument – an object describing token: its position, name \r\n\t\t * and original token itself. Should return a replacement \r\n\t\t * string that will appear in final output\r\n\t\t * \r\n\t\t * @returns {Object} Object with processed <code>text</code> property\r\n\t\t * and array of <code>tabstops</code> found\r\n\t\t * @memberOf tabStops\r\n\t\t */\r\n\t\textract: function(text, options) {\r\n\t\t\t// prepare defaults\r\n\t\t\tvar placeholders = {carets: ''};\r\n\t\t\tvar marks = [];\r\n\t\t\t\r\n\t\t\toptions = utils.extend({}, defaultOptions, options, {\r\n\t\t\t\ttabstop: function(data) {\r\n\t\t\t\t\tvar token = data.token;\r\n\t\t\t\t\tvar ret = '';\r\n\t\t\t\t\tif (data.placeholder == 'cursor') {\r\n\t\t\t\t\t\tmarks.push({\r\n\t\t\t\t\t\t\tstart: data.start,\r\n\t\t\t\t\t\t\tend: data.start + token.length,\r\n\t\t\t\t\t\t\tgroup: 'carets',\r\n\t\t\t\t\t\t\tvalue: ''\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// unify placeholder value for single group\r\n\t\t\t\t\t\tif ('placeholder' in data)\r\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (data.group in placeholders)\r\n\t\t\t\t\t\t\tret = placeholders[data.group];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmarks.push({\r\n\t\t\t\t\t\t\tstart: data.start,\r\n\t\t\t\t\t\t\tend: data.start + token.length,\r\n\t\t\t\t\t\t\tgroup: data.group,\r\n\t\t\t\t\t\t\tvalue: ret\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (options.replaceCarets) {\r\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate tabstops and unify group's placeholders\r\n\t\t\ttext = this.processText(text, options);\r\n\t\t\t\r\n\t\t\t// now, replace all tabstops with placeholders\r\n\t\t\tvar buf = '', lastIx = 0;\r\n\t\t\tvar tabStops = marks.map(function(mark) {\r\n\t\t\t\tbuf += text.substring(lastIx, mark.start);\r\n\t\t\t\t\r\n\t\t\t\tvar pos = buf.length;\r\n\t\t\t\tvar ph = placeholders[mark.group] || '';\r\n\t\t\t\t\r\n\t\t\t\tbuf += ph;\r\n\t\t\t\tlastIx = mark.end;\r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\tgroup: mark.group,\r\n\t\t\t\t\tstart: pos,\r\n\t\t\t\t\tend:  pos + ph.length\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tbuf += text.substring(lastIx);\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\ttext: buf,\r\n\t\t\t\ttabstops: tabStops.sort(function(a, b) {\r\n\t\t\t\t\treturn a.start - b.start;\r\n\t\t\t\t})\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Text processing routine. Locates escaped characters and tabstops and\r\n\t\t * replaces them with values returned by handlers defined in \r\n\t\t * <code>options</code>\r\n\t\t * @param {String} text\r\n\t\t * @param {Object} options See <code>extract</code> method options \r\n\t\t * description\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tprocessText: function(text, options) {\r\n\t\t\toptions = utils.extend({}, defaultOptions, options);\r\n\t\t\t\r\n\t\t\tvar buf = '';\r\n\t\t\t/** @type StringStream */\r\n\t\t\tvar stream = stringStream.create(text);\r\n\t\t\tvar ch, m, a;\r\n\t\t\t\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\r\n\t\t\t\t\t// handle escaped character\r\n\t\t\t\t\tbuf += options.escape(stream.next());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ta = ch;\r\n\t\t\t\t\r\n\t\t\t\tif (ch == '$') {\r\n\t\t\t\t\t// looks like a tabstop\r\n\t\t\t\t\tstream.start = stream.pos - 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif ((m = stream.match(/^[0-9]+/))) {\r\n\t\t\t\t\t\t// it's $N\r\n\t\t\t\t\t\ta = options.tabstop({\r\n\t\t\t\t\t\t\tstart: buf.length, \r\n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\r\n\t\t\t\t\t\t\ttoken: stream.current()\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if ((m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/))) {\r\n\t\t\t\t\t\t// ${variable}\r\n\t\t\t\t\t\ta = options.variable({\r\n\t\t\t\t\t\t\tstart: buf.length, \r\n\t\t\t\t\t\t\tname: m[1],\r\n\t\t\t\t\t\t\ttoken: stream.current()\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if ((m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false))) {\r\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\r\n\t\t\t\t\t\t// parse placeholder, including nested ones\r\n\t\t\t\t\t\tstream.skipToPair('{', '}');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar obj = {\r\n\t\t\t\t\t\t\tstart: buf.length, \r\n\t\t\t\t\t\t\tgroup: m[1],\r\n\t\t\t\t\t\t\ttoken: stream.current()\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (placeholder) {\r\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ta = options.tabstop(obj);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbuf += a;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn buf;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @param {Number} offset Tab index offset\r\n\t\t * @returns {Number} Maximum tabstop index in element\r\n\t\t */\r\n\t\tupgrade: function(node, offset) {\r\n\t\t\tvar maxNum = 0;\r\n\t\t\tvar options = {\r\n\t\t\t\ttabstop: function(data) {\r\n\t\t\t\t\tvar group = parseInt(data.group, 10);\r\n\t\t\t\t\tif (group > maxNum) maxNum = group;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (data.placeholder)\r\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t['start', 'end', 'content'].forEach(function(p) {\r\n\t\t\t\tnode[p] = this.processText(node[p], options);\r\n\t\t\t}, this);\r\n\t\t\t\r\n\t\t\treturn maxNum;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Helper function that produces a callback function for \r\n\t\t * <code>replaceVariables()</code> method from {@link utils}\r\n\t\t * module. This callback will replace variable definitions (like \r\n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\r\n\t\t * or outputs tabstop with variable name otherwise.\r\n\t\t * @param {AbbreviationNode} node Context node\r\n\t\t * @returns {Function}\r\n\t\t */\r\n\t\tvariablesResolver: function(node) {\r\n\t\t\tvar placeholderMemo = {};\r\n\t\t\treturn function(str, varName) {\r\n\t\t\t\t// do not mark `child` variable as placeholder – it‘s a reserved\r\n\t\t\t\t// variable name\r\n\t\t\t\tif (varName == 'child') {\r\n\t\t\t\t\treturn str;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (varName == 'cursor') {\r\n\t\t\t\t\treturn utils.getCaretPlaceholder();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar attr = node.attribute(varName);\r\n\t\t\t\tif (typeof attr !== 'undefined' && attr !== str) {\r\n\t\t\t\t\treturn attr;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar varValue = resources.getVariable(varName);\r\n\t\t\t\tif (varValue) {\r\n\t\t\t\t\treturn varValue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// output as placeholder\r\n\t\t\t\tif (!placeholderMemo[varName]) {\r\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Replace variables like ${var} in string\r\n\t\t * @param {String} str\r\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \r\n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceVariables: function(str, vars) {\r\n\t\t\tvars = vars || {};\r\n\t\t\tvar resolver = typeof vars === 'function' ? vars : function(str, p1) {\r\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\treturn this.processText(str, {\r\n\t\t\t\tvariable: function(data) {\r\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\r\n\t\t\t\t\tif (newValue === null) {\r\n\t\t\t\t\t\t// try to find variable in resources\r\n\t\t\t\t\t\tnewValue = resources.getVariable(data.name);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (newValue === null || typeof newValue === 'undefined')\r\n\t\t\t\t\t\t// nothing found, return token itself\r\n\t\t\t\t\t\tnewValue = data.token;\r\n\t\t\t\t\treturn newValue;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Resets global tabstop index. When parsed tree is converted to output\r\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \r\n\t\t * defined in snippets and elements are upgraded in order to prevent\r\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\r\n\t\t * should not be linked with the same placehilder of the child node.\r\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\r\n\t\t * upgrades tabstops of the same index for each node and writes maximum\r\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\r\n\t\t * this variable at reasonable value, it is recommended to call \r\n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \r\n\t\t * @returns\r\n\t\t */\r\n\t\tresetTabstopIndex: function() {\r\n\t\t\ttabstopIndex = 0;\r\n\t\t\tstartPlaceholderNum = 100;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Output processor for abbreviation parser that will upgrade tabstops \r\n\t\t * of parsed node in order to prevent tabstop index conflicts\r\n\t\t */\r\n\t\tabbrOutputProcessor: function(text, node, type) {\r\n\t\t\tvar maxNum = 0;\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\tvar tsOptions = {\r\n\t\t\t\ttabstop: function(data) {\r\n\t\t\t\t\tvar group = parseInt(data.group, 10);\r\n\t\t\t\t\tif (group === 0)\r\n\t\t\t\t\t\treturn '${0}';\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (group > maxNum) maxNum = group;\r\n\t\t\t\t\tif (data.placeholder) {\r\n\t\t\t\t\t\t// respect nested placeholders\r\n\t\t\t\t\t\tvar ix = group + tabstopIndex;\r\n\t\t\t\t\t\tvar placeholder = that.processText(data.placeholder, tsOptions);\r\n\t\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// upgrade tabstops\r\n\t\t\ttext = this.processText(text, tsOptions);\r\n\t\t\t\r\n\t\t\t// resolve variables\r\n\t\t\ttext = this.replaceVariables(text, this.variablesResolver(node));\r\n\t\t\t\r\n\t\t\ttabstopIndex += maxNum + 1;\r\n\t\t\treturn text;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./resources\":\"assets\\\\resources.js\",\"./stringStream\":\"assets\\\\stringStream.js\"}],\"assets\\\\tokenIterator.js\":[function(require,module,exports){\r\n/**\r\n * Helper class for convenient token iteration\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * @type TokenIterator\r\n\t * @param {Array} tokens\r\n\t * @type TokenIterator\r\n\t * @constructor\r\n\t */\r\n\tfunction TokenIterator(tokens) {\r\n\t\t/** @type Array */\r\n\t\tthis.tokens = tokens;\r\n\t\tthis._position = 0;\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\tTokenIterator.prototype = {\r\n\t\tnext: function() {\r\n\t\t\tif (this.hasNext()) {\r\n\t\t\t\tvar token = this.tokens[++this._i];\r\n\t\t\t\tthis._position = token.start;\r\n\t\t\t\treturn token;\r\n\t\t\t} else {\r\n\t\t\t\tthis._i = this._il;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tcurrent: function() {\r\n\t\t\treturn this.tokens[this._i];\r\n\t\t},\r\n\r\n\t\tpeek: function() {\r\n\t\t\treturn this.tokens[this._i + i];\r\n\t\t},\r\n\t\t\r\n\t\tposition: function() {\r\n\t\t\treturn this._position;\r\n\t\t},\r\n\t\t\r\n\t\thasNext: function() {\r\n\t\t\treturn this._i < this._il - 1;\r\n\t\t},\r\n\t\t\r\n\t\treset: function() {\r\n\t\t\tthis._i = 0;\r\n\t\t\tthis._il = this.tokens.length;\r\n\t\t},\r\n\t\t\r\n\t\titem: function() {\r\n\t\t\treturn this.tokens[this._i];\r\n\t\t},\r\n\t\t\r\n\t\titemNext: function() {\r\n\t\t\treturn this.tokens[this._i + 1];\r\n\t\t},\r\n\t\t\r\n\t\titemPrev: function() {\r\n\t\t\treturn this.tokens[this._i - 1];\r\n\t\t},\r\n\t\t\r\n\t\tnextUntil: function(type, callback) {\r\n\t\t\tvar token;\r\n\t\t\tvar test = typeof type == 'string' \r\n\t\t\t\t? function(t){return t.type == type;} \r\n\t\t\t\t: type;\r\n\t\t\t\r\n\t\t\twhile ((token = this.next())) {\r\n\t\t\t\tif (callback)\r\n\t\t\t\t\tcallback.call(this, token);\r\n\t\t\t\tif (test.call(this, token))\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\tcreate: function(tokens) {\r\n\t\t\treturn new TokenIterator(tokens);\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"editTree\\\\base.js\":[function(require,module,exports){\r\n/**\r\n * Abstract implementation of edit tree interface.\r\n * Edit tree is a named container of editable “name-value” child elements, \r\n * parsed from <code>source</code>. This container provides convenient methods\r\n * for editing/adding/removing child elements. All these update actions are\r\n * instantly reflected in the <code>source</code> code with respect of formatting.\r\n * <br><br>\r\n * For example, developer can create an edit tree from CSS rule and add or \r\n * remove properties from it–all changes will be immediately reflected in the \r\n * original source.\r\n * <br><br>\r\n * All classes defined in this module should be extended the same way as in\r\n * Backbone framework: using <code>extend</code> method to create new class and \r\n * <code>initialize</code> method to define custom class constructor.\r\n * \r\n * @example\r\n * <pre><code>\r\n * var MyClass = require('editTree/base').EditElement.extend({\r\n *     initialize: function() {\r\n *     // constructor code here\r\n *   }\r\n * });\r\n * \r\n * var elem = new MyClass(); \r\n * </code></pre>\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\tvar klass = require('../vendor/klass');\r\n\t\r\n\t/**\r\n\t * Named container of edited source\r\n\t * @type EditContainer\r\n\t * @param {String} source\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction EditContainer(source, options) {\r\n\t\tthis.options = utils.extend({offset: 0}, options);\r\n\t\t/**\r\n\t\t * Source code of edited structure. All changes in the structure are \r\n\t\t * immediately reflected into this property\r\n\t\t */\r\n\t\tthis.source = source;\r\n\t\t\r\n\t\t/** \r\n\t\t * List of all editable children\r\n\t\t * @private \r\n\t\t */\r\n\t\tthis._children = [];\r\n\t\t\r\n\t\t/**\r\n\t\t * Hash of all positions of container\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._positions = {\r\n\t\t\tname: 0\r\n\t\t};\r\n\t\t\r\n\t\tthis.initialize.apply(this, arguments);\r\n\t}\r\n\t\r\n\t/**\r\n\t * The self-propagating extend function for classes.\r\n\t * @type Function\r\n\t */\r\n\tEditContainer.extend = klass.extend;\r\n\t\r\n\tEditContainer.prototype = {\r\n\t\ttype: 'container',\r\n\t\t/**\r\n\t\t * Child class constructor\r\n\t\t */\r\n\t\tinitialize: function() {},\r\n\r\n\t\t/**\r\n\t\t * Make position absolute\r\n\t\t * @private\r\n\t\t * @param {Number} num\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\t_pos: function(num, isAbsolute) {\r\n\t\t\treturn num + (isAbsolute ? this.options.offset : 0);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replace substring of tag's source\r\n\t\t * @param {String} value\r\n\t\t * @param {Number} start\r\n\t\t * @param {Number} end\r\n\t\t * @private\r\n\t\t */\r\n\t\t_updateSource: function(value, start, end) {\r\n\t\t\t// create modification range\r\n\t\t\tvar r = range.create(start, typeof end === 'undefined' ? 0 : end - start);\r\n\t\t\tvar delta = value.length - r.length();\r\n\t\t\t\r\n\t\t\tvar update = function(obj) {\r\n\t\t\t\tObject.keys(obj).forEach(function(k) {\r\n\t\t\t\t\tif (obj[k] >= r.end) {\r\n\t\t\t\t\t\tobj[k] += delta;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// update affected positions of current container\r\n\t\t\tupdate(this._positions);\r\n\t\t\t\r\n\t\t\t// update affected positions of children\r\n\t\t\tvar recursiveUpdate = function(items) {\r\n\t\t\t\titems.forEach(function(item) {\r\n\t\t\t\t\tupdate(item._positions);\r\n\t\t\t\t\tif (item.type == 'container') {\r\n\t\t\t\t\t\trecursiveUpdate(item.list());\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\trecursiveUpdate(this.list());\r\n\t\t\tthis.source = utils.replaceSubstring(this.source, value, r);\r\n\t\t},\r\n\t\t\t\r\n\t\t\t\r\n\t\t/**\r\n\t\t * Adds new attribute \r\n\t\t * @param {String} name Property name\r\n\t\t * @param {String} value Property value\r\n\t\t * @param {Number} pos Position at which to insert new property. By \r\n\t\t * default the property is inserted at the end of rule \r\n\t\t * @returns {EditElement} Newly created element\r\n\t\t */\r\n\t\tadd: function(name, value, pos) {\r\n\t\t\t// this is abstract implementation\r\n\t\t\tvar item = new EditElement(name, value);\r\n\t\t\tthis._children.push(item);\r\n\t\t\treturn item;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns attribute object\r\n\t\t * @param {String} name Attribute name or its index\r\n\t\t * @returns {EditElement}\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\tif (typeof name === 'number') {\r\n\t\t\t\treturn this.list()[name];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\treturn utils.find(this.list(), function(prop) {\r\n\t\t\t\t\treturn prop.name() === name;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all children by name or indexes\r\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\r\n\t\t * <code>Array</code>, <code>Number</code>)\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetAll: function(name) {\r\n\t\t\tif (!Array.isArray(name))\r\n\t\t\t\tname = [name];\r\n\t\t\t\r\n\t\t\t// split names and indexes\r\n\t\t\tvar names = [], indexes = [];\r\n\t\t\tname.forEach(function(item) {\r\n\t\t\t\tif (typeof item === 'string') {\r\n\t\t\t\t\tnames.push(item);\r\n\t\t\t\t} else if (typeof item === 'number') {\r\n\t\t\t\t\tindexes.push(item);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn this.list().filter(function(attribute, i) {\r\n\t\t\t\treturn ~indexes.indexOf(i) || ~names.indexOf(attribute.name());\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns list of all editable child elements\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlist: function() {\r\n\t\t\treturn this._children;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove child element\r\n\t\t * @param {String} name Property name or its index\r\n\t\t */\r\n\t\tremove: function(name) {\r\n\t\t\tvar element = this.get(name);\r\n\t\t\tif (element) {\r\n\t\t\t\tthis._updateSource('', element.fullRange());\r\n\t\t\t\tvar ix = this._children.indexOf(element);\r\n\t\t\t\tif (~ix) {\r\n\t\t\t\t\tthis._children.splice(ix, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns index of editble child in list\r\n\t\t * @param {Object} item\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tindexOf: function(item) {\r\n\t\t\treturn this.list().indexOf(this.get(item));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns or updates element value. If such element doesn't exists,\r\n\t\t * it will be created automatically and added at the end of child list.\r\n\t\t * @param {String} name Element name or its index\r\n\t\t * @param {String} value New element value\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalue: function(name, value, pos) {\r\n\t\t\tvar element = this.get(name);\r\n\t\t\tif (element)\r\n\t\t\t\treturn element.value(value);\r\n\t\t\t\r\n\t\t\tif (typeof value !== 'undefined') {\r\n\t\t\t\t// no such element — create it\r\n\t\t\t\treturn this.add(name, value, pos);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all values of child elements found by <code>getAll()</code>\r\n\t\t * method\r\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\r\n\t\t * <code>Array</code>, <code>Number</code>)\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tvalues: function(name) {\r\n\t\t\treturn this.getAll(name).map(function(element) {\r\n\t\t\t\treturn element.value();\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets or gets container name\r\n\t\t * @param {String} val New name. If not passed, current \r\n\t\t * name is returned\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tname: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._name !== (val = String(val))) {\r\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\r\n\t\t\t\tthis._name = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns name range object\r\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \r\n\t\t * rule offset)\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tnameRange: function(isAbsolute) {\r\n\t\t\treturn range.create(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns range of current source\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t */\r\n\t\trange: function(isAbsolute) {\r\n\t\t\treturn range.create(isAbsolute ? this.options.offset : 0, this.valueOf());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element that belongs to specified position\r\n\t\t * @param {Number} pos\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t * @returns {EditElement}\r\n\t\t */\r\n\t\titemFromPosition: function(pos, isAbsolute) {\r\n\t\t\treturn utils.find(this.list(), function(elem) {\r\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns source code of current container \r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.source;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * @param {EditContainer} parent\r\n\t * @param {Object} nameToken\r\n\t * @param {Object} valueToken\r\n\t */\r\n\tfunction EditElement(parent, nameToken, valueToken) {\r\n\t\t/** @type EditContainer */\r\n\t\tthis.parent = parent;\r\n\t\t\r\n\t\tthis._name = nameToken.value;\r\n\t\tthis._value = valueToken ? valueToken.value : '';\r\n\t\t\r\n\t\tthis._positions = {\r\n\t\t\tname: nameToken.start,\r\n\t\t\tvalue: valueToken ? valueToken.start : -1\r\n\t\t};\r\n\t\t\r\n\t\tthis.initialize.apply(this, arguments);\r\n\t}\r\n\t\r\n\t/**\r\n\t * The self-propagating extend function for classes.\r\n\t * @type Function\r\n\t */\r\n\tEditElement.extend = klass.extend;\r\n\t\r\n\tEditElement.prototype = {\r\n\t\ttype: 'element',\r\n\r\n\t\t/**\r\n\t\t * Child class constructor\r\n\t\t */\r\n\t\tinitialize: function() {},\r\n\t\t\r\n\t\t/**\r\n\t\t * Make position absolute\r\n\t\t * @private\r\n\t\t * @param {Number} num\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\t_pos: function(num, isAbsolute) {\r\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\r\n\t\t},\r\n\t\t\t\r\n\t\t/**\r\n\t\t * Sets of gets element value\r\n\t\t * @param {String} val New element value. If not passed, current \r\n\t\t * value is returned\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalue: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._value !== (val = String(val))) {\r\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\r\n\t\t\t\tthis._value = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._value;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets of gets element name\r\n\t\t * @param {String} val New element name. If not passed, current \r\n\t\t * name is returned\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tname: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._name !== (val = String(val))) {\r\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\r\n\t\t\t\tthis._name = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns position of element name token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tnamePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns position of element value token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tvaluePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element name\r\n\t\t * @param {Boolean} isAbsolute Return absolute range \r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\trange: function(isAbsolute) {\r\n\t\t\treturn range.create(this.namePosition(isAbsolute), this.valueOf());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns full element range, including possible indentation\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tfullRange: function(isAbsolute) {\r\n\t\t\treturn this.range(isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element name range\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tnameRange: function(isAbsolute) {\r\n\t\t\treturn range.create(this.namePosition(isAbsolute), this.name());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element value range\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tvalueRange: function(isAbsolute) {\r\n\t\t\treturn range.create(this.valuePosition(isAbsolute), this.value());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns current element string representation\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\t\t\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.name() + this.value();\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\tEditContainer: EditContainer,\r\n\t\tEditElement: EditElement,\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates token that can be fed to <code>EditElement</code>\r\n\t\t * @param {Number} start\r\n\t\t * @param {String} value\r\n\t\t * @param {String} type\r\n\t\t * @returns\r\n\t\t */\r\n\t\tcreateToken: function(start, value, type) {\r\n\t\t\tvar obj = {\r\n\t\t\t\tstart: start || 0,\r\n\t\t\t\tvalue: value || '',\r\n\t\t\t\ttype: type\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tobj.end = obj.start + obj.value.length;\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../utils/common\":\"utils\\\\common.js\",\"../vendor/klass\":\"vendor\\\\klass.js\"}],\"editTree\\\\css.js\":[function(require,module,exports){\r\n/**\r\n * CSS EditTree is a module that can parse a CSS rule into a tree with \r\n * convenient methods for adding, modifying and removing CSS properties. These \r\n * changes can be written back to string with respect of code formatting.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar editTree = require('./base');\r\n\tvar cssParser = require('../parser/css');\r\n\tvar cssSections = require('../utils/cssSections');\r\n\tvar range = require('../assets/range');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar tokenIterator = require('../assets/tokenIterator');\r\n\r\n\tvar defaultOptions = {\r\n\t\tstyleBefore: '\\n\\t',\r\n\t\tstyleSeparator: ': ',\r\n\t\toffset: 0\r\n\t};\r\n\t\r\n\tvar reSpaceStart = /^\\s+/;\r\n\tvar reSpaceEnd = /\\s+$/;\r\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\r\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\r\n\t\r\n\t/**\r\n\t * Modifies given range to remove whitespace from beginning\r\n\t * and/or from the end\r\n\t * @param  {Range} rng Range to modify\r\n\t * @param  {String} text  Text that range belongs to\r\n\t * @param  {Number} mask  Mask indicating from which end \r\n\t * whitespace should be removed\r\n\t * @return {Range}\r\n\t */\r\n\tfunction trimWhitespaceInRange(rng, text, mask) {\r\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\r\n\t\ttext = rng.substring(text);\r\n\t\tvar m;\r\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) && (m = text.match(reSpaceStart))) {\r\n\t\t\trng.start += m[0].length;\r\n\t\t}\r\n\r\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) && (m = text.match(reSpaceEnd))) {\r\n\t\t\trng.end -= m[0].length;\r\n\t\t}\r\n\r\n\t\t// in case given range is just a whatespace\r\n\t\tif (rng.end < rng.start) {\r\n\t\t\trng.end = rng.start;\r\n\t\t}\r\n\r\n\t\treturn rng;\r\n\t}\r\n\r\n\t/**\r\n\t * Consumes CSS property and value from current token\r\n\t * iterator state. Offsets iterator pointer into token\r\n\t * that can be used for next value consmption\r\n\t * @param  {TokenIterator} it\r\n\t * @param  {String} text\r\n\t * @return {Object}    Object with `name` and `value` properties \r\n\t * ar ranges. Value range can be zero-length.\r\n\t */\r\n\tfunction consumeSingleProperty(it, text) {\r\n\t\tvar name, value, end;\r\n\t\tvar token = it.current();\r\n\r\n\t\tif (!token) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// skip whitespace\r\n\t\tvar ws = {'white': 1, 'line': 1, 'comment': 1};\r\n\t\twhile ((token = it.current())) {\r\n\t\t\tif (!(token.type in ws)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tit.next();\r\n\t\t}\r\n\r\n\t\tif (!it.hasNext()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// consume property name\r\n\t\ttoken = it.current();\r\n\t\tname = range(token.start, token.value);\r\n\t\tvar isAtProperty = token.value.charAt(0) == '@';\r\n\t\twhile (token = it.next()) {\r\n\t\t\tname.end = token.end;\r\n\t\t\tif (token.type == ':' || token.type == 'white') {\r\n\t\t\t\tname.end = token.start;\r\n\t\t\t\tit.next();\r\n\t\t\t\tif (token.type == ':' || isAtProperty) {\r\n\t\t\t\t\t// XXX I really ashame of this hardcode, but I need\r\n\t\t\t\t\t// to stop parsing if this is an SCSS mixin call,\r\n\t\t\t\t\t// for example: @include border-radius(10px)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type == ';' || token.type == 'line') {\r\n\t\t\t\t// there’s no value, looks like a mixin\r\n\t\t\t\t// or a special use case:\r\n\t\t\t\t// user is writing a new property or abbreviation\r\n\t\t\t\tname.end = token.start;\r\n\t\t\t\tvalue = range(token.start, 0);\r\n\t\t\t\tit.next();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttoken = it.current();\r\n\t\tif (!value && token) {\r\n\t\t\tif (token.type == 'line') {\r\n\t\t\t\tlastNewline = token;\r\n\t\t\t}\r\n\t\t\t// consume value\r\n\t\t\tvalue = range(token.start, token.value);\r\n\t\t\tvar lastNewline;\r\n\t\t\twhile ((token = it.next())) {\r\n\t\t\t\tvalue.end = token.end;\r\n\t\t\t\tif (token.type == 'line') {\r\n\t\t\t\t\tlastNewline = token;\r\n\t\t\t\t} else if (token.type == '}' || token.type == ';') {\r\n\t\t\t\t\tvalue.end = token.start;\r\n\t\t\t\t\tif (token.type == ';') {\r\n\t\t\t\t\t\tend = range(token.start, token.value);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tit.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (token.type == ':' && lastNewline) {\r\n\t\t\t\t\t// A special case: \r\n\t\t\t\t\t// user is writing a value before existing\r\n\t\t\t\t\t// property, but didn’t inserted closing semi-colon.\r\n\t\t\t\t\t// In this case, limit value range to previous\r\n\t\t\t\t\t// newline\r\n\t\t\t\t\tvalue.end = lastNewline.start;\r\n\t\t\t\t\tit._i = it.tokens.indexOf(lastNewline);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!value) {\r\n\t\t\tvalue = range(name.end, 0);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tname: trimWhitespaceInRange(name, text),\r\n\t\t\tvalue: trimWhitespaceInRange(value, text, WHITESPACE_REMOVE_FROM_START | (end ? WHITESPACE_REMOVE_FROM_END : 0)),\r\n\t\t\tend: end || range(value.end, 0)\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Finds parts of complex CSS value\r\n\t * @param {String} str\r\n\t * @returns {Array} Returns list of <code>Range</code>'s\r\n\t */\r\n\tfunction findParts(str) {\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(str);\r\n\t\tvar ch;\r\n\t\tvar result = [];\r\n\t\tvar sep = /[\\s\\u00a0,;]/;\r\n\t\t\r\n\t\tvar add = function() {\r\n\t\t\tstream.next();\r\n\t\t\tresult.push(range(stream.start, stream.current()));\r\n\t\t\tstream.start = stream.pos;\r\n\t\t};\r\n\t\t\r\n\t\t// skip whitespace\r\n\t\tstream.eatSpace();\r\n\t\tstream.start = stream.pos;\r\n\t\t\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (ch == '\"' || ch == \"'\") {\r\n\t\t\t\tstream.next();\r\n\t\t\t\tif (!stream.skipTo(ch)) break;\r\n\t\t\t\tadd();\r\n\t\t\t} else if (ch == '(') {\r\n\t\t\t\t// function found, may have nested function\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tadd();\r\n\t\t\t} else {\r\n\t\t\t\tif (sep.test(ch)) {\r\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\r\n\t\t\t\t\tstream.eatWhile(sep);\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tadd();\r\n\r\n\t\treturn utils.unique(result.filter(function(item) {\r\n\t\t\treturn !!item.length();\r\n\t\t}));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parses CSS properties from given CSS source\r\n\t * and adds them to CSSEditContainer node\r\n\t * @param  {CSSEditContainer} node\r\n\t * @param  {String} source CSS source\r\n\t * @param {Number} offset Offset of properties subset from original source\r\n\t */\r\n\tfunction consumeProperties(node, source, offset) {\r\n\t\tvar list = extractPropertiesFromSource(source, offset);\r\n\r\n\t\tlist.forEach(function(property) {\r\n\t\t\tnode._children.push(new CSSEditElement(node,\r\n\t\t\t\teditTree.createToken(property.name.start, property.nameText),\r\n\t\t\t\teditTree.createToken(property.value.start, property.valueText),\r\n\t\t\t\teditTree.createToken(property.end.start, property.endText)\r\n\t\t\t\t));\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Parses given CSS source and returns list of ranges of located CSS properties.\r\n\t * Normally, CSS source must contain properties only, it must be,\r\n\t * for example, a content of CSS selector or text between nested\r\n\t * CSS sections\r\n\t * @param  {String} source CSS source\r\n\t * @param {Number} offset Offset of properties subset from original source.\r\n\t * Used to provide proper ranges of locates items\r\n\t */\r\n\tfunction extractPropertiesFromSource(source, offset) {\r\n\t\toffset = offset || 0;\r\n\t\tsource = source.replace(reSpaceEnd, '');\r\n\t\tvar out = [];\r\n\r\n\t\tif (!source) {\r\n\t\t\treturn out;\r\n\t\t}\r\n\r\n\t\tvar tokens = cssParser.parse(source);\r\n\t\tvar it = tokenIterator.create(tokens);\r\n\t\tvar property;\r\n\r\n\t\twhile ((property = consumeSingleProperty(it, source))) {\r\n\t\t\tout.push({\r\n\t\t\t\tnameText: property.name.substring(source),\r\n\t\t\t\tname: property.name.shift(offset),\r\n\r\n\t\t\t\tvalueText: property.value.substring(source),\r\n\t\t\t\tvalue: property.value.shift(offset),\r\n\r\n\t\t\t\tendText: property.end.substring(source),\r\n\t\t\t\tend: property.end.shift(offset)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @class\r\n\t * @extends EditContainer\r\n\t */\r\n\tvar CSSEditContainer = editTree.EditContainer.extend({\r\n\t\tinitialize: function(source, options) {\r\n\t\t\tutils.extend(this.options, defaultOptions, options);\r\n\t\t\t\r\n\t\t\tif (Array.isArray(source)) {\r\n\t\t\t\tsource = cssParser.toSource(source);\r\n\t\t\t}\r\n\r\n\t\t\tvar allRules = cssSections.findAllRules(source);\r\n\t\t\tvar currentRule = allRules.shift();\r\n\r\n\t\t\t// keep top-level rules only since they will\r\n\t\t\t// be parsed by nested CSSEditContainer call\r\n\t\t\tvar topLevelRules = [];\r\n\t\t\tallRules.forEach(function(r) {\r\n\t\t\t\tvar isTopLevel = !utils.find(topLevelRules, function(tr) {\r\n\t\t\t\t\treturn tr.contains(r);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (isTopLevel) {\r\n\t\t\t\t\ttopLevelRules.push(r);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\t\tvar selectorRange = range.create2(currentRule.start, currentRule._selectorEnd);\r\n\t\t\tthis._name = selectorRange.substring(source);\r\n\t\t\tthis._positions.name = selectorRange.start;\r\n\t\t\tthis._positions.contentStart = currentRule._contentStart + 1;\r\n\r\n\t\t\tvar sectionOffset = currentRule._contentStart + 1;\r\n\t\t\tvar sectionEnd = currentRule.end - 1;\r\n\r\n\t\t\t// parse properties between nested rules\r\n\t\t\t// and add nested rules as children\r\n\t\t\tvar that = this;\r\n\t\t\ttopLevelRules.forEach(function(r) {\r\n\t\t\t\tconsumeProperties(that, source.substring(sectionOffset, r.start), sectionOffset);\r\n\t\t\t\tvar opt = utils.extend({}, that.options, {offset: r.start + that.options.offset});\r\n\t\t\t\t// XXX I think I don’t need nested containers here\r\n\t\t\t\t// They should be handled separately\r\n\t\t\t\t// that._children.push(new CSSEditContainer(r.substring(source), opt));\r\n\t\t\t\tsectionOffset = r.end;\r\n\t\t\t});\r\n\r\n\t\t\t// consume the rest of data\r\n\t\t\tconsumeProperties(this, source.substring(sectionOffset, currentRule.end - 1), sectionOffset);\r\n\t\t\tthis._saveStyle();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Remembers all styles of properties\r\n\t\t * @private\r\n\t\t */\r\n\t\t_saveStyle: function() {\r\n\t\t\tvar start = this._positions.contentStart;\r\n\t\t\tvar source = this.source;\r\n\t\t\t\r\n\t\t\tthis.list().forEach(function(p) {\r\n\t\t\t\tif (p.type === 'container') {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\r\n\t\t\t\t// a small hack here:\r\n\t\t\t\t// Sometimes users add empty lines before properties to logically\r\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\r\n\t\t\t\t// characters between rules may lead to undesired behavior,\r\n\t\t\t\t// especially when current rule is duplicated or used as a donor\r\n\t\t\t\t// to create new rule.\r\n\t\t\t\t// To solve this issue, we‘ll take only last newline indentation\r\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\r\n\t\t\t\tif (lines.length > 1) {\r\n\t\t\t\t\tp.styleBefore = '\\n' + lines[lines.length - 1];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\r\n\t\t\t\t\r\n\t\t\t\t// graceful and naive comments removal \r\n\t\t\t\tvar parts = p.styleBefore.split('*/');\r\n\t\t\t\tp.styleBefore = parts[parts.length - 1];\r\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\r\n\t\t\t\t\r\n\t\t\t\tstart = p.range().end;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns position of element name token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tnamePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns position of element value token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tvaluePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.contentStart, isAbsolute);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns element value range\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tvalueRange: function(isAbsolute) {\r\n\t\t\treturn range.create2(this.valuePosition(isAbsolute), this._pos(this.valueOf().length, isAbsolute) - 1);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new CSS property \r\n\t\t * @param {String} name Property name\r\n\t\t * @param {String} value Property value\r\n\t\t * @param {Number} pos Position at which to insert new property. By \r\n\t\t * default the property is inserted at the end of rule \r\n\t\t * @returns {CSSEditProperty}\r\n\t\t */\r\n\t\tadd: function(name, value, pos) {\r\n\t\t\tvar list = this.list();\r\n\t\t\tvar start = this._positions.contentStart;\r\n\t\t\tvar styles = utils.pick(this.options, 'styleBefore', 'styleSeparator');\r\n\t\t\t\r\n\t\t\tif (typeof pos === 'undefined') {\r\n\t\t\t\tpos = list.length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/** @type CSSEditProperty */\r\n\t\t\tvar donor = list[pos];\r\n\t\t\tif (donor) {\r\n\t\t\t\tstart = donor.fullRange().start;\r\n\t\t\t} else if ((donor = list[pos - 1])) {\r\n\t\t\t\t// make sure that donor has terminating semicolon\r\n\t\t\t\tdonor.end(';');\r\n\t\t\t\tstart = donor.range().end;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (donor) {\r\n\t\t\t\tstyles = utils.pick(donor, 'styleBefore', 'styleSeparator');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\r\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\r\n\t\t\t\r\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\r\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\r\n\t\t\t\r\n\t\t\tutils.extend(property, styles);\r\n\t\t\t\r\n\t\t\t// write new property into the source\r\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\r\n\t\t\t\r\n\t\t\t// insert new property\r\n\t\t\tthis._children.splice(pos, 0, property);\r\n\t\t\treturn property;\r\n\t\t}\r\n\t});\r\n\t\r\n\t/**\r\n\t * @class\r\n\t * @type CSSEditElement\r\n\t * @constructor\r\n\t */\r\n\tvar CSSEditElement = editTree.EditElement.extend({\r\n\t\tinitialize: function(rule, name, value, end) {\r\n\t\t\tthis.styleBefore = rule.options.styleBefore;\r\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\r\n\t\t\t\r\n\t\t\tthis._end = end.value;\r\n\t\t\tthis._positions.end = end.start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns ranges of complex value parts\r\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\r\n\t\t */\r\n\t\tvalueParts: function(isAbsolute) {\r\n\t\t\tvar parts = findParts(this.value());\r\n\t\t\tif (isAbsolute) {\r\n\t\t\t\tvar offset = this.valuePosition(true);\r\n\t\t\t\tparts.forEach(function(p) {\r\n\t\t\t\t\tp.shift(offset);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn parts;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets of gets element value. \r\n\t\t * When setting value, this implementation will ensure that your have \r\n\t\t * proper name-value separator\r\n\t\t * @param {String} val New element value. If not passed, current \r\n\t\t * value is returned\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalue: function(val) {\r\n\t\t\tvar isUpdating = typeof val !== 'undefined';\r\n\t\t\tvar allItems = this.parent.list();\r\n\t\t\tif (isUpdating && this.isIncomplete()) {\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tvar donor = utils.find(allItems, function(item) {\r\n\t\t\t\t\treturn item !== self && !item.isIncomplete();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.styleSeparator = donor \r\n\t\t\t\t\t? donor.styleSeparator \r\n\t\t\t\t\t: this.parent.options.styleSeparator;\r\n\t\t\t\tthis.parent._updateSource(this.styleSeparator, range(this.valueRange().start, 0));\r\n\t\t\t}\r\n\r\n\t\t\tvar value = this.constructor.__super__.value.apply(this, arguments);\r\n\t\t\tif (isUpdating) {\r\n\t\t\t\t// make sure current property has terminating semi-colon\r\n\t\t\t\t// if it’s not the last one\r\n\t\t\t\tvar ix = allItems.indexOf(this);\r\n\t\t\t\tif (ix !== allItems.length - 1 && !this.end()) {\r\n\t\t\t\t\tthis.end(';');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Test if current element is incomplete, e.g. has no explicit\r\n\t\t * name-value separator\r\n\t\t * @return {Boolean} [description]\r\n\t\t */\r\n\t\tisIncomplete: function() {\r\n\t\t\treturn this.nameRange().end === this.valueRange().start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets of gets property end value (basically, it's a semicolon)\r\n\t\t * @param {String} val New end value. If not passed, current \r\n\t\t * value is returned\r\n\t\t */\r\n\t\tend: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._end !== val) {\r\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\r\n\t\t\t\tthis._end = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._end;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns full rule range, with indentation\r\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\r\n\t\t * rule offset)\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tfullRange: function(isAbsolute) {\r\n\t\t\tvar r = this.range(isAbsolute);\r\n\t\t\tr.start -= this.styleBefore.length;\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns item string representation\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Parses CSS rule into editable tree\r\n\t\t * @param {String} source\r\n\t\t * @param {Object} options\r\n\t\t * @memberOf emmet.cssEditTree\r\n\t\t * @returns {EditContainer}\r\n\t\t */\r\n\t\tparse: function(source, options) {\r\n\t\t\treturn new CSSEditContainer(source, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \r\n\t\t * @param {String} content CSS source code\r\n\t\t * @param {Number} pos Character position where to start source code extraction\r\n\t\t * @returns {EditContainer}\r\n\t\t */\r\n\t\tparseFromPosition: function(content, pos, isBackward) {\r\n\t\t\tvar bounds = cssSections.locateRule(content, pos, isBackward);\r\n\t\t\tif (!bounds || !bounds.inside(pos)) {\r\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this.parse(bounds.substring(content), {\r\n\t\t\t\toffset: bounds.start\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Locates CSS property in given CSS code fragment under specified character position\r\n\t\t * @param  {String} css CSS code or parsed CSSEditContainer\r\n\t\t * @param  {Number} pos Character position where to search CSS property\r\n\t\t * @return {CSSEditElement}\r\n\t\t */\r\n\t\tpropertyFromPosition: function(css, pos) {\r\n\t\t\tvar cssProp = null;\r\n\t\t\t/** @type EditContainer */\r\n\t\t\tvar cssRule = typeof css === 'string' ? this.parseFromPosition(css, pos, true) : css;\r\n\t\t\tif (cssRule) {\r\n\t\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\r\n\t\t\t\tif (!cssProp) {\r\n\t\t\t\t\t// in case user just started writing CSS property\r\n\t\t\t\t\t// and didn't include semicolon–try another approach\r\n\t\t\t\t\tcssProp = utils.find(cssRule.list(), function(elem) {\r\n\t\t\t\t\t\treturn elem.range(true).end == pos;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn cssProp;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes vendor prefix from CSS property\r\n\t\t * @param {String} name CSS property\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tbaseName: function(name) {\r\n\t\t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds parts of complex CSS value\r\n\t\t * @param {String} str\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tfindParts: findParts,\r\n\r\n\t\textractPropertiesFromSource: extractPropertiesFromSource\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../assets/tokenIterator\":\"assets\\\\tokenIterator.js\",\"../parser/css\":\"parser\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"./base\":\"editTree\\\\base.js\"}],\"editTree\\\\xml.js\":[function(require,module,exports){\r\n/**\r\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \r\n * convenient methods for adding, modifying and removing attributes. These \r\n * changes can be written back to string with respect of code formatting.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar editTree = require('./base');\r\n\tvar xmlParser = require('../parser/xml');\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\r\n\tvar defaultOptions = {\r\n\t\tstyleBefore: ' ',\r\n\t\tstyleSeparator: '=',\r\n\t\tstyleQuote: '\"',\r\n\t\toffset: 0\r\n\t};\r\n\t\r\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\r\n\t\r\n\tvar XMLEditContainer = editTree.EditContainer.extend({\r\n\t\tinitialize: function(source, options) {\r\n\t\t\tutils.defaults(this.options, defaultOptions);\r\n\t\t\tthis._positions.name = 1;\r\n\t\t\t\r\n\t\t\tvar attrToken = null;\r\n\t\t\tvar tokens = xmlParser.parse(source);\r\n\t\t\t\r\n\t\t\ttokens.forEach(function(token) {\r\n\t\t\t\ttoken.value = range.create(token).substring(source);\r\n\t\t\t\tswitch (token.type) {\r\n\t\t\t\t\tcase 'tag':\r\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\r\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 'attribute':\r\n\t\t\t\t\t\t// add empty attribute\r\n\t\t\t\t\t\tif (attrToken) {\r\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tattrToken = token;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\r\n\t\t\t\t\t\tattrToken = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\t\r\n\t\t\tif (attrToken) {\r\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._saveStyle();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Remembers all styles of properties\r\n\t\t * @private\r\n\t\t */\r\n\t\t_saveStyle: function() {\r\n\t\t\tvar start = this.nameRange().end;\r\n\t\t\tvar source = this.source;\r\n\t\t\t\r\n\t\t\tthis.list().forEach(function(p) {\r\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\r\n\t\t\t\t\r\n\t\t\t\tif (p.valuePosition() !== -1) {\r\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstart = p.range().end;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new attribute \r\n\t\t * @param {String} name Property name\r\n\t\t * @param {String} value Property value\r\n\t\t * @param {Number} pos Position at which to insert new property. By \r\n\t\t * default the property is inserted at the end of rule \r\n\t\t */\r\n\t\tadd: function(name, value, pos) {\r\n\t\t\tvar list = this.list();\r\n\t\t\tvar start = this.nameRange().end;\r\n\t\t\tvar styles = utils.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\r\n\t\t\t\r\n\t\t\tif (typeof pos === 'undefined') {\r\n\t\t\t\tpos = list.length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t/** @type XMLEditAttribute */\r\n\t\t\tvar donor = list[pos];\r\n\t\t\tif (donor) {\r\n\t\t\t\tstart = donor.fullRange().start;\r\n\t\t\t} else if ((donor = list[pos - 1])) {\r\n\t\t\t\tstart = donor.range().end;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (donor) {\r\n\t\t\t\tstyles = utils.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\r\n\t\t\t\r\n\t\t\tvar attribute = new XMLEditElement(this, \r\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\r\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \r\n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\r\n\t\t\t\t\t);\r\n\t\t\t\r\n\t\t\tutils.extend(attribute, styles);\r\n\t\t\t\r\n\t\t\t// write new attribute into the source\r\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\r\n\t\t\t\r\n\t\t\t// insert new attribute\r\n\t\t\tthis._children.splice(pos, 0, attribute);\r\n\t\t\treturn attribute;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A special case of attribute editing: adds class value to existing\r\n\t\t * `class` attribute\r\n\t\t * @param {String} value\r\n\t\t */\r\n\t\taddClass: function(value) {\r\n\t\t\tvar attr = this.get('class');\r\n\t\t\tvalue = utils.trim(value);\r\n\t\t\tif (!attr) {\r\n\t\t\t\treturn this.add('class', value);\r\n\t\t\t}\r\n\r\n\t\t\tvar classVal = attr.value();\r\n\t\t\tvar classList = ' ' + classVal.replace(/\\n/g, ' ') + ' ';\r\n\t\t\tif (!~classList.indexOf(' ' + value + ' ')) {\r\n\t\t\t\tattr.value(classVal + ' ' + value);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A special case of attribute editing: removes class value from existing\r\n\t\t * `class` attribute\r\n\t\t * @param {String} value\r\n\t\t */\r\n\t\tremoveClass: function(value) {\r\n\t\t\tvar attr = this.get('class');\r\n\t\t\tvalue = utils.trim(value);\r\n\t\t\tif (!attr) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar reClass = new RegExp('(^|\\\\s+)' + utils.escapeForRegexp(value));\r\n\t\t\tvar classVal = attr.value().replace(reClass, '');\r\n\t\t\tif (!utils.trim(classVal)) {\r\n\t\t\t\tthis.remove('class');\r\n\t\t\t} else {\r\n\t\t\t\tattr.value(classVal);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tvar XMLEditElement = editTree.EditElement.extend({\r\n\t\tinitialize: function(parent, nameToken, valueToken) {\r\n\t\t\tthis.styleBefore = parent.options.styleBefore;\r\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\r\n\t\t\t\r\n\t\t\tvar value = '', quote = parent.options.styleQuote;\r\n\t\t\tif (valueToken) {\r\n\t\t\t\tvalue = valueToken.value;\r\n\t\t\t\tquote = value.charAt(0);\r\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\r\n\t\t\t\t\tvalue = value.substring(1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tquote = '';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\r\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.styleQuote = quote;\r\n\t\t\t\r\n\t\t\tthis._value = value;\r\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns full rule range, with indentation\r\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\r\n\t\t * rule offset)\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tfullRange: function(isAbsolute) {\r\n\t\t\tvar r = this.range(isAbsolute);\r\n\t\t\tr.start -= this.styleBefore.length;\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\t\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.name() + this.styleSeparator\r\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Parses HTML element into editable tree\r\n\t\t * @param {String} source\r\n\t\t * @param {Object} options\r\n\t\t * @memberOf emmet.htmlEditTree\r\n\t\t * @returns {EditContainer}\r\n\t\t */\r\n\t\tparse: function(source, options) {\r\n\t\t\treturn new XMLEditContainer(source, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extract and parse HTML from specified position in <code>content</code> \r\n\t\t * @param {String} content CSS source code\r\n\t\t * @param {Number} pos Character position where to start source code extraction\r\n\t\t * @returns {XMLEditElement}\r\n\t\t */\r\n\t\tparseFromPosition: function(content, pos, isBackward) {\r\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\r\n\t\t\tif (!bounds || !bounds.inside(pos))\r\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\r\n\t\t\t\treturn null;\r\n\t\t\t\r\n\t\t\treturn this.parse(bounds.substring(content), {\r\n\t\t\t\toffset: bounds.start\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \r\n\t\t * <code>pos</code> position\r\n\t\t * @param {String} content\r\n\t\t * @param {Number} pos\r\n\t\t * @param {Boolean} isBackward\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\textractTag: function(content, pos, isBackward) {\r\n\t\t\tvar len = content.length, i;\r\n\t\t\t\r\n\t\t\t// max extraction length. I don't think there may be tags larger \r\n\t\t\t// than 2000 characters length\r\n\t\t\tvar maxLen = Math.min(2000, len);\r\n\t\t\t\r\n\t\t\t/** @type Range */\r\n\t\t\tvar r = null;\r\n\t\t\t\r\n\t\t\tvar match = function(pos) {\r\n\t\t\t\tvar m;\r\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\r\n\t\t\t\t\treturn range.create(pos, m[0]);\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// lookup backward, in case we are inside tag already\r\n\t\t\tfor (i = pos; i >= 0; i--) {\r\n\t\t\t\tif ((r = match(i))) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (r && (r.inside(pos) || isBackward))\r\n\t\t\t\treturn r;\r\n\t\t\t\r\n\t\t\tif (!r && isBackward)\r\n\t\t\t\treturn null;\r\n\t\t\t\r\n\t\t\t// search forward\r\n\t\t\tfor (i = pos; i < len; i++) {\r\n\t\t\t\tif ((r = match(i)))\r\n\t\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../parser/xml\":\"parser\\\\xml.js\",\"../utils/common\":\"utils\\\\common.js\",\"./base\":\"editTree\\\\base.js\"}],\"filter\\\\bem.js\":[function(require,module,exports){\r\n/**\r\n * Filter for aiding of writing elements with complex class names as described\r\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\r\n * automatically inherit block and element names from parent elements and insert\r\n * them into child element classes\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar htmlFilter = require('./html');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar abbreviationUtils = require('../utils/abbreviation');\r\n\tvar utils = require('../utils/common');\r\n\r\n\tprefs.define('bem.elementSeparator', '__', 'Class name’s element separator.');\r\n\tprefs.define('bem.modifierSeparator', '_', 'Class name’s modifier separator.');\r\n\tprefs.define('bem.shortElementPrefix', '-', \r\n\t\t\t'Symbol for describing short “block-element” notation. Class names '\r\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parent‘s '\r\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \r\n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\r\n\t\r\n\tvar shouldRunHtmlFilter = false;\r\n\t\r\n\tfunction getSeparators() {\r\n\t\treturn {\r\n\t\t\telement: prefs.get('bem.elementSeparator'),\r\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {AbbreviationNode} item\r\n\t */\r\n\tfunction bemParse(item) {\r\n\t\tif (abbreviationUtils.isSnippet(item))\r\n\t\t\treturn item;\r\n\t\t\r\n\t\t// save BEM stuff in cache for faster lookups\r\n\t\titem.__bem = {\r\n\t\t\tblock: '',\r\n\t\t\telement: '',\r\n\t\t\tmodifier: ''\r\n\t\t};\r\n\t\t\r\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\r\n\t\t\r\n\t\t// guess best match for block name\r\n\t\tvar reBlockName = /^[a-z]\\-/i;\r\n\t\titem.__bem.block = utils.find(classNames, function(name) {\r\n\t\t\treturn reBlockName.test(name);\r\n\t\t});\r\n\t\t\r\n\t\t// guessing doesn't worked, pick first class name as block name\r\n\t\tif (!item.__bem.block) {\r\n\t\t\treBlockName = /^[a-z]/i;\r\n\t\t\titem.__bem.block = utils.find(classNames, function(name) {\r\n\t\t\t\treturn reBlockName.test(name);\r\n\t\t\t}) || '';\r\n\t\t}\r\n\r\n\t\tclassNames = classNames.map(function(name) {\r\n\t\t\treturn processClassName(name, item);\r\n\t\t});\r\n\r\n\t\tclassNames = utils.unique(utils.flatten(classNames)).join(' ');\r\n\t\tif (classNames) {\r\n\t\t\titem.attribute('class', classNames);\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param {String} className\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeClassName(className) {\r\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\r\n\t\t\r\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\r\n\t\tif (shortSymbol) {\r\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\r\n\t\t\tclassName = className.replace(re, function(str, p1) {\r\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn utils.trim(className);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes class name\r\n\t * @param {String} name Class name item to process\r\n\t * @param {AbbreviationNode} item Host node for provided class name\r\n\t * @returns Processed class name. May return <code>Array</code> of\r\n\t * class names \r\n\t */\r\n\tfunction processClassName(name, item) {\r\n\t\tname = transformClassName(name, item, 'element');\r\n\t\tname = transformClassName(name, item, 'modifier');\r\n\t\t\r\n\t\t// expand class name\r\n\t\t// possible values:\r\n\t\t// * block__element\r\n\t\t// * block__element_modifier\r\n\t\t// * block__element_modifier1_modifier2\r\n\t\t// * block_modifier\r\n\t\tvar block = '', element = '', modifier = '';\r\n\t\tvar separators = getSeparators();\r\n\t\tif (~name.indexOf(separators.element)) {\r\n\t\t\tvar elements = name.split(separators.element);\r\n\t\t\tblock = elements.shift();\r\n\r\n\t\t\tvar modifiers = elements.pop().split(separators.modifier);\r\n\t\t\telements.push(modifiers.shift());\r\n\t\t\telement = elements.join(separators.element);\r\n\t\t\tmodifier = modifiers.join(separators.modifier);\r\n\t\t} else if (~name.indexOf(separators.modifier)) {\r\n\t\t\tvar blockModifiers = name.split(separators.modifier);\r\n\t\t\t\r\n\t\t\tblock = blockModifiers.shift();\r\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\r\n\t\t}\r\n\t\t\r\n\t\tif (block || element || modifier) {\r\n\t\t\tif (!block) {\r\n\t\t\t\tblock = item.__bem.block;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// inherit parent bem element, if exists\r\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\r\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\r\n\t\t\t\r\n\t\t\t// produce multiple classes\r\n\t\t\tvar prefix = block;\r\n\t\t\tvar result = [];\r\n\t\t\t\r\n\t\t\tif (element) {\r\n\t\t\t\tprefix += separators.element + element;\r\n\t\t\t\tresult.push(prefix);\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(prefix);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (modifier) {\r\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!item.__bem.block || modifier) {\r\n\t\t\t\titem.__bem.block = block;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\titem.__bem.element = element;\r\n\t\t\titem.__bem.modifier = modifier;\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\t\r\n\t\t// ...otherwise, return processed or original class name\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Low-level function to transform user-typed class name into full BEM class\r\n\t * @param {String} name Class name item to process\r\n\t * @param {AbbreviationNode} item Host node for provided class name\r\n\t * @param {String} entityType Type of entity to be tried to transform \r\n\t * ('element' or 'modifier')\r\n\t * @returns {String} Processed class name or original one if it can't be\r\n\t * transformed\r\n\t */\r\n\tfunction transformClassName(name, item, entityType) {\r\n\t\tvar separators = getSeparators();\r\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\r\n\t\tif (reSep.test(name)) {\r\n\t\t\tvar depth = 0; // parent lookup depth\r\n\t\t\tvar cleanName = name.replace(reSep, function(str) {\r\n\t\t\t\tdepth = str.length / separators[entityType].length;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// find donor element\r\n\t\t\tvar donor = item;\r\n\t\t\twhile (donor.parent && depth--) {\r\n\t\t\t\tdonor = donor.parent;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!donor || !donor.__bem)\r\n\t\t\t\tdonor = item;\r\n\t\t\t\r\n\t\t\tif (donor && donor.__bem) {\r\n\t\t\t\tvar prefix = donor.__bem.block;\r\n\t\t\t\t\r\n\t\t\t\t// decide if we should inherit element name\r\n//\t\t\t\tif (entityType == 'element') {\r\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\r\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\r\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\r\n//\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\r\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\r\n\t\t\t\t\r\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Recursive function for processing tags, which extends class names \r\n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\r\n\t * <br><br>\r\n\t * It does several things:<br>\r\n\t * <ul>\r\n\t * <li>Expands complex class name (according to BEM symbol semantics):\r\n\t * .block__elem_modifier → .block.block__elem.block__elem_modifier\r\n\t * </li>\r\n\t * <li>Inherits block name on child elements: \r\n\t * .b-block > .__el > .__el → .b-block > .b-block__el > .b-block__el__el\r\n\t * </li>\r\n\t * <li>Treats first dash symbol as '__'</li>\r\n\t * <li>Double underscore (or typographic '–') is also treated as an element \r\n\t * level lookup, e.g. ____el will search for element definition in parent’s \r\n\t * parent element:\r\n\t * .b-block > .__el1 > .____el2 → .b-block > .b-block__el1 > .b-block__el2\r\n\t * </li>\r\n\t * </ul>\r\n\t * \r\n\t * @param {AbbreviationNode} tree\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction process(tree, profile) {\r\n\t\tif (tree.name) {\r\n\t\t\tbemParse(tree, profile);\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tprocess(item, profile);\r\n\t\t\tif (!abbreviationUtils.isSnippet(item) && item.start) {\r\n\t\t\t\tshouldRunHtmlFilter = true;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn function(tree, profile) {\r\n\t\tshouldRunHtmlFilter = false;\r\n\t\ttree = process(tree, profile);\r\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\r\n\t\t// to update output\r\n\t\tif (shouldRunHtmlFilter) {\r\n\t\t\ttree = htmlFilter(tree, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./html\":\"filter\\\\html.js\"}],\"filter\\\\comment.js\":[function(require,module,exports){\r\n/**\r\n * Comment important tags (with 'id' and 'class' attributes)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar utils = require('../utils/common');\r\n\tvar template = require('../utils/template');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar filterCore = require('./main');\r\n\t\r\n\tprefs.define('filter.commentAfter', \r\n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\r\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\r\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\r\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\r\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\r\n\t\t\t+ 'the following properties and functions are availabe:\\n'\r\n\t\t\t+ '<ul>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>attr(name, before, after)</code> – a function that outputs' \r\n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \r\n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \r\n\t\t\t+ 'empty string will be returned.</li>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>node</code> – current node (instance of <code>AbbreviationNode</code>)</li>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>name</code> – name of current tag</li>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>padding</code> – current string padding, can be used ' \r\n\t\t\t+ 'for formatting</li>'\r\n\t\t\t\r\n\t\t\t+'</ul>');\r\n\t\r\n\tprefs.define('filter.commentBefore', \r\n\t\t\t'',\r\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\r\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\r\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\r\n\t\t\t+ 'property');\r\n\t\r\n\tprefs.define('filter.commentTrigger', 'id, class',\r\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\r\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\r\n\t\t\t+ 'every element, set this option to <code>*</code>');\r\n\t\r\n\t/**\r\n\t * Add comments to tag\r\n\t * @param {AbbreviationNode} node\r\n\t */\r\n\tfunction addComments(node, templateBefore, templateAfter) {\r\n\t\t// check if comments should be added\r\n\t\tvar trigger = prefs.get('filter.commentTrigger');\r\n\t\tif (trigger != '*') {\r\n\t\t\tvar shouldAdd = utils.find(trigger.split(','), function(name) {\r\n\t\t\t\treturn !!node.attribute(utils.trim(name));\r\n\t\t\t});\r\n\r\n\t\t\tif (!shouldAdd) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar ctx = {\r\n\t\t\tnode: node,\r\n\t\t\tname: node.name(),\r\n\t\t\tpadding: node.parent ? node.parent.padding : '',\r\n\t\t\tattr: function(name, before, after) {\r\n\t\t\t\tvar attr = node.attribute(name);\r\n\t\t\t\tif (attr) {\r\n\t\t\t\t\treturn (before || '') + attr + (after || '');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar nodeBefore = templateBefore ? templateBefore(ctx) : '';\r\n\t\tvar nodeAfter = templateAfter ? templateAfter(ctx) : '';\r\n\t\t\r\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\r\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\r\n\t}\r\n\t\r\n\tfunction process(tree, before, after) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (abbrUtils.isBlock(item)) {\r\n\t\t\t\taddComments(item, before, after);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, before, after);\r\n\t\t});\r\n\t\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn function(tree) {\r\n\t\tvar templateBefore = template(prefs.get('filter.commentBefore'));\r\n\t\tvar templateAfter = template(prefs.get('filter.commentAfter'));\r\n\t\t\r\n\t\treturn process(tree, templateBefore, templateAfter);\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/template\":\"utils\\\\template.js\",\"./main\":\"filter\\\\main.js\"}],\"filter\\\\css.js\":[function(require,module,exports){\r\n/**\r\n * Filter for outputting CSS and alike\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * Test if passed item is very first child in parsed tree\r\n\t * @param {AbbreviationNode} item\r\n\t */\r\n\tfunction isVeryFirstChild(item) {\r\n\t\treturn item.parent && !item.parent.parent && !item.index();\r\n\t}\r\n\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false) {\r\n\t\t\t\titem.start = '\\n' + item.start;\r\n\t\t\t}\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{}],\"filter\\\\escape.js\":[function(require,module,exports){\r\n/**\r\n * Filter for escaping unsafe XML characters: <, >, &\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar charMap = {\r\n\t\t'<': '&lt;',\r\n\t\t'>': '&gt;',\r\n\t\t'&': '&amp;'\r\n\t};\r\n\t\r\n\tfunction escapeChars(str) {\r\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\r\n\t\t\treturn charMap[p1];\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\titem.start = escapeChars(item.start);\r\n\t\t\titem.end = escapeChars(item.end);\r\n\t\t\titem.content = escapeChars(item.content);\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{}],\"filter\\\\format.js\":[function(require,module,exports){\r\n/**\r\n * Generic formatting filter: creates proper indentation for each tree node,\r\n * placing \"%s\" placeholder where the actual output should be. You can use\r\n * this filter to preformat tree and then replace %s placeholder to whatever you\r\n * need. This filter should't be called directly from editor as a part \r\n * of abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\tprefs.define('format.noIndentTags', 'html', \r\n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\r\n\t\r\n\tprefs.define('format.forceIndentationForTags', 'body', \r\n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\r\n\r\n\tvar placeholder = '%s';\r\n\t\r\n\t/**\r\n\t * Get indentation for given node\r\n\t * @param {AbbreviationNode} node\r\n\t * @returns {String}\r\n\t */\r\n\tfunction getIndentation(node) {\r\n\t\tvar items = prefs.getArray('format.noIndentTags') || [];\r\n\t\tif (~items.indexOf(node.name())) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t\t\r\n\t\treturn '\\t';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Test if passed node has block-level sibling element\r\n\t * @param {AbbreviationNode} item\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction hasBlockSibling(item) {\r\n\t\treturn item.parent && abbrUtils.hasBlockChildren(item.parent);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Test if passed item is very first child in parsed tree\r\n\t * @param {AbbreviationNode} item\r\n\t */\r\n\tfunction isVeryFirstChild(item) {\r\n\t\treturn item.parent && !item.parent.parent && !item.index();\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if a newline should be added before element\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction shouldAddLineBreak(node, profile) {\r\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\r\n\t\t\treturn true;\r\n\t\t\r\n\t\tif (!node.parent || !profile.inline_break)\r\n\t\t\treturn false;\r\n\t\t\r\n\t\t// check if there are required amount of adjacent inline element\r\n\t\treturn shouldFormatInline(node.parent, profile);\r\n}\r\n\t\r\n\t/**\r\n\t * Need to add newline because <code>item</code> has too many inline children\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction shouldBreakChild(node, profile) {\r\n\t\t// we need to test only one child element, because \r\n\t\t// hasBlockChildren() method will do the rest\r\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\r\n\t}\r\n\t\r\n\tfunction shouldFormatInline(node, profile) {\r\n\t\tvar nodeCount = 0;\r\n\t\treturn !!utils.find(node.children, function(child) {\r\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\r\n\t\t\t\tnodeCount = 0;\r\n\t\t\telse if (abbrUtils.isInline(child))\r\n\t\t\t\tnodeCount++;\r\n\t\t\t\r\n\t\t\tif (nodeCount >= profile.inline_break)\r\n\t\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\t\r\n\tfunction isRoot(item) {\r\n\t\treturn !item.parent;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with matched resource of type <code>snippet</code>\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processSnippet(item, profile) {\r\n\t\titem.start = item.end = '';\r\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\r\n\t\t\t// check if we’re not inside inline element\r\n\t\t\tif (isRoot(item.parent) || !abbrUtils.isInline(item.parent)) {\r\n\t\t\t\titem.start = '\\n' + item.start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if we should add line breaks inside inline element\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction shouldBreakInsideInline(node, profile) {\r\n\t\tvar hasBlockElems = node.children.some(function(child) {\r\n\t\t\tif (abbrUtils.isSnippet(child))\r\n\t\t\t\treturn false;\r\n\t\t\t\r\n\t\t\treturn !abbrUtils.isInline(child);\r\n\t\t});\r\n\t\t\r\n\t\tif (!hasBlockElems) {\r\n\t\t\treturn shouldFormatInline(node, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\titem.start = item.end = placeholder;\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar nl = '\\n';\r\n\t\tvar indent = getIndentation(item);\r\n\t\t\t\r\n\t\t// formatting output\r\n\t\tif (profile.tag_nl !== false) {\r\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\r\n\t\t\tif (!forceNl) {\r\n\t\t\t\tvar forceIndentTags = prefs.getArray('format.forceIndentationForTags') || [];\r\n\t\t\t\tforceNl = ~forceIndentTags.indexOf(item.name());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// formatting block-level elements\r\n\t\t\tif (!item.isTextNode()) {\r\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\r\n\t\t\t\t\t// - do not indent the very first element\r\n\t\t\t\t\t// - do not indent first child of a snippet\r\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\r\n\t\t\t\t\t\titem.start = nl + item.start;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\r\n\t\t\t\t\t\titem.end = nl + item.end;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\r\n\t\t\t\t\t\titem.start += nl + indent;\r\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\r\n\t\t\t\t\titem.start = nl + item.start;\r\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\r\n\t\t\t\t\titem.end = nl + item.end;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\titem.padding = indent;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes simplified tree, making it suitable for output as HTML structure\r\n\t * @param {AbbreviationNode} tree\r\n\t * @param {OutputProfile} profile\r\n\t * @param {Number} level Depth level\r\n\t */\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessSnippet(item, profile, level);\r\n\t\t\t} else {\r\n\t\t\t\tprocessTag(item, profile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"filter\\\\haml.js\":[function(require,module,exports){\r\n/**\r\n * Filter for producing HAML code from abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar formatFilter = require('./format');\r\n\r\n\tfunction transformClassName(className) {\r\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\r\n\t}\r\n\r\n\t/**\r\n\t * Condenses all \"data-\" attributes into a single entry.\r\n\t * HAML allows data attributes to be ouputted as a sub-hash\r\n\t * of `:data` key\r\n\t * @param  {Array} attrs\r\n\t * @return {Array}\r\n\t */\r\n\tfunction condenseDataAttrs(attrs) {\r\n\t\tvar out = [], data = null;\r\n\t\tvar reData = /^data-/i;\r\n\t\tattrs.forEach(function(attr) {\r\n\t\t\tif (reData.test(attr.name)) {\r\n\t\t\t\tif (!data) {\r\n\t\t\t\t\tdata = [];\r\n\t\t\t\t\tout.push({\r\n\t\t\t\t\t\tname: 'data',\r\n\t\t\t\t\t\tvalue: data\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.push(utils.extend({}, attr, {name: attr.name.replace(reData, '')}));\r\n\t\t\t} else {\r\n\t\t\t\tout.push(attr);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction stringifyAttrs(attrs, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\treturn '{' + attrs.map(function(attr) {\r\n\t\t\tvar value = attrQuote + attr.value + attrQuote;\r\n\t\t\tif (Array.isArray(attr.value)) {\r\n\t\t\t\tvalue = stringifyAttrs(attr.value, profile);\r\n\t\t\t} else if (attr.isBoolean) {\r\n\t\t\t\tvalue = 'true';\r\n\t\t\t}\r\n\r\n\t\t\treturn ':' + attr.name + ' => ' + value\r\n\t\t}).join(', ') + '}';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates HAML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} tag\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction makeAttributesString(tag, profile) {\r\n\t\tvar attrs = '';\r\n\t\tvar otherAttrs = [];\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\ttag.attributeList().forEach(function(a) {\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tswitch (attrName.toLowerCase()) {\r\n\t\t\t\t// use short notation for ID and CLASS attributes\r\n\t\t\t\tcase 'id':\r\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'class':\r\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t// process other attributes\r\n\t\t\t\tdefault:\r\n\t\t\t\t\totherAttrs.push({\r\n\t\t\t\t\t\tname: attrName,\r\n\t\t\t\t\t\tvalue: a.value || cursor,\r\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (otherAttrs.length) {\r\n\t\t\tattrs += stringifyAttrs(condenseDataAttrs(otherAttrs), profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn attrs;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent)\r\n\t\t\t// looks like it's root element\r\n\t\t\treturn item;\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile);\r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\r\n\t\tvar start= '';\r\n\t\t\t\r\n\t\t// define tag name\r\n\t\tvar tagName = '%' + profile.tagName(item.name());\r\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\r\n\t\t\t// omit div tag\r\n\t\t\ttagName = '';\r\n\t\t\t\r\n\t\titem.end = '';\r\n\t\tstart = tagName + attrs + selfClosing;\r\n\t\tif (item.content && !/^\\s/.test(item.content)) {\r\n\t\t\titem.content = ' ' + item.content;\r\n\t\t}\r\n\t\t\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\tif (!item.children.length && !isUnary)\r\n\t\t\titem.start += cursor;\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\ttree = formatFilter(tree, '_format', profile);\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, profile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\html.js\":[function(require,module,exports){\r\n/**\r\n * Filter that produces HTML tree\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar utils = require('../utils/common');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar formatFilter = require('./format');\r\n\r\n\t/**\r\n\t * Creates HTML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction makeAttributesString(node, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\treturn node.attributeList().map(function(a) {\r\n\t\t\tvar isBoolean = profile.isBoolean(a.name, a.value);\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tvar attrValue = isBoolean ? attrName : a.value;\r\n\t\t\tif (isBoolean && profile.allowCompactBoolean()) {\r\n\t\t\t\treturn ' ' + attrName;\r\n\t\t\t}\r\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (attrValue || cursor) + attrQuote;\r\n\t\t}).join('');\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent) { // looks like it's root element\r\n\t\t\treturn item;\r\n\t\t}\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile); \r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar start = '';\r\n\t\tvar end = '';\r\n\t\t\t\r\n\t\t// define opening and closing tags\r\n\t\tif (!item.isTextNode()) {\r\n\t\t\tvar tagName = profile.tagName(item.name());\r\n\t\t\tif (isUnary) {\r\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\r\n\t\t\t\titem.end = '';\r\n\t\t\t} else {\r\n\t\t\t\tstart = '<' + tagName + attrs + '>';\r\n\t\t\t\tend = '</' + tagName + '>';\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\t// should we put caret placeholder after opening tag?\r\n\t\tif (\r\n\t\t\t\t!item.children.length \r\n\t\t\t\t&& !isUnary \r\n\t\t\t\t&& !~item.content.indexOf(cursor)\r\n\t\t\t\t&& !tabStops.extract(item.content).tabstops.length\r\n\t\t\t) {\r\n\t\t\titem.start += cursor;\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\ttree = formatFilter(tree, profile, level)\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, profile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\jade.js\":[function(require,module,exports){\r\n/**\r\n * Filter for producing Jade code from abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar formatFilter = require('./format');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar profile = require('../assets/profile');\r\n\r\n\tvar reNl = /[\\n\\r]/;\r\n\tvar reIndentedText = /^\\s*\\|/;\r\n\tvar reSpace = /^\\s/;\r\n\r\n\tfunction transformClassName(className) {\r\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\r\n\t}\r\n\r\n\tfunction stringifyAttrs(attrs, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\treturn '(' + attrs.map(function(attr) {\r\n\t\t\tif (attr.isBoolean) {\r\n\t\t\t\treturn attr.name;\r\n\t\t\t}\r\n\r\n\t\t\treturn attr.name + '=' + attrQuote + attr.value + attrQuote;\r\n\t\t}).join(', ') + ')';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates HAML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} tag\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction makeAttributesString(tag, profile) {\r\n\t\tvar attrs = '';\r\n\t\tvar otherAttrs = [];\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\ttag.attributeList().forEach(function(a) {\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tswitch (attrName.toLowerCase()) {\r\n\t\t\t\t// use short notation for ID and CLASS attributes\r\n\t\t\t\tcase 'id':\r\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'class':\r\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t// process other attributes\r\n\t\t\t\tdefault:\r\n\t\t\t\t\totherAttrs.push({\r\n\t\t\t\t\t\tname: attrName,\r\n\t\t\t\t\t\tvalue: a.value || cursor,\r\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (otherAttrs.length) {\r\n\t\t\tattrs += stringifyAttrs(otherAttrs, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn attrs;\r\n\t}\r\n\r\n\tfunction processTagContent(item) {\r\n\t\tif (!item.content) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar content = tabStops.replaceVariables(item.content, function(str, name) {\r\n\t\t\tif (name === 'nl' || name === 'newline') {\r\n\t\t\t\treturn '\\n';\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t});\r\n\r\n\t\tif (reNl.test(content) && !reIndentedText.test(content)) {\r\n\t\t\t// multiline content: pad it with indentation and pipe\r\n\t\t\tvar pad = '| ';\r\n\t\t\titem.content = '\\n' + pad + utils.padString(content, pad);\r\n\t\t} else if (!reSpace.test(content)) {\r\n\t\t\titem.content = ' ' + content;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent)\r\n\t\t\t// looks like it's a root (empty) element\r\n\t\t\treturn item;\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile);\r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\t\t\r\n\t\t// define tag name\r\n\t\tvar tagName = profile.tagName(item.name());\r\n\t\tif (tagName.toLowerCase() == 'div' && attrs && attrs.charAt(0) != '(')\r\n\t\t\t// omit div tag\r\n\t\t\ttagName = '';\r\n\t\t\t\r\n\t\titem.end = '';\r\n\t\tvar start = tagName + attrs;\r\n\t\tprocessTagContent(item);\r\n\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\tif (!item.children.length && !isUnary)\r\n\t\t\titem.start += cursor;\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, curProfile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\t// always format with `xml` profile since\r\n\t\t\t// Jade requires all tags to be on separate lines\r\n\t\t\ttree = formatFilter(tree, profile.get('xml'));\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, curProfile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, curProfile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\jsx.js\":[function(require,module,exports){\r\n/**\r\n * A filter for React.js (JSX):\r\n * ranames attributes like `class` and `for`\r\n * for proper representation in JSX\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar attrMap = {\r\n\t\t'class': 'className',\r\n\t\t'for': 'htmlFor'\r\n\t};\r\n\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\titem._attributes.forEach(function(attr) {\r\n\t\t\t\tif (attr.name in attrMap) {\r\n\t\t\t\t\tattr.name = attrMap[attr.name]\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{}],\"filter\\\\main.js\":[function(require,module,exports){\r\n/**\r\n * Module for handling filters\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar profile = require('../assets/profile');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\t/** List of registered filters */\r\n\tvar registeredFilters = {\r\n\t\thtml: require('./html'),\r\n\t\thaml: require('./haml'),\r\n\t\tjade: require('./jade'),\r\n\t\tjsx: require('./jsx'),\r\n\t\tslim: require('./slim'),\r\n\t\txsl: require('./xsl'),\r\n\t\tcss: require('./css'),\r\n\t\tbem: require('./bem'),\r\n\t\tc: require('./comment'),\r\n\t\te: require('./escape'),\r\n\t\ts: require('./singleLine'),\r\n\t\tt: require('./trim')\r\n\t};\r\n\t\r\n\t/** Filters that will be applied for unknown syntax */\r\n\tvar basicFilters = 'html';\r\n\t\r\n\tfunction list(filters) {\r\n\t\tif (!filters)\r\n\t\t\treturn [];\r\n\t\t\r\n\t\tif (typeof filters === 'string') {\r\n\t\t\treturn filters.split(/[\\|,]/g);\r\n\t\t}\r\n\t\t\r\n\t\treturn filters;\r\n\t}\r\n\t\r\n\treturn  {\r\n\t\t/**\r\n\t\t * Register new filter\r\n\t\t * @param {String} name Filter name\r\n\t\t * @param {Function} fn Filter function\r\n\t\t */\r\n\t\tadd: function(name, fn) {\r\n\t\t\tregisteredFilters[name] = fn;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Apply filters for final output tree\r\n\t\t * @param {AbbreviationNode} tree Output tree\r\n\t\t * @param {Array} filters List of filters to apply. Might be a \r\n\t\t * <code>String</code>\r\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \r\n\t\t * module. Filters defined it profile are not used, <code>profile</code>\r\n\t\t * is passed to filter function\r\n\t\t * @memberOf emmet.filters\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tapply: function(tree, filters, profileName) {\r\n\t\t\tprofileName = profile.get(profileName);\r\n\t\t\t\r\n\t\t\tlist(filters).forEach(function(filter) {\r\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\r\n\t\t\t\tif (name && name in registeredFilters) {\r\n\t\t\t\t\ttree = registeredFilters[name](tree, profileName);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn tree;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Composes list of filters that should be applied to a tree, based on \r\n\t\t * passed data\r\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\r\n\t\t * @param {Object} profile Output profile\r\n\t\t * @param {String} additionalFilters List or pipe-separated\r\n\t\t * string of additional filters to apply\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tcomposeList: function(syntax, profileName, additionalFilters) {\r\n\t\t\tprofileName = profile.get(profileName);\r\n\t\t\tvar filters = list(profileName.filters || resources.findItem(syntax, 'filters') || basicFilters);\r\n\t\t\t\r\n\t\t\tif (profileName.extraFilters) {\r\n\t\t\t\tfilters = filters.concat(list(profileName.extraFilters));\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tif (additionalFilters) {\r\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tif (!filters || !filters.length) {\r\n\t\t\t\t// looks like unknown syntax, apply basic filters\r\n\t\t\t\tfilters = list(basicFilters);\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn filters;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts filter list from abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \r\n\t\t * extracted filters\r\n\t\t */\r\n\t\textract: function(abbr) {\r\n\t\t\tvar filters = '';\r\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\r\n\t\t\t\tfilters = p1;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn [abbr, list(filters)];\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"./bem\":\"filter\\\\bem.js\",\"./comment\":\"filter\\\\comment.js\",\"./css\":\"filter\\\\css.js\",\"./escape\":\"filter\\\\escape.js\",\"./haml\":\"filter\\\\haml.js\",\"./html\":\"filter\\\\html.js\",\"./jade\":\"filter\\\\jade.js\",\"./jsx\":\"filter\\\\jsx.js\",\"./singleLine\":\"filter\\\\singleLine.js\",\"./slim\":\"filter\\\\slim.js\",\"./trim\":\"filter\\\\trim.js\",\"./xsl\":\"filter\\\\xsl.js\"}],\"filter\\\\singleLine.js\":[function(require,module,exports){\r\n/**\r\n * Output abbreviation on a single line (i.e. no line breaks)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar rePad = /^\\s+/;\r\n\tvar reNl = /[\\n\\r]/g;\r\n\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\t// remove padding from item \r\n\t\t\t\titem.start = item.start.replace(rePad, '');\r\n\t\t\t\titem.end = item.end.replace(rePad, '');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// remove newlines \r\n\t\t\titem.start = item.start.replace(reNl, '');\r\n\t\t\titem.end = item.end.replace(reNl, '');\r\n\t\t\titem.content = item.content.replace(reNl, '');\r\n\t\t\t\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n\r\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\"}],\"filter\\\\slim.js\":[function(require,module,exports){\r\n/**\r\n * Filter for producing Jade code from abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar formatFilter = require('./format');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar profile = require('../assets/profile');\r\n\r\n\tvar reNl = /[\\n\\r]/;\r\n\tvar reIndentedText = /^\\s*\\|/;\r\n\tvar reSpace = /^\\s/;\r\n\r\n\tprefs.define('slim.attributesWrapper', 'none', \r\n\t\t'Defines how attributes will be wrapped:' +\r\n\t\t'<ul>' +\r\n\t\t'<li><code>none</code> – no wrapping;</li>' +\r\n\t\t'<li><code>round</code> — wrap attributes with round braces;</li>' +\r\n\t\t'<li><code>square</code> — wrap attributes with round braces;</li>' +\r\n\t\t'<li><code>curly</code> — wrap attributes with curly braces.</li>' +\r\n\t\t'</ul>');\r\n\r\n\tfunction transformClassName(className) {\r\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\r\n\t}\r\n\r\n\tfunction getAttrWrapper() {\r\n\t\tvar start = ' ', end = '';\r\n\t\tswitch (prefs.get('slim.attributesWrapper')) {\r\n\t\t\tcase 'round':\r\n\t\t\t\tstart = '(';\r\n\t\t\t\tend = ')';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'square':\r\n\t\t\t\tstart = '[';\r\n\t\t\t\tend = ']';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'curly':\r\n\t\t\t\tstart = '{';\r\n\t\t\t\tend = '}';\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tstart: start,\r\n\t\t\tend: end\r\n\t\t};\r\n\t}\r\n\r\n\tfunction stringifyAttrs(attrs, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar attrWrap = getAttrWrapper();\r\n\t\treturn attrWrap.start + attrs.map(function(attr) {\r\n\t\t\tvar value = attrQuote + attr.value + attrQuote;\r\n\t\t\tif (attr.isBoolean) {\r\n\t\t\t\tif (!attrWrap.end) {\r\n\t\t\t\t\tvalue = 'true';\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn attr.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn attr.name + '=' + value;\r\n\t\t}).join(' ') + attrWrap.end;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates HAML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} tag\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction makeAttributesString(tag, profile) {\r\n\t\tvar attrs = '';\r\n\t\tvar otherAttrs = [];\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\ttag.attributeList().forEach(function(a) {\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tswitch (attrName.toLowerCase()) {\r\n\t\t\t\t// use short notation for ID and CLASS attributes\r\n\t\t\t\tcase 'id':\r\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'class':\r\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t// process other attributes\r\n\t\t\t\tdefault:\r\n\t\t\t\t\totherAttrs.push({\r\n\t\t\t\t\t\tname: attrName,\r\n\t\t\t\t\t\tvalue: a.value || cursor,\r\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (otherAttrs.length) {\r\n\t\t\tattrs += stringifyAttrs(otherAttrs, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn attrs;\r\n\t}\r\n\r\n\tfunction processTagContent(item) {\r\n\t\tif (!item.content) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar content = tabStops.replaceVariables(item.content, function(str, name) {\r\n\t\t\tif (name === 'nl' || name === 'newline') {\r\n\t\t\t\treturn '\\n';\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t});\r\n\r\n\t\tif (reNl.test(content) && !reIndentedText.test(content)) {\r\n\t\t\t// multiline content: pad it with indentation and pipe\r\n\t\t\tvar pad = '  ';\r\n\t\t\titem.content = '\\n| ' + utils.padString(content, pad);\r\n\t\t} else if (!reSpace.test(content)) {\r\n\t\t\titem.content = ' ' + content;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent)\r\n\t\t\t// looks like it's a root (empty) element\r\n\t\t\treturn item;\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile);\r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\r\n\t\t\t\r\n\t\t// define tag name\r\n\t\tvar tagName = profile.tagName(item.name());\r\n\t\tif (tagName.toLowerCase() == 'div' && attrs && '([{'.indexOf(attrs.charAt(0)) == -1)\r\n\t\t\t// omit div tag\r\n\t\t\ttagName = '';\r\n\t\t\t\r\n\t\titem.end = '';\r\n\t\tvar start = tagName + attrs + selfClosing;\r\n\t\tprocessTagContent(item);\r\n\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\tif (!item.children.length && !isUnary)\r\n\t\t\titem.start += cursor;\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, curProfile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\t// always format with `xml` profile since\r\n\t\t\t// Slim requires all tags to be on separate lines\r\n\t\t\ttree = formatFilter(tree, profile.get('xml'));\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, curProfile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, curProfile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\trim.js\":[function(require,module,exports){\r\n/**\r\n * Trim filter: removes characters at the beginning of the text\r\n * content that indicates lists: numbers, #, *, -, etc.\r\n * \r\n * Useful for wrapping lists with abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tprefs.define('filter.trimRegexp', \r\n\t\t'[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\r\n\t\t'Regular expression used to remove list markers (numbers, dashes, ' \r\n\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\r\n\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \r\n\t\t+ 'documents (for example, Word documents).');\r\n\t\r\n\tfunction process(tree, re) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (item.content) {\r\n\t\t\t\titem.content = item.content.replace(re, '');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, re);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn function(tree) {\r\n\t\tvar re = new RegExp(prefs.get('filter.trimRegexp'));\r\n\t\treturn process(tree, re);\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\"}],\"filter\\\\xsl.js\":[function(require,module,exports){\r\n/**\r\n * Filter for trimming \"select\" attributes from some tags that contains\r\n * child elements\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\r\n\tvar tags = {\r\n\t\t'xsl:variable': 1,\r\n\t\t'xsl:with-param': 1\r\n\t};\r\n\t\r\n\t/**\r\n\t * Removes \"select\" attribute from node\r\n\t * @param {AbbreviationNode} node\r\n\t */\r\n\tfunction trimAttribute(node) {\r\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\r\n\t}\r\n\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)\r\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \r\n\t\t\t\t\t&& item.children.length)\r\n\t\t\t\ttrimAttribute(item);\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\"}],\"generator\\\\lorem.js\":[function(require,module,exports){\r\n/**\r\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \r\n * <code>lorem(num)?</code> abbreviation.\r\n * This code is based on Django's contribution: \r\n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\r\n * <br><br>\r\n * Examples to test:<br>\r\n * <code>lipsum</code> – generates 30 words text.<br>\r\n * <code>lipsum*6</code> – generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\r\n * <code>ol>lipsum10*5</code> — generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\r\n * with text of 10 words on each line.<br>\r\n * <code>span*3>lipsum20</code> – generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element.\r\n * Each paragraph phrase is unique.   \r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\r\n\tvar langs = {\r\n\t\ten: {\r\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\r\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\r\n\t\t\t\t'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\r\n\t\t\t\t'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\r\n\t\t\t\t'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\r\n\t\t\t\t'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\r\n\t\t\t\t'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\r\n\t\t\t\t'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\r\n\t\t\t\t'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\r\n\t\t\t\t'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\r\n\t\t\t\t'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\r\n\t\t\t\t'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\r\n\t\t\t\t'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\r\n\t\t\t\t'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\r\n\t\t\t\t'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\r\n\t\t\t\t'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\r\n\t\t\t\t'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\r\n\t\t\t\t'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\r\n\t\t\t\t'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\r\n\t\t\t\t'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\r\n\t\t\t\t'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\r\n\t\t\t\t'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\r\n\t\t\t\t'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\r\n\t\t\t\t'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\r\n\t\t\t\t'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\r\n\t\t\t\t'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\r\n\t\t\t\t'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\r\n\t\t\t\t'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\r\n\t\t\t\t'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\r\n\t\t\t\t'maxime', 'corrupti']\r\n\t\t},\r\n\t\tsp: {\r\n\t\t\tcommon: ['mujer', 'uno', 'dolor', 'más', 'de', 'poder', 'mismo', 'si'],\r\n\t\t\twords: ['ejercicio', 'preferencia', 'perspicacia', 'laboral', 'paño',\r\n\t\t\t\t'suntuoso', 'molde', 'namibia', 'planeador', 'mirar', 'demás', 'oficinista', 'excepción',\r\n\t\t\t\t'odio', 'consecuencia', 'casi', 'auto', 'chicharra', 'velo', 'elixir',\r\n\t\t\t\t'ataque', 'no', 'odio', 'temporal', 'cuórum', 'dignísimo',\r\n\t\t\t\t'facilismo', 'letra', 'nihilista', 'expedición', 'alma', 'alveolar', 'aparte',\r\n\t\t\t\t'león', 'animal', 'como', 'paria', 'belleza', 'modo', 'natividad',\r\n\t\t\t\t'justo', 'ataque', 'séquito', 'pillo', 'sed', 'ex', 'y', 'voluminoso',\r\n\t\t\t\t'temporalidad', 'verdades', 'racional', 'asunción', 'incidente', 'marejada',\r\n\t\t\t\t'placenta', 'amanecer', 'fuga', 'previsor', 'presentación', 'lejos',\r\n\t\t\t\t'necesariamente', 'sospechoso', 'adiposidad', 'quindío', 'pócima',\r\n\t\t\t\t'voluble', 'débito', 'sintió', 'accesorio', 'falda', 'sapiencia',\r\n\t\t\t\t'volutas', 'queso', 'permacultura', 'laudo', 'soluciones', 'entero',\r\n\t\t\t\t'pan', 'litro', 'tonelada', 'culpa', 'libertario', 'mosca', 'dictado',\r\n\t\t\t\t'reincidente', 'nascimiento', 'dolor', 'escolar', 'impedimento', 'mínima',\r\n\t\t\t\t'mayores', 'repugnante', 'dulce', 'obcecado', 'montaña', 'enigma',\r\n\t\t\t\t'total', 'deletéreo', 'décima', 'cábala', 'fotografía', 'dolores',\r\n\t\t\t\t'molesto', 'olvido', 'paciencia', 'resiliencia', 'voluntad', 'molestias',\r\n\t\t\t\t'magnífico', 'distinción', 'ovni', 'marejada', 'cerro', 'torre', 'y',\r\n\t\t\t\t'abogada', 'manantial', 'corporal', 'agua', 'crepúsculo', 'ataque', 'desierto',\r\n\t\t\t\t'laboriosamente', 'angustia', 'afortunado', 'alma', 'encefalograma',\r\n\t\t\t\t'materialidad', 'cosas', 'o', 'renuncia', 'error', 'menos', 'conejo',\r\n\t\t\t\t'abadía', 'analfabeto', 'remo', 'fugacidad', 'oficio', 'en', 'almácigo', 'vos', 'pan',\r\n\t\t\t\t'represión', 'números', 'triste', 'refugiado', 'trote', 'inventor',\r\n\t\t\t\t'corchea', 'repelente', 'magma', 'recusado', 'patrón', 'explícito',\r\n\t\t\t\t'paloma', 'síndrome', 'inmune', 'autoinmune', 'comodidad',\r\n\t\t\t\t'ley', 'vietnamita', 'demonio', 'tasmania', 'repeler', 'apéndice',\r\n\t\t\t\t'arquitecto', 'columna', 'yugo', 'computador', 'mula', 'a', 'propósito',\r\n\t\t\t\t'fantasía', 'alias', 'rayo', 'tenedor', 'deleznable', 'ventana', 'cara',\r\n\t\t\t\t'anemia', 'corrupto']\r\n\t\t},\r\n\t\tru: {\r\n\t\t\tcommon: ['далеко-далеко', 'за', 'словесными', 'горами', 'в стране', 'гласных', 'и согласных', 'живут', 'рыбные', 'тексты'],\r\n\t\t\twords: ['вдали', 'от всех', 'они', 'буквенных', 'домах', 'на берегу', 'семантика', \r\n\t\t\t\t'большого', 'языкового', 'океана', 'маленький', 'ручеек', 'даль', \r\n\t\t\t\t'журчит', 'по всей', 'обеспечивает', 'ее','всеми', 'необходимыми', \r\n\t\t\t\t'правилами', 'эта', 'парадигматическая', 'страна', 'которой', 'жаренные', \r\n\t\t\t\t'предложения', 'залетают', 'прямо', 'рот', 'даже', 'всемогущая', \r\n\t\t\t\t'пунктуация', 'не', 'имеет', 'власти', 'над', 'рыбными', 'текстами', \r\n\t\t\t\t'ведущими', 'безорфографичный', 'образ', 'жизни', 'однажды', 'одна', \r\n\t\t\t\t'маленькая', 'строчка','рыбного', 'текста', 'имени', 'lorem', 'ipsum', \r\n\t\t\t\t'решила', 'выйти', 'большой', 'мир', 'грамматики', 'великий', 'оксмокс', \r\n\t\t\t\t'предупреждал', 'о', 'злых', 'запятых', 'диких', 'знаках', 'вопроса', \r\n\t\t\t\t'коварных', 'точках', 'запятой', 'но', 'текст', 'дал', 'сбить', \r\n\t\t\t\t'себя', 'толку', 'он', 'собрал', 'семь', 'своих', 'заглавных', 'букв', \r\n\t\t\t\t'подпоясал', 'инициал', 'за', 'пояс', 'пустился', 'дорогу', \r\n\t\t\t\t'взобравшись', 'первую', 'вершину', 'курсивных', 'гор', 'бросил', \r\n\t\t\t\t'последний', 'взгляд', 'назад', 'силуэт', 'своего', 'родного', 'города', \r\n\t\t\t\t'буквоград', 'заголовок', 'деревни', 'алфавит', 'подзаголовок', 'своего', \r\n\t\t\t\t'переулка', 'грустный', 'реторический', 'вопрос', 'скатился', 'его', \r\n\t\t\t\t'щеке', 'продолжил', 'свой', 'путь', 'дороге', 'встретил', 'рукопись', \r\n\t\t\t\t'она', 'предупредила',  'моей', 'все', 'переписывается', 'несколько', \r\n\t\t\t\t'раз', 'единственное', 'что', 'меня', 'осталось', 'это', 'приставка', \r\n\t\t\t\t'возвращайся', 'ты', 'лучше', 'свою', 'безопасную', 'страну', 'послушавшись', \r\n\t\t\t\t'рукописи', 'наш', 'продолжил', 'свой', 'путь', 'вскоре', 'ему', \r\n\t\t\t\t'повстречался', 'коварный', 'составитель', 'рекламных', 'текстов', \r\n\t\t\t\t'напоивший', 'языком', 'речью', 'заманивший', 'свое', 'агентство', \r\n\t\t\t\t'которое', 'использовало', 'снова', 'снова', 'своих', 'проектах', \r\n\t\t\t\t'если', 'переписали', 'то', 'живет', 'там', 'до', 'сих', 'пор']\r\n\t\t}\r\n\t};\r\n\r\n\t\r\n\tprefs.define('lorem.defaultLang', 'en', \r\n\t\t'Default language of generated dummy text. Currently, <code>en</code>\\\r\n\t\tand <code>ru</code> are supported, but users can add their own syntaxes\\\r\n\t\tsee <a href=\"http://docs.emmet.io/abbreviations/lorem-ipsum/\">docs</a>.');\r\n\tprefs.define('lorem.omitCommonPart', false,\r\n\t\t'Omit commonly used part (e.g. “Lorem ipsum dolor sit amet“) from generated text.');\r\n\t\r\n\t/**\r\n\t * Returns random integer between <code>from</code> and <code>to</code> values\r\n\t * @param {Number} from\r\n\t * @param {Number} to\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction randint(from, to) {\r\n\t\treturn Math.round(Math.random() * (to - from) + from);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param {Array} arr\r\n\t * @param {Number} count\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction sample(arr, count) {\r\n\t\tvar len = arr.length;\r\n\t\tvar iterations = Math.min(len, count);\r\n\t\tvar result = [];\r\n\t\twhile (result.length < iterations) {\r\n\t\t\tvar randIx = randint(0, len - 1);\r\n\t\t\tif (!~result.indexOf(randIx)) {\r\n\t\t\t\tresult.push(randIx);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result.map(function(ix) {\r\n\t\t\treturn arr[ix];\r\n\t\t});\r\n\t}\r\n\t\r\n\tfunction choice(val) {\r\n\t\tif (typeof val === 'string')\r\n\t\t\treturn val.charAt(randint(0, val.length - 1));\r\n\t\t\r\n\t\treturn val[randint(0, val.length - 1)];\r\n\t}\r\n\t\r\n\tfunction sentence(words, end) {\r\n\t\tif (words.length) {\r\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\r\n\t\t}\r\n\t\t\r\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\r\n\t}\r\n\t\r\n\t/**\r\n\t * Insert commas at randomly selected words. This function modifies values\r\n\t * inside <code>words</code> array \r\n\t * @param {Array} words\r\n\t */\r\n\tfunction insertCommas(words) {\r\n\t\tvar len = words.length;\r\n\r\n\t\tif (len < 2) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar totalCommas = 0;\r\n\t\tif (len > 3 && len <= 6) {\r\n\t\t\ttotalCommas = randint(0, 1);\r\n\t\t} else if (len > 6 && len <= 12) {\r\n\t\t\ttotalCommas = randint(0, 2);\r\n\t\t} else {\r\n\t\t\ttotalCommas = randint(1, 4);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, pos, word; i < totalCommas; i++) {\r\n\t\t\tpos = randint(0, words.length - 2);\r\n\t\t\tword = words[pos];\r\n\t\t\tif (word.charAt(word.length - 1) !== ',') {\r\n\t\t\t\twords[pos] += ',';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Generate a paragraph of \"Lorem ipsum\" text\r\n\t * @param {Number} wordCount Words count in paragraph\r\n\t * @param {Boolean} startWithCommon Should paragraph start with common \r\n\t * \"lorem ipsum\" sentence.\r\n\t * @returns {String}\r\n\t */\r\n\tfunction paragraph(lang, wordCount, startWithCommon) {\r\n\t\tvar data = langs[lang];\r\n\t\tif (!data) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tvar result = [];\r\n\t\tvar totalWords = 0;\r\n\t\tvar words;\r\n\t\t\r\n\t\twordCount = parseInt(wordCount, 10);\r\n\t\t\r\n\t\tif (startWithCommon && data.common) {\r\n\t\t\twords = data.common.slice(0, wordCount);\r\n\t\t\tif (words.length > 5) {\r\n\t\t\t\twords[4] += ',';\r\n\t\t\t}\r\n\t\t\ttotalWords += words.length;\r\n\t\t\tresult.push(sentence(words, '.'));\r\n\t\t}\r\n\t\t\r\n\t\twhile (totalWords < wordCount) {\r\n\t\t\twords = sample(data.words, Math.min(randint(2, 30), wordCount - totalWords));\r\n\t\t\ttotalWords += words.length;\r\n\t\t\tinsertCommas(words);\r\n\t\t\tresult.push(sentence(words));\r\n\t\t}\r\n\t\t\r\n\t\treturn result.join(' ');\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Adds new language words for Lorem Ipsum generator\r\n\t\t * @param {String} lang Two-letter lang definition\r\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \r\n\t\t * list of words (String), Array of words or object with <code>text</code> and\r\n\t\t * <code>common</code> properties\r\n\t\t */\r\n\t\taddLang: function(lang, data) {\r\n\t\t\tif (typeof data === 'string') {\r\n\t\t\t\tdata = {\r\n\t\t\t\t\twords: data.split(' ').filter(function(item) {\r\n\t\t\t\t\t\treturn !!item;\r\n\t\t\t\t\t})\r\n\t\t\t\t};\r\n\t\t\t} else if (Array.isArray(data)) {\r\n\t\t\t\tdata = {words: data};\r\n\t\t\t}\r\n\r\n\t\t\tlangs[lang] = data;\r\n\t\t},\r\n\t\tpreprocessor: function(tree) {\r\n\t\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\r\n\t\t\tvar allowCommon = !prefs.get('lorem.omitCommonPart');\r\n\t\t\t\r\n\t\t\t/** @param {AbbreviationNode} node */\r\n\t\t\ttree.findAll(function(node) {\r\n\t\t\t\tif (node._name && (match = node._name.match(re))) {\r\n\t\t\t\t\tvar wordCound = match[2] || 30;\r\n\t\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\r\n\t\t\t\t\t\r\n\t\t\t\t\t// force node name resolving if node should be repeated\r\n\t\t\t\t\t// or contains attributes. In this case, node should be outputed\r\n\t\t\t\t\t// as tag, otherwise as text-only node\r\n\t\t\t\t\tnode._name = '';\r\n\t\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\r\n\t\t\t\t\tnode.data('pasteOverwrites', true);\r\n\t\t\t\t\tnode.data('paste', function(i) {\r\n\t\t\t\t\t\treturn paragraph(lang, wordCound, !i && allowCommon);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\"}],\"parser\\\\abbreviation.js\":[function(require,module,exports){\r\n/**\r\n * Emmet abbreviation parser.\r\n * Takes string abbreviation and recursively parses it into a tree. The parsed \r\n * tree can be transformed into a string representation with \r\n * <code>toString()</code> method. Note that string representation is defined\r\n * by custom processors (called <i>filters</i>), not by abbreviation parser \r\n * itself.\r\n * \r\n * This module can be extended with custom pre-/post-processors to shape-up\r\n * final tree or its representation. Actually, many features of abbreviation \r\n * engine are defined in other modules as tree processors\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar profile = require('../assets/profile');\r\n\tvar filters = require('../filter/main');\r\n\tvar utils = require('../utils/common');\r\n\tvar abbreviationUtils = require('../utils/abbreviation');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\r\n\t// pre- and post-processorcs\r\n\tvar lorem = require('../generator/lorem');\r\n\tvar procPastedContent = require('./processor/pastedContent');\r\n\tvar procTagName = require('./processor/tagName');\r\n\tvar procResourceMatcher = require('./processor/resourceMatcher');\r\n\tvar procAttributes = require('./processor/attributes');\r\n\tvar procHref = require('./processor/href');\r\n\r\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\r\n\tvar reWord = /[\\w\\-:\\$@]/;\r\n\tvar DEFAULT_ATTR_NAME = '%default';\r\n\t\r\n\tvar pairs = {\r\n\t\t'[': ']',\r\n\t\t'(': ')',\r\n\t\t'{': '}'\r\n\t};\r\n\t\r\n\tvar spliceFn = Array.prototype.splice;\r\n\t\r\n\tvar preprocessors = [];\r\n\tvar postprocessors = [];\r\n\tvar outputProcessors = [];\r\n\t\r\n\t/**\r\n\t * @type AbbreviationNode\r\n\t */\r\n\tfunction AbbreviationNode(parent) {\r\n\t\t/** @type AbbreviationNode */\r\n\t\tthis.parent = null;\r\n\t\tthis.children = [];\r\n\t\tthis._attributes = [];\r\n\t\t\r\n\t\t/** @type String Raw abbreviation for current node */\r\n\t\tthis.abbreviation = '';\r\n\t\tthis.counter = 1;\r\n\t\tthis._name = null;\r\n\t\tthis._text = '';\r\n\t\tthis.repeatCount = 1;\r\n\t\tthis.hasImplicitRepeat = false;\r\n\t\t\r\n\t\t/** Custom data dictionary */\r\n\t\tthis._data = {};\r\n\t\t\r\n\t\t// output properties\r\n\t\tthis.start = '';\r\n\t\tthis.end = '';\r\n\t\tthis.content = '';\r\n\t\tthis.padding = '';\r\n\t}\r\n\t\r\n\tAbbreviationNode.prototype = {\r\n\t\t/**\r\n\t\t * Adds passed node as child or creates new child\r\n\t\t * @param {AbbreviationNode} child\r\n\t\t * @param {Number} position Index in children array where child should \r\n\t\t * be inserted\r\n\t\t * @return {AbbreviationNode}\r\n\t\t */\r\n\t\taddChild: function(child, position) {\r\n\t\t\tchild = child || new AbbreviationNode();\r\n\t\t\tchild.parent = this;\r\n\t\t\t\r\n\t\t\tif (typeof position === 'undefined') {\r\n\t\t\t\tthis.children.push(child);\r\n\t\t\t} else {\r\n\t\t\t\tthis.children.splice(position, 0, child);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn child;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates a deep copy of current node\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tclone: function() {\r\n\t\t\tvar node = new AbbreviationNode();\r\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\r\n\t\t\tattrs.forEach(function(a) {\r\n\t\t\t\tnode[a] = this[a];\r\n\t\t\t}, this);\r\n\t\t\t\r\n\t\t\t// clone attributes\r\n\t\t\tnode._attributes = this._attributes.map(function(attr) {\r\n\t\t\t\treturn utils.extend({}, attr);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tnode._data = utils.extend({}, this._data);\r\n\t\t\t\r\n\t\t\t// clone children\r\n\t\t\tnode.children = this.children.map(function(child) {\r\n\t\t\t\tchild = child.clone();\r\n\t\t\t\tchild.parent = node;\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn node;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes current node from parent‘s child list\r\n\t\t * @returns {AbbreviationNode} Current node itself\r\n\t\t */\r\n\t\tremove: function() {\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tvar ix = this.parent.children.indexOf(this);\r\n\t\t\t\tif (~ix) {\r\n\t\t\t\t\tthis.parent.children.splice(ix, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replaces current node in parent‘s children list with passed nodes\r\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\r\n\t\t */\r\n\t\treplace: function() {\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tvar ix = parent.children.indexOf(this);\r\n\t\t\tvar items = utils.flatten(arguments);\r\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\r\n\t\t\t\r\n\t\t\t// update parent\r\n\t\t\titems.forEach(function(item) {\r\n\t\t\t\titem.parent = parent;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\r\n\t\t * node and its children \r\n\t\t * @param {String} name Property to update\r\n\t\t * @param {Object} value New property value\r\n\t\t */\r\n\t\tupdateProperty: function(name, value) {\r\n\t\t\tthis[name] = value;\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tchild.updateProperty(name, value);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds first child node that matches truth test for passed \r\n\t\t * <code>fn</code> function\r\n\t\t * @param {Function} fn\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tfind: function(fn) {\r\n\t\t\treturn this.findAll(fn, {amount: 1})[0];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds all child nodes that matches truth test for passed \r\n\t\t * <code>fn</code> function\r\n\t\t * @param {Function} fn\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tfindAll: function(fn, state) {\r\n\t\t\tstate = utils.extend({amount: 0, found: 0}, state || {});\r\n\r\n\t\t\tif (typeof fn !== 'function') {\r\n\t\t\t\tvar elemName = fn.toLowerCase();\r\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tvar result = [];\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tif (fn(child)) {\r\n\t\t\t\t\tresult.push(child);\r\n\t\t\t\t\tstate.found++;\r\n\t\t\t\t\tif (state.amount && state.found >= state.amount) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresult = result.concat(child.findAll(fn));\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result.filter(function(item) {\r\n\t\t\t\treturn !!item;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets/gets custom data\r\n\t\t * @param {String} name\r\n\t\t * @param {Object} value\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tdata: function(name, value) {\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tthis._data[name] = value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._data[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns name of current node\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tname: function() {\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns list of attributes for current node\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tattributeList: function() {\r\n\t\t\treturn optimizeAttributes(this._attributes.slice(0));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns or sets attribute value\r\n\t\t * @param {String} name Attribute name\r\n\t\t * @param {String} value New attribute value. `Null` value \r\n\t\t * will remove attribute\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tattribute: function(name, value) {\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tif (value === null) {\r\n\t\t\t\t\t// remove attribute\r\n\t\t\t\t\tvar vals = this._attributes.filter(function(attr) {\r\n\t\t\t\t\t\treturn attr.name === name;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tvar that = this;\r\n\t\t\t\t\tvals.forEach(function(attr) {\r\n\t\t\t\t\t\tvar ix = that._attributes.indexOf(attr);\r\n\t\t\t\t\t\tif (~ix) {\r\n\t\t\t\t\t\t\tthat._attributes.splice(ix, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// modify attribute\r\n\t\t\t\tvar attrNames = this._attributes.map(function(attr) {\r\n\t\t\t\t\treturn attr.name;\r\n\t\t\t\t});\r\n\t\t\t\tvar ix = attrNames.indexOf(name.toLowerCase());\r\n\t\t\t\tif (~ix) {\r\n\t\t\t\t\tthis._attributes[ix].value = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._attributes.push({\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn (utils.find(this.attributeList(), function(attr) {\r\n\t\t\t\treturn attr.name == name;\r\n\t\t\t}) || {}).value;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns index of current node in parent‘s children list\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tindex: function() {\r\n\t\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets how many times current element should be repeated\r\n\t\t * @private\r\n\t\t */\r\n\t\t_setRepeat: function(count) {\r\n\t\t\tif (count) {\r\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\r\n\t\t\t} else {\r\n\t\t\t\tthis.hasImplicitRepeat = true;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets abbreviation that belongs to current node\r\n\t\t * @param {String} abbr\r\n\t\t */\r\n\t\tsetAbbreviation: function(abbr) {\r\n\t\t\tabbr = abbr || '';\r\n\t\t\t\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\t// find multiplier\r\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\r\n\t\t\t\tthat._setRepeat(repeatCount);\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tthis.abbreviation = abbr;\r\n\t\t\t\r\n\t\t\tvar abbrText = extractText(abbr);\r\n\t\t\tif (abbrText) {\r\n\t\t\t\tabbr = abbrText.element;\r\n\t\t\t\tthis.content = this._text = abbrText.text;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\r\n\t\t\tif (abbrAttrs) {\r\n\t\t\t\tabbr = abbrAttrs.element;\r\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._name = abbr;\r\n\t\t\t\r\n\t\t\t// validate name\r\n\t\t\tif (this._name && !reValidName.test(this._name)) {\r\n\t\t\t\tthrow new Error('Invalid abbreviation');\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns string representation of current node\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tvalueOf: function() {\r\n\t\t\tvar start = this.start;\r\n\t\t\tvar end = this.end;\r\n\t\t\tvar content = this.content;\r\n\t\t\t\r\n\t\t\t// apply output processors\r\n\t\t\tvar node = this;\r\n\t\t\toutputProcessors.forEach(function(fn) {\r\n\t\t\t\tstart = fn(start, node, 'start');\r\n\t\t\t\tcontent = fn(content, node, 'content');\r\n\t\t\t\tend = fn(end, node, 'end');\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tvar innerContent = this.children.map(function(child) {\r\n\t\t\t\treturn child.valueOf();\r\n\t\t\t}).join('');\r\n\t\t\t\r\n\t\t\tcontent = abbreviationUtils.insertChildContent(content, innerContent, {\r\n\t\t\t\tkeepVariable: false\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn start + utils.padString(content, this.padding) + end;\r\n\t\t},\r\n\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current node contains children with empty <code>expr</code>\r\n\t\t * property\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\thasEmptyChildren: function() {\r\n\t\t\treturn !!utils.find(this.children, function(child) {\r\n\t\t\t\treturn child.isEmpty();\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current node has implied name that should be resolved\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\thasImplicitName: function() {\r\n\t\t\treturn !this._name && !this.isTextNode();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates that current element is a grouping one, e.g. has no \r\n\t\t * representation but serves as a container for other nodes\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisGroup: function() {\r\n\t\t\treturn !this.abbreviation;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \r\n\t\t * grouping node and should not be outputted\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisEmpty: function() {\r\n\t\t\treturn !this.abbreviation && !this.children.length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates that current node should be repeated\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisRepeating: function() {\r\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current node is a text-only node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisTextNode: function() {\r\n\t\t\treturn !this.name() && !this.attributeList().length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates whether this node may be used to build elements or snippets\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisElement: function() {\r\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns latest and deepest child of current tree\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tdeepestChild: function() {\r\n\t\t\tif (!this.children.length)\r\n\t\t\t\treturn null;\r\n\t\t\t\t\r\n\t\t\tvar deepestChild = this;\r\n\t\t\twhile (deepestChild.children.length) {\r\n\t\t\t\tdeepestChild = deepestChild.children[deepestChild.children.length - 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn deepestChild;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Returns stripped string: a string without first and last character.\r\n\t * Used for “unquoting” strings\r\n\t * @param {String} str\r\n\t * @returns {String}\r\n\t */\r\n\tfunction stripped(str) {\r\n\t\treturn str.substring(1, str.length - 1);\r\n\t}\r\n\t\r\n\tfunction consumeQuotedValue(stream, quote) {\r\n\t\tvar ch;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (ch === quote)\r\n\t\t\t\treturn true;\r\n\t\t\t\r\n\t\t\tif (ch == '\\\\')\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parses abbreviation into a tree\r\n\t * @param {String} abbr\r\n\t * @returns {AbbreviationNode}\r\n\t */\r\n\tfunction parseAbbreviation(abbr) {\r\n\t\tabbr = utils.trim(abbr);\r\n\t\t\r\n\t\tvar root = new AbbreviationNode();\r\n\t\tvar context = root.addChild(), ch;\r\n\t\t\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(abbr);\r\n\t\tvar loopProtector = 1000, multiplier;\r\n\t\tvar addChild = function(child) {\r\n\t\t\tcontext.addChild(child);\r\n\t\t};\r\n\r\n\t\tvar consumeAbbr = function() {\r\n\t\t\tstream.start = stream.pos;\r\n\t\t\tstream.eatWhile(function(c) {\r\n\t\t\t\tif (c == '[' || c == '{') {\r\n\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\r\n\t\t\t\t\t\tstream.backUp(1);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tthrow new Error('Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (c == '+') {\r\n\t\t\t\t\t// let's see if this is an expando marker\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\r\n\t\t\t\t\tstream.backUp(1);\r\n\t\t\t\t\treturn isMarker;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn c != '(' && isAllowedChar(c);\r\n\t\t\t});\r\n\t\t};\r\n\t\t\r\n\t\twhile (!stream.eol() && --loopProtector > 0) {\r\n\t\t\tch = stream.peek();\r\n\t\t\t\r\n\t\t\tswitch (ch) {\r\n\t\t\t\tcase '(': // abbreviation group\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\r\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\r\n\t\t\t\t\t\tif ((multiplier = stream.match(/^\\*(\\d+)?/, true))) {\r\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tinner.children.forEach(addChild);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '>': // child operator\r\n\t\t\t\t\tcontext = context.addChild();\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '+': // sibling operator\r\n\t\t\t\t\tcontext = context.parent.addChild();\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '^': // climb up operator\r\n\t\t\t\t\tvar parent = context.parent || context;\r\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tdefault: // consume abbreviation\r\n\t\t\t\t\tconsumeAbbr();\r\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (loopProtector < 1) {\r\n\t\t\tthrow new Error('Endless loop detected');\r\n\t\t}\r\n\t\t\r\n\t\treturn root;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits attribute set into a list of attributes string\r\n\t * @param  {String} attrSet \r\n\t * @return {Array}\r\n\t */\r\n\tfunction splitAttributes(attrSet) {\r\n\t\tattrSet = utils.trim(attrSet);\r\n\t\tvar parts = [];\r\n\r\n\t\t// split attribute set by spaces\r\n\t\tvar stream = stringStream(attrSet), ch;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (ch == ' ') {\r\n\t\t\t\tparts.push(utils.trim(stream.current()));\r\n\t\t\t\t// skip spaces\r\n\t\t\t\twhile (stream.peek() == ' ') {\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t} else if (ch == '\"' || ch == \"'\") {\r\n\t\t\t\t// skip values in strings\r\n\t\t\t\tif (!stream.skipString(ch)) {\r\n\t\t\t\t\tthrow new Error('Invalid attribute set');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tparts.push(utils.trim(stream.current()));\r\n\t\treturn parts;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes opening and closing quotes from given string\r\n\t * @param  {String} str\r\n\t * @return {String}\r\n\t */\r\n\tfunction unquote(str) {\r\n\t\tvar ch = str.charAt(0);\r\n\t\tif (ch == '\"' || ch == \"'\") {\r\n\t\t\tstr = str.substr(1);\r\n\t\t\tvar last = str.charAt(str.length - 1);\r\n\t\t\tif (last === ch) {\r\n\t\t\t\tstr = str.substr(0, str.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t}\r\n\r\n\t/**\r\n\t * Extract attributes and their values from attribute set: \r\n\t * <code>[attr col=3 title=\"Quoted string\"]</code> (without square braces)\r\n\t * @param {String} attrSet\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction extractAttributes(attrSet) {\r\n\t\tvar reAttrName = /^[\\w\\-:\\$@]+\\.?$/;\r\n\t\treturn splitAttributes(attrSet).map(function(attr) {\r\n\t\t\t// attribute name: [attr]\r\n\t\t\tif (reAttrName.test(attr)) {\r\n\t\t\t\tvar value = '';\r\n\t\t\t\tif (attr.charAt(attr.length - 1) == '.') {\r\n\t\t\t\t\t// a boolean attribute\r\n\t\t\t\t\tattr = attr.substr(0, attr.length - 1);\r\n\t\t\t\t\tvalue = attr;\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: attr,\r\n\t\t\t\t\tvalue: value\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// attribute with value: [name=val], [name=\"val\"]\r\n\t\t\tif (~attr.indexOf('=')) {\r\n\t\t\t\tvar parts = attr.split('=');\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: parts.shift(),\r\n\t\t\t\t\tvalue: unquote(parts.join('='))\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// looks like it’s implied attribute\r\n\t\t\treturn {\r\n\t\t\t\tname: DEFAULT_ATTR_NAME,\r\n\t\t\t\tvalue: unquote(attr)\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \r\n\t * returns object with <code>element</code> and <code>attributes</code>\r\n\t * properties\r\n\t * @param {String} abbr\r\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \r\n\t * abbreviation\r\n\t */\r\n\tfunction parseAttributes(abbr) {\r\n\t\t/*\r\n\t\t * Example of incoming data:\r\n\t\t * #header\r\n\t\t * .some.data\r\n\t\t * .some.data#header\r\n\t\t * [attr]\r\n\t\t * #item[attr=Hello other=\"World\"].class\r\n\t\t */\r\n\t\tvar result = [];\r\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\r\n\t\tvar nameEnd = null;\r\n\t\t\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(abbr);\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tswitch (stream.peek()) {\r\n\t\t\t\tcase '#': // id\r\n\t\t\t\tcase '.': // class\r\n\t\t\t\t\tif (nameEnd === null)\r\n\t\t\t\t\t\tnameEnd = stream.pos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\r\n\t\t\t\t\t\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tstream.eatWhile(reWord);\r\n\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\tname: attrName, \r\n\t\t\t\t\t\tvalue: stream.current()\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '[': //begin attribute set\r\n\t\t\t\t\tif (nameEnd === null)\r\n\t\t\t\t\t\tnameEnd = stream.pos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) {\r\n\t\t\t\t\t\tthrow new Error('Invalid attribute set definition');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = result.concat(\r\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstream.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (!result.length)\r\n\t\t\treturn null;\r\n\t\t\r\n\t\treturn {\r\n\t\t\telement: abbr.substring(0, nameEnd),\r\n\t\t\tattributes: optimizeAttributes(result)\r\n\t\t};\r\n\t}\r\n\t\r\n\t/**\r\n\t * Optimize attribute set: remove duplicates and merge class attributes\r\n\t * @param attrs\r\n\t */\r\n\tfunction optimizeAttributes(attrs) {\r\n\t\t// clone all attributes to make sure that original objects are \r\n\t\t// not modified\r\n\t\tattrs = attrs.map(function(attr) {\r\n\t\t\treturn utils.clone(attr);\r\n\t\t});\r\n\t\t\r\n\t\tvar lookup = {};\r\n\r\n\t\treturn attrs.filter(function(attr) {\r\n\t\t\tif (!(attr.name in lookup)) {\r\n\t\t\t\treturn lookup[attr.name] = attr;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar la = lookup[attr.name];\r\n\t\t\t\r\n\t\t\tif (attr.name.toLowerCase() == 'class') {\r\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\r\n\t\t\t} else {\r\n\t\t\t\tla.value = attr.value;\r\n\t\t\t\tla.isImplied = !!attr.isImplied;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\r\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\r\n\t * If nothing found, returns <code>null</code>\r\n\t * @param {String} abbr\r\n\t * \r\n\t */\r\n\tfunction extractText(abbr) {\r\n\t\tif (!~abbr.indexOf('{'))\r\n\t\t\treturn null;\r\n\t\t\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(abbr);\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tswitch (stream.peek()) {\r\n\t\t\t\tcase '[':\r\n\t\t\t\tcase '(':\r\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '{':\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tstream.skipToPair('{', '}');\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\r\n\t\t\t\t\t\ttext: stripped(stream.current())\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstream.next();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * “Un-rolls“ contents of current node: recursively replaces all repeating \r\n\t * children with their repeated clones\r\n\t * @param {AbbreviationNode} node\r\n\t * @returns {AbbreviationNode}\r\n\t */\r\n\tfunction unroll(node) {\r\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\r\n\t\t\tchild = node.children[i];\r\n\t\t\t\r\n\t\t\tif (child.isRepeating()) {\r\n\t\t\t\tmaxCount = j = child.repeatCount;\r\n\t\t\t\tchild.repeatCount = 1;\r\n\t\t\t\tchild.updateProperty('counter', 1);\r\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\r\n\t\t\t\twhile (--j > 0) {\r\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\r\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\r\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// to keep proper 'counter' property, we need to walk\r\n\t\t// on children once again\r\n\t\tnode.children.forEach(unroll);\r\n\t\t\r\n\t\treturn node;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Optimizes tree node: replaces empty nodes with their children\r\n\t * @param {AbbreviationNode} node\r\n\t * @return {AbbreviationNode}\r\n\t */\r\n\tfunction squash(node) {\r\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\r\n\t\t\t/** @type AbbreviationNode */\r\n\t\t\tvar n = node.children[i];\r\n\t\t\tif (n.isGroup()) {\r\n\t\t\t\tn.replace(squash(n).children);\r\n\t\t\t} else if (n.isEmpty()) {\r\n\t\t\t\tn.remove();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tnode.children.forEach(squash);\r\n\t\t\r\n\t\treturn node;\r\n\t}\r\n\t\r\n\tfunction isAllowedChar(ch) {\r\n\t\tvar charCode = ch.charCodeAt(0);\r\n\t\tvar specialChars = '#.*:$-_!@|%';\r\n\t\t\r\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\r\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\r\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\r\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\r\n\t}\r\n\r\n\t// XXX add counter replacer function as output processor\r\n\toutputProcessors.push(function(text, node) {\r\n\t\treturn utils.replaceCounter(text, node.counter, node.maxCount);\r\n\t});\r\n\r\n\t// XXX add tabstop updater\r\n\toutputProcessors.push(tabStops.abbrOutputProcessor.bind(tabStops));\r\n\r\n\t// include default pre- and postprocessors\r\n\t[lorem, procResourceMatcher, procAttributes, procPastedContent, procTagName, procHref].forEach(function(mod) {\r\n\t\tif (mod.preprocessor) {\r\n\t\t\tpreprocessors.push(mod.preprocessor.bind(mod));\r\n\t\t}\r\n\r\n\t\tif (mod.postprocessor) {\r\n\t\t\tpostprocessors.push(mod.postprocessor.bind(mod));\r\n\t\t}\r\n\t});\r\n\r\n\treturn {\r\n\t\tDEFAULT_ATTR_NAME: DEFAULT_ATTR_NAME,\r\n\r\n\t\t/**\r\n\t\t * Parses abbreviation into tree with respect of groups, \r\n\t\t * text nodes and attributes. Each node of the tree is a single \r\n\t\t * abbreviation. Tree represents actual structure of the outputted \r\n\t\t * result\r\n\t\t * @memberOf abbreviationParser\r\n\t\t * @param {String} abbr Abbreviation to parse\r\n\t\t * @param {Object} options Additional options for parser and processors\r\n\t\t * \r\n\t\t * @return {AbbreviationNode}\r\n\t\t */\r\n\t\tparse: function(abbr, options) {\r\n\t\t\toptions = options || {};\r\n\t\t\t\r\n\t\t\tvar tree = parseAbbreviation(abbr);\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\tif (options.contextNode) {\r\n\t\t\t\t// add info about context node –\r\n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \r\n\t\t\t\t// expanded\r\n\t\t\t\ttree._name = options.contextNode.name;\r\n\t\t\t\tvar attrLookup = {};\r\n\t\t\t\ttree._attributes.forEach(function(attr) {\r\n\t\t\t\t\tattrLookup[attr.name] = attr;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\toptions.contextNode.attributes.forEach(function(attr) {\r\n\t\t\t\t\tif (attr.name in attrLookup) {\r\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tattr = utils.clone(attr);\r\n\t\t\t\t\t\ttree._attributes.push(attr);\r\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// apply preprocessors\r\n\t\t\tpreprocessors.forEach(function(fn) {\r\n\t\t\t\tfn(tree, options, that);\r\n\t\t\t});\r\n\r\n\t\t\tif ('counter' in options) {\r\n\t\t\t\ttree.updateProperty('counter', options.counter);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttree = squash(unroll(tree));\r\n\t\t\t\r\n\t\t\t// apply postprocessors\r\n\t\t\tpostprocessors.forEach(function(fn) {\r\n\t\t\t\tfn(tree, options, that);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn tree;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Expands given abbreviation into a formatted code structure.\r\n\t\t * This is the main method that is used for expanding abbreviation\r\n\t\t * @param {String} abbr Abbreviation to expand\r\n\t\t * @param {Options} options Additional options for abbreviation\r\n\t\t * expanding and transformation: `syntax`, `profile`, `contextNode` etc.\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\texpand: function(abbr, options) {\r\n\t\t\tif (!abbr) return '';\r\n\t\t\tif (typeof options == 'string') {\r\n\t\t\t\tthrow new Error('Deprecated use of `expand` method: `options` must be object');\r\n\t\t\t}\r\n\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\tif (!options.syntax) {\r\n\t\t\t\toptions.syntax = utils.defaultSyntax();\r\n\t\t\t}\r\n\r\n\t\t\tvar p = profile.get(options.profile, options.syntax);\r\n\t\t\ttabStops.resetTabstopIndex();\r\n\t\t\t\r\n\t\t\tvar data = filters.extract(abbr);\r\n\t\t\tvar outputTree = this.parse(data[0], options);\r\n\r\n\t\t\tvar filtersList = filters.composeList(options.syntax, p, data[1]);\r\n\t\t\tfilters.apply(outputTree, filtersList, p);\r\n\r\n\t\t\treturn outputTree.valueOf();\r\n\t\t},\r\n\t\t\r\n\t\tAbbreviationNode: AbbreviationNode,\r\n\t\t\r\n\t\t/**\r\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\r\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\r\n\t\t * The passed tree is in unoptimized state.\r\n\t\t * @param {Function} fn Preprocessor function. This function receives\r\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\r\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\r\n\t\t * method\r\n\t\t */\r\n\t\taddPreprocessor: function(fn) {\r\n\t\t\tif (!~preprocessors.indexOf(fn)) {\r\n\t\t\t\tpreprocessors.push(fn);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered preprocessor\r\n\t\t */\r\n\t\tremoveFilter: function(fn) {\r\n\t\t\tvar ix = preprocessors.indexOf(fn);\r\n\t\t\tif (~ix) {\r\n\t\t\t\tpreprocessors.splice(ix, 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \r\n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\r\n\t\t * right before it returns from <code>parse()</code> method\r\n\t\t * @param {Function} fn Postprocessor function. This function receives\r\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\r\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\r\n\t\t * method\r\n\t\t */\r\n\t\taddPostprocessor: function(fn) {\r\n\t\t\tif (!~postprocessors.indexOf(fn)) {\r\n\t\t\t\tpostprocessors.push(fn);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered postprocessor function\r\n\t\t */\r\n\t\tremovePostprocessor: function(fn) {\r\n\t\t\tvar ix = postprocessors.indexOf(fn);\r\n\t\t\tif (~ix) {\r\n\t\t\t\tpostprocessors.splice(ix, 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \r\n\t\t * function that applies to output part (<code>start</code>, \r\n\t\t * <code>end</code> and <code>content</code>) when \r\n\t\t * <code>AbbreviationNode.toString()</code> method is called\r\n\t\t */\r\n\t\taddOutputProcessor: function(fn) {\r\n\t\t\tif (!~outputProcessors.indexOf(fn)) {\r\n\t\t\t\toutputProcessors.push(fn);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered output processor\r\n\t\t */\r\n\t\tremoveOutputProcessor: function(fn) {\r\n\t\t\tvar ix = outputProcessors.indexOf(fn);\r\n\t\t\tif (~ix) {\r\n\t\t\t\toutputProcessors.splice(ix, 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\r\n\t\t * @param {String} ch\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisAllowedChar: function(ch) {\r\n\t\t\tch = String(ch); // convert Java object to JS\r\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../filter/main\":\"filter\\\\main.js\",\"../generator/lorem\":\"generator\\\\lorem.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./processor/attributes\":\"parser\\\\processor\\\\attributes.js\",\"./processor/href\":\"parser\\\\processor\\\\href.js\",\"./processor/pastedContent\":\"parser\\\\processor\\\\pastedContent.js\",\"./processor/resourceMatcher\":\"parser\\\\processor\\\\resourceMatcher.js\",\"./processor/tagName\":\"parser\\\\processor\\\\tagName.js\"}],\"parser\\\\css.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar session = {tokens: null};\r\n\t\r\n\t// walks around the source\r\n\tvar walker = {\r\n\t\tinit: function (source) {\r\n\t\t\t// this.source = source.replace(/\\r\\n?/g, '\\n');\r\n\t\t\tthis.source = source;\r\n\t\t\tthis.ch = '';\r\n\t\t\tthis.chnum = -1;\r\n\t\t\r\n\t\t\t// advance\r\n\t\t\tthis.nextChar();\r\n\t\t},\r\n\t\tnextChar: function () {\r\n\t\t\treturn this.ch = this.source.charAt(++this.chnum);\r\n\t\t},\r\n\t\tpeek: function() {\r\n\t\t\treturn this.source.charAt(this.chnum + 1);\r\n\t\t}\r\n\t};\r\n\r\n\t// utility helpers\r\n\tfunction isNameChar(c, cc) {\r\n\t\tcc = cc || c.charCodeAt(0);\r\n\t\treturn (\r\n\t\t\t(cc >= 97 && cc <= 122 /* a-z */) || \r\n\t\t\t(cc >= 65 && cc <= 90 /* A-Z */) || \r\n\t\t\t/* \r\n\t\t\tExperimental: include cyrillic ranges \r\n\t\t\tsince some letters, similar to latin ones, can \r\n\t\t\taccidentally appear in CSS tokens\r\n\t\t\t*/\r\n\t\t\t(cc >= 1024 && cc <= 1279) || \r\n\t\t\tc === '&' || /* selector placeholder (LESS, SCSS) */\r\n\t\t\tc === '_' || \r\n\t\t\tc === '<' || /* comparisons (LESS, SCSS) */\r\n\t\t\tc === '>' || \r\n\t\t\tc === '=' || \r\n\t\t\tc === '-'\r\n\t\t);\r\n\t}\r\n\r\n\tfunction isDigit(c, cc) {\r\n\t\tcc = cc || c.charCodeAt(0);\r\n\t\treturn (cc >= 48 && cc <= 57);\r\n\t}\r\n\r\n\tvar isOp = (function () {\r\n\t\tvar opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\r\n\t\t\topsmatcha = \"*^|$~\".split(''),\r\n\t\t\tops = {},\r\n\t\t\topsmatch = {},\r\n\t\t\ti = 0;\r\n\t\tfor (; i < opsa.length; i += 1) {\r\n\t\t\tops[opsa[i]] = true;\r\n\t\t}\r\n\t\tfor (i = 0; i < opsmatcha.length; i += 1) {\r\n\t\t\topsmatch[opsmatcha[i]] = true;\r\n\t\t}\r\n\t\treturn function (ch, matchattr) {\r\n\t\t\tif (matchattr) {\r\n\t\t\t\treturn ch in opsmatch;\r\n\t\t\t}\r\n\t\t\treturn ch in ops;\r\n\t\t};\r\n\t}());\r\n\t\r\n\t// creates token objects and pushes them to a list\r\n\tfunction tokener(value, type) {\r\n\t\tsession.tokens.push({\r\n\t\t\tvalue: value,\r\n\t\t\ttype:  type || value,\r\n\t\t\tstart: null,\r\n\t\t\tend:   null\r\n\t\t});\r\n\t}\r\n\r\n\tfunction getPosInfo(w) {\r\n\t\tvar errPos = w.chnum;\r\n\t\tvar source = w.source.replace(/\\r\\n?/g, '\\n');\r\n\t\tvar part = w.source.substring(0, errPos + 1).replace(/\\r\\n?/g, '\\n');\r\n\t\tvar lines = part.split('\\n');\r\n\t\tvar ch = (lines[lines.length - 1] || '').length;\r\n\t\tvar fullLine = source.split('\\n')[lines.length - 1] || '';\r\n\t\t\r\n\t\tvar chunkSize = 100;\r\n\t\tvar offset = Math.max(0, ch - chunkSize);\r\n\t\tvar formattedLine = fullLine.substr(offset, chunkSize * 2) + '\\n';\r\n\t\tfor (var i = 0; i < ch - offset - 1; i++) {\r\n\t\t\tformattedLine += '-';\r\n\t\t}\r\n\t\tformattedLine += '^';\r\n\r\n\t\treturn {\r\n\t\t\tline: lines.length,\r\n\t\t\tch: ch,\r\n\t\t\ttext: fullLine,\r\n\t\t\thint: formattedLine\r\n\t\t};\r\n\t}\r\n\r\n\tfunction raiseError(message) {\r\n\t\tvar err = error(message);\r\n\t\tvar errObj = new Error(err.message, '', err.line);\r\n\t\terrObj.line = err.line;\r\n\t\terrObj.ch = err.ch;\r\n\t\terrObj.name = err.name;\r\n\t\terrObj.hint = err.hint;\r\n\r\n\t\tthrow errObj;\r\n\t}\r\n\t\r\n\t// oops\r\n\tfunction error(m) { \r\n\t\tvar w = walker;\r\n\t\tvar info = getPosInfo(walker);\r\n\t\tvar tokens = session.tokens;\r\n\t\tsession.tokens = null;\r\n\r\n\t\tvar message = 'CSS parsing error at line ' + info.line + ', char ' + info.ch + ': ' + m;\r\n\t\tmessage += '\\n' +  info.hint;\r\n\t\treturn {\r\n\t\t\tname: \"ParseError\",\r\n\t\t\tmessage: message,\r\n\t\t\thint: info.hint,\r\n\t\t\tline: info.line,\r\n\t\t\tch: info.ch\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// token handlers follow for:\r\n\t// white space, comment, string, identifier, number, operator\r\n\tfunction white() {\r\n\t\tvar c = walker.ch,\r\n\t\t\ttoken = '';\r\n\t\r\n\t\twhile (c === \" \" || c === \"\\t\") {\r\n\t\t\ttoken += c;\r\n\t\t\tc = walker.nextChar();\r\n\t\t}\r\n\t\r\n\t\ttokener(token, 'white');\r\n\t\r\n\t}\r\n\r\n\tfunction comment() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\ttoken = c,\r\n\t\t\tcnext;\r\n\t \r\n\t\tcnext = w.nextChar();\r\n\r\n\t\tif (cnext === '/') {\r\n\t\t\t// inline comment in SCSS and LESS\r\n\t\t\twhile (c && !(cnext === \"\\n\" || cnext === \"\\r\")) {\r\n\t\t\t\ttoken += cnext;\r\n\t\t\t\tc = cnext;\r\n\t\t\t\tcnext = w.nextChar();\r\n\t\t\t}\r\n\t\t} else if (cnext === '*') {\r\n\t\t\t// multiline CSS commment\r\n\t\t\twhile (c && !(c === \"*\" && cnext === \"/\")) {\r\n\t\t\t\ttoken += cnext;\r\n\t\t\t\tc = cnext;\r\n\t\t\t\tcnext = w.nextChar();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// oops, not a comment, just a /\r\n\t\t\treturn tokener(token, token);\r\n\t\t}\r\n\t\t\r\n\t\ttoken += cnext;\r\n\t\tw.nextChar();\r\n\t\ttokener(token, 'comment');\r\n\t}\r\n\r\n\tfunction eatString() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\tq = c,\r\n\t\t\ttoken = c,\r\n\t\t\tcnext;\r\n\t\r\n\t\tc = w.nextChar();\r\n\r\n\t\twhile (c !== q) {\r\n\t\t\tif (c === '\\n') {\r\n\t\t\t\tcnext = w.nextChar();\r\n\t\t\t\tif (cnext === \"\\\\\") {\r\n\t\t\t\t\ttoken += c + cnext;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// end of line with no \\ escape = bad\r\n\t\t\t\t\traiseError(\"Unterminated string\");\r\n\t\t\t\t}\r\n\t\t\t} else if (c === '') {\r\n\t\t\t\traiseError(\"Unterminated string\");\r\n\t\t\t} else {\r\n\t\t\t\tif (c === \"\\\\\") {\r\n\t\t\t\t\ttoken += c + w.nextChar();\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttoken += c;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\r\n\t\t\tc = w.nextChar();\r\n\t\t}\r\n\r\n\t\ttoken += c;\r\n\r\n\t\treturn token;\r\n\t}\r\n\r\n\tfunction str() {\r\n\t\tvar token = eatString();\r\n\t\twalker.nextChar();\r\n\t\ttokener(token, 'string');\r\n\t}\r\n\t\r\n\tfunction brace() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\tdepth = 1,\r\n\t\t\ttoken = c,\r\n\t\t\tstop = false;\r\n\t\r\n\t\tc = w.nextChar();\r\n\t\r\n\t\twhile (c && !stop) {\r\n\t\t\tif (c === '(') {\r\n\t\t\t\tdepth++;\r\n\t\t\t} else if (c === ')') {\r\n\t\t\t\tdepth--;\r\n\t\t\t\tif (!depth) {\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}\r\n\t\t\t} else if (c === '\"' || c === \"'\") {\r\n\t\t\t\tc = eatString();\r\n\t\t\t} else if (c === '') {\r\n\t\t\t\traiseError(\"Unterminated brace\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttoken += c;\r\n\t\t\tc = w.nextChar();\r\n\t\t}\r\n\t\t\r\n\t\ttokener(token, 'brace');\r\n\t}\r\n\r\n\tfunction identifier(pre) {\r\n\t\tvar c = walker.ch;\r\n\t\tvar token = pre ? pre + c : c;\r\n\t\t\t\r\n\t\tc = walker.nextChar();\r\n\t\tvar cc = c.charCodeAt(0);\r\n\t\twhile (isNameChar(c, cc) || isDigit(c, cc)) {\r\n\t\t\ttoken += c;\r\n\t\t\tc = walker.nextChar();\r\n\t\t\tcc = c.charCodeAt(0);\r\n\t\t}\r\n\t\r\n\t\ttokener(token, 'identifier');\r\n\t}\r\n\r\n\tfunction num() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\ttoken = c,\r\n\t\t\tpoint = token === '.',\r\n\t\t\tnondigit;\r\n\t\t\r\n\t\tc = w.nextChar();\r\n\t\tnondigit = !isDigit(c);\r\n\t\r\n\t\t// .2px or .classname?\r\n\t\tif (point && nondigit) {\r\n\t\t\t// meh, NaN, could be a class name, so it's an operator for now\r\n\t\t\treturn tokener(token, '.');    \r\n\t\t}\r\n\t\t\r\n\t\t// -2px or -moz-something\r\n\t\tif (token === '-' && nondigit) {\r\n\t\t\treturn identifier('-');\r\n\t\t}\r\n\t\r\n\t\twhile (c !== '' && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\r\n\t\t\tif (c === '.') {\r\n\t\t\t\tpoint = true;\r\n\t\t\t}\r\n\t\t\ttoken += c;\r\n\t\t\tc = w.nextChar();\r\n\t\t}\r\n\r\n\t\ttokener(token, 'number');    \r\n\t\r\n\t}\r\n\r\n\tfunction op() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\ttoken = c,\r\n\t\t\tnext = w.nextChar();\r\n\t\t\t\r\n\t\tif (next === \"=\" && isOp(token, true)) {\r\n\t\t\ttoken += next;\r\n\t\t\ttokener(token, 'match');\r\n\t\t\tw.nextChar();\r\n\t\t\treturn;\r\n\t\t} \r\n\t\t\r\n\t\ttokener(token, token);\r\n\t}\r\n\r\n\r\n\t// call the appropriate handler based on the first character in a token suspect\r\n\tfunction tokenize() {\r\n\t\tvar ch = walker.ch;\r\n\t\r\n\t\tif (ch === \" \" || ch === \"\\t\") {\r\n\t\t\treturn white();\r\n\t\t}\r\n\r\n\t\tif (ch === '/') {\r\n\t\t\treturn comment();\r\n\t\t} \r\n\r\n\t\tif (ch === '\"' || ch === \"'\") {\r\n\t\t\treturn str();\r\n\t\t}\r\n\t\t\r\n\t\tif (ch === '(') {\r\n\t\t\treturn brace();\r\n\t\t}\r\n\t\r\n\t\tif (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\r\n\t\t\treturn num();\r\n\t\t}\r\n\t\r\n\t\tif (isNameChar(ch)) {\r\n\t\t\treturn identifier();\r\n\t\t}\r\n\r\n\t\tif (isOp(ch)) {\r\n\t\t\treturn op();\r\n\t\t}\r\n\r\n\t\tif (ch === '\\r') {\r\n\t\t\tif (walker.peek() === '\\n') {\r\n\t\t\t\tch += walker.nextChar();\r\n\t\t\t}\r\n\r\n\t\t\ttokener(ch, 'line');\r\n\t\t\twalker.nextChar();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (ch === '\\n') {\r\n\t\t\ttokener(ch, 'line');\r\n\t\t\twalker.nextChar();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\traiseError(\"Unrecognized character '\" + ch + \"'\");\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Sprits given source into tokens\r\n\t\t * @param {String} source\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlex: function (source) {\r\n\t\t\twalker.init(source);\r\n\t\t\tsession.tokens = [];\r\n\r\n\t\t\t// for empty source, return single space token\r\n\t\t\tif (!source) {\r\n\t\t\t\tsession.tokens.push(this.white());\r\n\t\t\t} else {\r\n\t\t\t\twhile (walker.ch !== '') {\r\n\t\t\t\t\ttokenize();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar tokens = session.tokens;\r\n\t\t\tsession.tokens = null;\r\n\t\t\treturn tokens;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Tokenizes CSS source. It's like `lex()` method,\r\n\t\t * but also stores proper token indexes in source, \r\n\t\t * so it's a bit slower\r\n\t\t * @param {String} source\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tparse: function(source) {\r\n\t\t\t// transform tokens\r\n\t\t\tvar tokens = this.lex(source), pos = 0, token;\r\n\t\t\tfor (var i = 0, il = tokens.length; i < il; i++) {\r\n\t\t\t\ttoken = tokens[i];\r\n\t\t\t\ttoken.start = pos;\r\n\t\t\t\ttoken.end = (pos += token.value.length);\r\n\t\t\t}\r\n\t\t\treturn tokens;\r\n\t\t},\r\n\r\n\t\twhite: function() {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: '',\r\n\t\t\t\ttype:  'white',\r\n\t\t\t\tstart: 0,\r\n\t\t\t\tend:   0\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\ttoSource: function(toks) {\r\n\t\t\tvar i = 0, max = toks.length, src = '';\r\n\t\t\tfor (; i < max; i++) {\r\n\t\t\t\tsrc += toks[i].value;\r\n\t\t\t}\r\n\t\t\treturn src;\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"parser\\\\processor\\\\attributes.js\":[function(require,module,exports){\r\n/**\r\n * Resolves node attribute names: moves `default` attribute value\r\n * from stub to real attribute.\r\n *\r\n * This resolver should be applied *after* resource matcher\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../../utils/common');\r\n\r\n\tvar findDefault = function(attr) {\r\n\t\treturn attr.isDefault;\r\n\t};\r\n\r\n\tvar findImplied = function(attr) {\r\n\t\treturn attr.isImplied;\r\n\t};\r\n\r\n\tvar findEmpty = function(attr) {\r\n\t\treturn !attr.value;\r\n\t};\r\n\r\n\tfunction resolveDefaultAttrs(node, parser) {\r\n\t\tnode.children.forEach(function(item) {\r\n\t\t\tvar attrList = item.attributeList();\r\n\t\t\tvar defaultAttrValue = item.attribute(parser.DEFAULT_ATTR_NAME);\r\n\t\t\tif (typeof defaultAttrValue !== 'undefined') {\r\n\t\t\t\t// remove stub attribute\r\n\t\t\t\titem.attribute(parser.DEFAULT_ATTR_NAME, null);\r\n\t\t\t\t\r\n\t\t\t\tif (attrList.length) {\r\n\t\t\t\t\t// target for default value:\r\n\t\t\t\t\t// 1. default attribute\r\n\t\t\t\t\t// 2. implied attribute\r\n\t\t\t\t\t// 3. first empty attribute\r\n\t\t\t\t\r\n\t\t\t\t\t// find attribute marked as default\r\n\t\t\t\t\tvar defaultAttr = utils.find(attrList, findDefault) \r\n\t\t\t\t\t\t|| utils.find(attrList, findImplied) \r\n\t\t\t\t\t\t|| utils.find(attrList, findEmpty);\r\n\r\n\t\t\t\t\tif (defaultAttr) {\r\n\t\t\t\t\t\tvar oldVal = item.attribute(defaultAttr.name);\r\n\t\t\t\t\t\tvar newVal = utils.replaceUnescapedSymbol(oldVal, '|', defaultAttrValue);\r\n\t\t\t\t\t\t// no replacement, e.g. default value does not contains | symbol\r\n\t\t\t\t\t\tif (oldVal == newVal) {\r\n\t\t\t\t\t\t\tnewVal = defaultAttrValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\titem.attribute(defaultAttr.name, newVal);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// if no default attribute value, remove implied attributes\r\n\t\t\t\tattrList.forEach(function(attr) {\r\n\t\t\t\t\tif (attr.isImplied) {\r\n\t\t\t\t\t\titem.attribute(attr.name, null);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tresolveDefaultAttrs(item, parser);\r\n\t\t});\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * @param  {AbbreviationNode} tree\r\n\t\t * @param  {Object} options\r\n\t\t * @param  {abbreviation} parser\r\n\t\t */\r\n\t\tpreprocessor: function(tree, options, parser) {\r\n\t\t\tresolveDefaultAttrs(tree, parser);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\href.js\":[function(require,module,exports){\r\n/**\r\n * A preptocessor for &lt;a&gt; tag: tests wrapped content\r\n * for common URL patterns and, if matched, inserts it as \r\n * `href` attribute\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../../assets/preferences');\r\n\tvar utils = require('../../utils/common');\r\n\tvar pc = require('./pastedContent');\r\n\r\n\tprefs.define('href.autodetect', true, \r\n\t\t'Enables or disables automatic URL recognition when wrapping\\\r\n\t\ttext with <code>&lt;a&gt;</code> tag. With this option enabled,\\\r\n\t\tif wrapped text matches URL or e-mail pattern it will be automatically\\\r\n\t\tinserted into <code>href</code> attribute.');\r\n\tprefs.define('href.urlPattern', '^(?:(?:https?|ftp|file)://|www\\\\.|ftp\\\\.)(?:\\\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\\\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\\\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\\\)|[A-Z0-9+&@#/%=~_|$])', \r\n\t\t'RegExp pattern to match wrapped URLs. Matched content will be inserts\\\r\n\t\tas-is into <code>href</code> attribute, only whitespace will be trimmed.');\r\n\r\n\tprefs.define('href.emailPattern', '^[a-z0-9._%+-]+@[a-z0-9.-]+\\\\.[a-z]{2,5}$', \r\n\t\t'RegExp pattern to match wrapped e-mails. Unlike <code>href.urlPattern</code>,\\\r\n\t\twrapped content will be prefixed with <code>mailto:</code> in <code>href</code>\\\r\n\t\tattribute');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * @param {AbbreviationNode} tree\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\tpostprocessor: function(tree, options) {\r\n\t\t\tif (!prefs.get('href.autodetect')) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar reUrl = new RegExp(prefs.get('href.urlPattern'), 'i');\r\n\t\t\tvar reEmail = new RegExp(prefs.get('href.emailPattern'), 'i');\r\n\t\t\tvar reProto = /^([a-z]+:)?\\/\\//i;\r\n\r\n\t\t\ttree.findAll(function(item) {\r\n\t\t\t\tif (item.name().toLowerCase() != 'a' || item.attribute('href')) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pastedContent = utils.trim(pc.pastedContent(item) || options.pastedContent);\r\n\t\t\t\tif (pastedContent) {\r\n\t\t\t\t\tif (reUrl.test(pastedContent)) {\r\n\t\t\t\t\t\t// do we have protocol?\r\n\t\t\t\t\t\tif (!reProto.test(pastedContent)) {\r\n\t\t\t\t\t\t\tpastedContent = 'http://' + pastedContent;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\titem.attribute('href', pastedContent);\r\n\t\t\t\t\t} else if (reEmail.test(pastedContent)) {\r\n\t\t\t\t\t\titem.attribute('href', 'mailto:' + pastedContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../assets/preferences\":\"assets\\\\preferences.js\",\"../../utils/common\":\"utils\\\\common.js\",\"./pastedContent\":\"parser\\\\processor\\\\pastedContent.js\"}],\"parser\\\\processor\\\\pastedContent.js\":[function(require,module,exports){\r\n/**\r\n * Pasted content abbreviation processor. A pasted content is a content that\r\n * should be inserted into implicitly repeated abbreviation nodes.\r\n * This processor powers “Wrap With Abbreviation” action\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../../utils/common');\r\n\tvar abbrUtils = require('../../utils/abbreviation');\r\n\tvar stringStream = require('../../assets/stringStream');\r\n\tvar range = require('../../assets/range');\r\n\r\n\tvar outputPlaceholder = '$#';\r\n\t\r\n\t/**\r\n\t * Locates output placeholders inside text\r\n\t * @param {String} text\r\n\t * @returns {Array} Array of ranges of output placeholder in text\r\n\t */\r\n\tfunction locateOutputPlaceholder(text) {\r\n\t\tvar result = [];\r\n\t\t\r\n\t\tvar stream = stringStream.create(text);\r\n\t\t\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tif (stream.peek() == '\\\\') {\r\n\t\t\t\tstream.next();\r\n\t\t\t} else {\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\r\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstream.next();\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Replaces output placeholders inside <code>source</code> with \r\n\t * <code>value</code>\r\n\t * @param {String} source\r\n\t * @param {String} value\r\n\t * @returns {String}\r\n\t */\r\n\tfunction replaceOutputPlaceholders(source, value) {\r\n\t\tvar ranges = locateOutputPlaceholder(source);\r\n\t\t\r\n\t\tranges.reverse().forEach(function(r) {\r\n\t\t\tsource = utils.replaceSubstring(source, value, r);\r\n\t\t});\r\n\t\t\r\n\t\treturn source;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if parsed node contains output placeholder – a target where\r\n\t * pasted content should be inserted\r\n\t * @param {AbbreviationNode} node\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction hasOutputPlaceholder(node) {\r\n\t\tif (locateOutputPlaceholder(node.content).length)\r\n\t\t\treturn true;\r\n\t\t\r\n\t\t// check if attributes contains placeholder\r\n\t\treturn !!utils.find(node.attributeList(), function(attr) {\r\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Insert pasted content into correct positions of parsed node\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {String} content\r\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\r\n\t * found instead of appending to existing content\r\n\t */\r\n\tfunction insertPastedContent(node, content, overwrite) {\r\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\r\n\t\t\treturn hasOutputPlaceholder(item);\r\n\t\t});\r\n\t\t\r\n\t\tif (hasOutputPlaceholder(node))\r\n\t\t\tnodesWithPlaceholders.unshift(node);\r\n\t\t\r\n\t\tif (nodesWithPlaceholders.length) {\r\n\t\t\tnodesWithPlaceholders.forEach(function(item) {\r\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\r\n\t\t\t\titem._attributes.forEach(function(attr) {\r\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// on output placeholders in subtree, insert content in the deepest\r\n\t\t\t// child node\r\n\t\t\tvar deepest = node.deepestChild() || node;\r\n\t\t\tif (overwrite) {\r\n\t\t\t\tdeepest.content = content;\r\n\t\t\t} else {\r\n\t\t\t\tdeepest.content = abbrUtils.insertChildContent(deepest.content, content);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tpastedContent: function(item) {\r\n\t\t\tvar content = item.data('paste');\r\n\t\t\tif (Array.isArray(content)) {\r\n\t\t\t\treturn content[item.counter - 1];\r\n\t\t\t} else if (typeof content === 'function') {\r\n\t\t\t\treturn content(item.counter - 1, item.content);\r\n\t\t\t} else if (content) {\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @param {AbbreviationNode} tree\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\tpreprocessor: function(tree, options) {\r\n\t\t\tif (options.pastedContent) {\r\n\t\t\t\tvar lines = utils.splitByLines(options.pastedContent, true).map(utils.trim);\r\n\t\t\t\t\r\n\t\t\t\t// set repeat count for implicitly repeated elements before\r\n\t\t\t\t// tree is unrolled\r\n\t\t\t\ttree.findAll(function(item) {\r\n\t\t\t\t\tif (item.hasImplicitRepeat) {\r\n\t\t\t\t\t\titem.data('paste', lines);\r\n\t\t\t\t\t\treturn item.repeatCount = lines.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @param {AbbreviationNode} tree\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\tpostprocessor: function(tree, options) {\r\n\t\t\tvar that = this;\r\n\t\t\t// for each node with pasted content, update text data\r\n\t\t\tvar targets = tree.findAll(function(item) {\r\n\t\t\t\tvar pastedContent = that.pastedContent(item);\r\n\t\t\t\tif (pastedContent) {\r\n\t\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn !!pastedContent;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (!targets.length && options.pastedContent) {\r\n\t\t\t\t// no implicitly repeated elements, put pasted content in\r\n\t\t\t\t// the deepest child\r\n\t\t\t\tinsertPastedContent(tree, options.pastedContent);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../assets/range\":\"assets\\\\range.js\",\"../../assets/stringStream\":\"assets\\\\stringStream.js\",\"../../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\resourceMatcher.js\":[function(require,module,exports){\r\n/**\r\n * Processor function that matches parsed <code>AbbreviationNode</code>\r\n * against resources defined in <code>resource</code> module\r\n */ \r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar resources = require('../../assets/resources');\r\n\tvar elements = require('../../assets/elements');\r\n\tvar utils = require('../../utils/common');\r\n\tvar abbreviationUtils = require('../../utils/abbreviation');\r\n\r\n\t/**\r\n\t * Finds matched resources for child nodes of passed <code>node</code> \r\n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\r\n\t * that describes output of parsed node \r\n\t * @param {AbbreviationNode} node\r\n\t * @param {String} syntax\r\n\t */\r\n\tfunction matchResources(node, syntax, parser) {\r\n\t\t// do a shallow copy because the children list can be modified during\r\n\t\t// resource matching\r\n\t\tnode.children.slice(0).forEach(function(child) {\r\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\r\n\t\t\tif (typeof r === 'string') {\r\n\t\t\t\tr = elements.create('snippet', r);\r\n\t\t\t}\r\n\r\n\t\t\tchild.data('resource', r);\r\n\t\t\tvar elemType = elements.type(r);\r\n\r\n\t\t\tif (elemType == 'snippet') {\r\n\t\t\t\tvar content = r.data;\r\n\t\t\t\tvar curContent = child._text || child.content;\r\n\t\t\t\tif (curContent) {\r\n\t\t\t\t\tcontent = abbreviationUtils.insertChildContent(content, curContent);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tchild.content = content;\r\n\t\t\t} else if (elemType == 'element') {\r\n\t\t\t\tchild._name = r.name;\r\n\t\t\t\tif (Array.isArray(r.attributes)) {\r\n\t\t\t\t\tchild._attributes = [].concat(r.attributes, child._attributes);\r\n\t\t\t\t}\r\n\t\t\t} else if (elemType == 'reference') {\r\n\t\t\t\t// it’s a reference to another abbreviation:\r\n\t\t\t\t// parse it and insert instead of current child\r\n\t\t\t\t/** @type AbbreviationNode */\r\n\t\t\t\tvar subtree = parser.parse(r.data, {\r\n\t\t\t\t\tsyntax: syntax\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// if context element should be repeated, check if we need to \r\n\t\t\t\t// transfer repeated element to specific child node\r\n\t\t\t\tif (child.repeatCount > 1) {\r\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\r\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tif (!repeatedChildren.length) {\r\n\t\t\t\t\t\trepeatedChildren = subtree.children\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\trepeatedChildren.forEach(function(node) {\r\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\r\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// move child‘s children into the deepest child of new subtree\r\n\t\t\t\tvar deepestChild = subtree.deepestChild();\r\n\t\t\t\tif (deepestChild) {\r\n\t\t\t\t\tchild.children.forEach(function(c) {\r\n\t\t\t\t\t\tdeepestChild.addChild(c);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tdeepestChild.content = child.content;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// copy current attributes to children\r\n\t\t\t\tsubtree.children.forEach(function(node) {\r\n\t\t\t\t\tchild.attributeList().forEach(function(attr) {\r\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tchild.replace(subtree.children);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmatchResources(child, syntax, parser);\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tpreprocessor: function(tree, options, parser) {\r\n\t\t\tvar syntax = options.syntax || utils.defaultSyntax();\r\n\t\t\tmatchResources(tree, syntax, parser);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../assets/elements\":\"assets\\\\elements.js\",\"../../assets/resources\":\"assets\\\\resources.js\",\"../../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\tagName.js\":[function(require,module,exports){\r\n/**\r\n * Resolves tag names in abbreviations with implied name\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar tagName = require('../../resolver/tagName');\r\n\r\n\t/**\r\n\t * Resolves implicit node names in parsed tree\r\n\t * @param {AbbreviationNode} tree\r\n\t */\r\n\tfunction resolveNodeNames(tree) {\r\n\t\ttree.children.forEach(function(node) {\r\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\r\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\r\n\t\t\t\tnode.data('nameResolved', true);\r\n\t\t\t}\r\n\t\t\tresolveNodeNames(node);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn {\r\n\t\tpostprocessor: resolveNodeNames\r\n\t};\r\n});\r\n},{\"../../resolver/tagName\":\"resolver\\\\tagName.js\"}],\"parser\\\\xml.js\":[function(require,module,exports){\r\n/**\r\n * HTML tokenizer by Marijn Haverbeke\r\n * http://codemirror.net/\r\n * @constructor\r\n * @memberOf __xmlParseDefine\r\n * @param {Function} require\r\n * @param {Underscore} _\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar stringStream = require('../assets/stringStream');\r\n\r\n\tvar Kludges = {\r\n\t\tautoSelfClosers : {},\r\n\t\timplicitlyClosed : {},\r\n\t\tcontextGrabbers : {},\r\n\t\tdoNotIndent : {},\r\n\t\tallowUnquoted : true,\r\n\t\tallowMissing : true\r\n\t};\r\n\r\n\t// Return variables for tokenizers\r\n\tvar tagName = null, type = null;\r\n\r\n\tfunction inText(stream, state) {\r\n\t\tfunction chain(parser) {\r\n\t\t\tstate.tokenize = parser;\r\n\t\t\treturn parser(stream, state);\r\n\t\t}\r\n\r\n\t\tvar ch = stream.next();\r\n\t\tif (ch == \"<\") {\r\n\t\t\tif (stream.eat(\"!\")) {\r\n\t\t\t\tif (stream.eat(\"[\")) {\r\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\r\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t} else if (stream.match(\"--\"))\r\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\r\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\r\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\r\n\t\t\t\t\treturn chain(doctype(1));\r\n\t\t\t\t} else\r\n\t\t\t\t\treturn null;\r\n\t\t\t} else if (stream.eat(\"?\")) {\r\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\r\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\r\n\t\t\t\treturn \"meta\";\r\n\t\t\t} else {\r\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\r\n\t\t\t\tstream.eatSpace();\r\n\t\t\t\ttagName = \"\";\r\n\t\t\t\tvar c;\r\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\r\n\t\t\t\t\ttagName += c;\r\n\t\t\t\tstate.tokenize = inTag;\r\n\t\t\t\treturn \"tag\";\r\n\t\t\t}\r\n\t\t} else if (ch == \"&\") {\r\n\t\t\tvar ok;\r\n\t\t\tif (stream.eat(\"#\")) {\r\n\t\t\t\tif (stream.eat(\"x\")) {\r\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\r\n\t\t\t}\r\n\t\t\treturn ok ? \"atom\" : \"error\";\r\n\t\t} else {\r\n\t\t\tstream.eatWhile(/[^&<]/);\r\n\t\t\treturn \"text\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction inTag(stream, state) {\r\n\t\tvar ch = stream.next();\r\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\r\n\t\t\tstate.tokenize = inText;\r\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\r\n\t\t\treturn \"tag\";\r\n\t\t} else if (ch == \"=\") {\r\n\t\t\ttype = \"equals\";\r\n\t\t\treturn null;\r\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\r\n\t\t\tstate.tokenize = inAttribute(ch);\r\n\t\t\treturn state.tokenize(stream, state);\r\n\t\t} else {\r\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\r\n\t\t\treturn \"word\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction inAttribute(quote) {\r\n\t\treturn function(stream, state) {\r\n\t\t\twhile (!stream.eol()) {\r\n\t\t\t\tif (stream.next() == quote) {\r\n\t\t\t\t\tstate.tokenize = inTag;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"string\";\r\n\t\t};\r\n\t}\r\n\r\n\tfunction inBlock(style, terminator) {\r\n\t\treturn function(stream, state) {\r\n\t\t\twhile (!stream.eol()) {\r\n\t\t\t\tif (stream.match(terminator)) {\r\n\t\t\t\t\tstate.tokenize = inText;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tstream.next();\r\n\t\t\t}\r\n\t\t\treturn style;\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction doctype(depth) {\r\n\t\treturn function(stream, state) {\r\n\t\t\tvar ch;\r\n\t\t\twhile ((ch = stream.next()) !== null) {\r\n\t\t\t\tif (ch == \"<\") {\r\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\r\n\t\t\t\t\treturn state.tokenize(stream, state);\r\n\t\t\t\t} else if (ch == \">\") {\r\n\t\t\t\t\tif (depth == 1) {\r\n\t\t\t\t\t\tstate.tokenize = inText;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\r\n\t\t\t\t\t\treturn state.tokenize(stream, state);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"meta\";\r\n\t\t};\r\n\t}\r\n\r\n\tvar curState = null, setStyle;\r\n\tfunction pass() {\r\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\r\n\t\t\tcurState.cc.push(arguments[i]);\r\n\t}\r\n\t\r\n\tfunction cont() {\r\n\t\tpass.apply(null, arguments);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction pushContext(tagName, startOfLine) {\r\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \r\n\t\t\t|| (curState.context && curState.context.noIndent);\r\n\t\tcurState.context = {\r\n\t\t\tprev : curState.context,\r\n\t\t\ttagName : tagName,\r\n\t\t\tindent : curState.indented,\r\n\t\t\tstartOfLine : startOfLine,\r\n\t\t\tnoIndent : noIndent\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction popContext() {\r\n\t\tif (curState.context)\r\n\t\t\tcurState.context = curState.context.prev;\r\n\t}\r\n\r\n\tfunction element(type) {\r\n\t\tif (type == \"openTag\") {\r\n\t\t\tcurState.tagName = tagName;\r\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\r\n\t\t} else if (type == \"closeTag\") {\r\n\t\t\tvar err = false;\r\n\t\t\tif (curState.context) {\r\n\t\t\t\tif (curState.context.tagName != tagName) {\r\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\r\n\t\t\t\t\t\tpopContext();\r\n\t\t\t\t\t}\r\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\terr = true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (err)\r\n\t\t\t\tsetStyle = \"error\";\r\n\t\t\treturn cont(endclosetag(err));\r\n\t\t}\r\n\t\treturn cont();\r\n\t}\r\n\t\r\n\tfunction endtag(startOfLine) {\r\n\t\treturn function(type) {\r\n\t\t\tif (type == \"selfcloseTag\"\r\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\r\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\r\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\r\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\r\n\t\t\t\treturn cont();\r\n\t\t\t}\r\n\t\t\tif (type == \"endTag\") {\r\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\r\n\t\t\t\tpushContext(curState.tagName, startOfLine);\r\n\t\t\t\treturn cont();\r\n\t\t\t}\r\n\t\t\treturn cont();\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction endclosetag(err) {\r\n\t\treturn function(type) {\r\n\t\t\tif (err)\r\n\t\t\t\tsetStyle = \"error\";\r\n\t\t\tif (type == \"endTag\") {\r\n\t\t\t\tpopContext();\r\n\t\t\t\treturn cont();\r\n\t\t\t}\r\n\t\t\tsetStyle = \"error\";\r\n\t\t\treturn cont(arguments.callee);\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction maybePopContext(nextTagName) {\r\n\t\tvar parentTagName;\r\n\t\twhile (true) {\r\n\t\t\tif (!curState.context) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\r\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\r\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tpopContext();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction attributes(type) {\r\n\t\tif (type == \"word\") {\r\n\t\t\tsetStyle = \"attribute\";\r\n\t\t\treturn cont(attribute, attributes);\r\n\t\t}\r\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\r\n\t\t\treturn pass();\r\n\t\tsetStyle = \"error\";\r\n\t\treturn cont(attributes);\r\n\t}\r\n\t\r\n\tfunction attribute(type) {\r\n\t\tif (type == \"equals\")\r\n\t\t\treturn cont(attvalue, attributes);\r\n\t\tif (!Kludges.allowMissing)\r\n\t\t\tsetStyle = \"error\";\r\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\r\n\t\t\t\t: cont();\r\n\t}\r\n\t\r\n\tfunction attvalue(type) {\r\n\t\tif (type == \"string\")\r\n\t\t\treturn cont(attvaluemaybe);\r\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\r\n\t\t\tsetStyle = \"string\";\r\n\t\t\treturn cont();\r\n\t\t}\r\n\t\tsetStyle = \"error\";\r\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\r\n\t\t\t\t: cont();\r\n\t}\r\n\t\r\n\tfunction attvaluemaybe(type) {\r\n\t\tif (type == \"string\")\r\n\t\t\treturn cont(attvaluemaybe);\r\n\t\telse\r\n\t\t\treturn pass();\r\n\t}\r\n\t\r\n\tfunction startState() {\r\n\t\treturn {\r\n\t\t\ttokenize : inText,\r\n\t\t\tcc : [],\r\n\t\t\tindented : 0,\r\n\t\t\tstartOfLine : true,\r\n\t\t\ttagName : null,\r\n\t\t\tcontext : null\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction token(stream, state) {\r\n\t\tif (stream.sol()) {\r\n\t\t\tstate.startOfLine = true;\r\n\t\t\tstate.indented = 0;\r\n\t\t}\r\n\t\t\r\n\t\tif (stream.eatSpace())\r\n\t\t\treturn null;\r\n\r\n\t\tsetStyle = type = tagName = null;\r\n\t\tvar style = state.tokenize(stream, state);\r\n\t\tstate.type = type;\r\n\t\tif ((style || type) && style != \"comment\") {\r\n\t\t\tcurState = state;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar comb = state.cc.pop() || element;\r\n\t\t\t\tif (comb(type || style))\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tstate.startOfLine = false;\r\n\t\treturn setStyle || style;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * @memberOf emmet.xmlParser\r\n\t\t * @returns\r\n\t\t */\r\n\t\tparse: function(data, offset) {\r\n\t\t\toffset = offset || 0;\r\n\t\t\tvar state = startState();\r\n\t\t\tvar stream = stringStream.create(data);\r\n\t\t\tvar tokens = [];\r\n\t\t\twhile (!stream.eol()) {\r\n\t\t\t\ttokens.push({\r\n\t\t\t\t\ttype: token(stream, state),\r\n\t\t\t\t\tstart: stream.start + offset,\r\n\t\t\t\t\tend: stream.pos + offset\r\n\t\t\t\t});\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn tokens;\r\n\t\t}\t\t\r\n\t};\r\n});\r\n\r\n},{\"../assets/stringStream\":\"assets\\\\stringStream.js\"}],\"plugin\\\\file.js\":[function(require,module,exports){\r\n/**\r\n * Module for working with file. Shall implement\r\n * IEmmetFile interface.\r\n *\r\n * Since implementation of this module depends\r\n * greatly on current runtime, this module must be\r\n * initialized with actual implementation first\r\n * before use. E.g.\r\n * require('./plugin/file')({\r\n * \tread: function() {...}\r\n * })\r\n *\r\n * By default, this module provides Node.JS implementation\r\n */\r\n\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar _transport = {};\r\n\r\n\t// hide it from Require.JS parser\r\n\t(function(r) {\r\n\t\tif (typeof define === 'undefined' || !define.amd) {\r\n\t\t\ttry {\r\n\t\t\t\tfs = r('fs');\r\n\t\t\t\tpath = r('path');\r\n\t\t\t\t_transport.http = r('http');\r\n\t\t\t\t_transport.https = r('https');\r\n\t\t\t} catch(e) { }\r\n\t\t}\r\n\t})(require);\r\n\r\n\t// module is a function that can extend itself\r\n\tmodule.exports = function(obj) {\r\n\t\tif (obj) {\r\n\t\t\tutils.extend(module.exports, obj);\r\n\t\t}\r\n\t};\r\n\r\n\tfunction bts(bytes) {\r\n\t\tvar out = [];\r\n\t\tfor (var i = 0, il = bytes.length; i < il; i++) {\r\n\t\t\tout.push(String.fromCharCode(bytes[i]));\r\n\t\t}\r\n\t\treturn out.join('');\r\n\t}\r\n\r\n\tfunction isURL(path) {\r\n\t\tvar re = /^https?:\\/\\//;\r\n\t\treturn re.test(path);\r\n\t}\r\n\r\n\treturn utils.extend(module.exports, {\r\n\t\t_parseParams: function(args) {\r\n\t\t\tvar params = {\r\n\t\t\t\tpath: args[0],\r\n\t\t\t\tsize: 0\r\n\t\t\t};\r\n\r\n\t\t\targs = utils.toArray(args, 1);\r\n\t\t\tparams.callback = args[args.length - 1];\r\n\t\t\targs = args.slice(0, args.length - 1);\r\n\t\t\tif (args.length) {\r\n\t\t\t\tparams.size = args[0];\r\n\t\t\t}\r\n\r\n\t\t\treturn params;\r\n\t\t},\r\n\r\n\t\t_read: function(params, callback) {\r\n\t\t\tif (isURL(params.path)) {\r\n\t\t\t\tvar req = _transport[/^https:/.test(params.path) ? 'https' : 'http'].get(params.path, function(res) {\r\n\t\t\t\t\tvar bufs = [];\r\n\t\t\t\t\tvar totalLength = 0;\r\n\t\t\t\t\tvar finished = false;\r\n\t\t\t\t\tres\r\n\t\t\t\t\t\t.on('data', function(chunk) {\r\n\t\t\t\t\t\t\ttotalLength += chunk.length;\r\n\t\t\t\t\t\t\tbufs.push(chunk);\r\n\t\t\t\t\t\t\tif (params.size && totalLength >= params.size) {\r\n\t\t\t\t\t\t\t\tfinished = true;\r\n\t\t\t\t\t\t\t\tcallback(null, Buffer.concat(bufs));\r\n\t\t\t\t\t\t\t\treq.abort();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on('end', function() {\r\n\t\t\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\t\t\tfinished = true;\r\n\t\t\t\t\t\t\t\tcallback(null, Buffer.concat(bufs));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}).on('error', callback);\r\n\t\t\t} else {\r\n\t\t\t\tif (params.size) {\r\n\t\t\t\t\tvar fd = fs.openSync(params.path, 'r');\r\n\t\t\t\t\tvar buf = new Buffer(params.size);\r\n\t\t\t\t\tfs.read(fd, buf, 0, params.size, null, function(err, bytesRead) {\r\n\t\t\t\t\t\tcallback(err, buf)\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcallback(null, fs.readFileSync(params.path));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Reads binary file content and return it\r\n\t\t * @param {String} path File's relative or absolute path\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tread: function(path, size, callback) {\r\n\t\t\tvar params = this._parseParams(arguments);\r\n\t\t\tthis._read(params, function(err, buf) {\r\n\t\t\t\tparams.callback(err, err ? '' : bts(buf));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Read file content and return it\r\n\t\t * @param {String} path File's relative or absolute path\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treadText: function(path, size, callback) {\r\n\t\t\tvar params = this._parseParams(arguments);\r\n\t\t\tthis._read(params, function(err, buf) {\r\n\t\t\t\tparams.callback(err, err ? '' : buf.toString());\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Locate <code>file_name</code> file that relates to <code>editor_file</code>.\r\n\t\t * File name may be absolute or relative path\r\n\t\t *\r\n\t\t * <b>Dealing with absolute path.</b>\r\n\t\t * Many modern editors have a \"project\" support as information unit, but you\r\n\t\t * should not rely on project path to find file with absolute path. First,\r\n\t\t * it requires user to create a project before using this method (and this\r\n\t\t * is not very convenient). Second, project path doesn't always points to\r\n\t\t * to website's document root folder: it may point, for example, to an\r\n\t\t * upper folder which contains server-side scripts.\r\n\t\t *\r\n\t\t * For better result, you should use the following algorithm in locating\r\n\t\t * absolute resources:\r\n\t\t * 1) Get parent folder for <code>editorFile</code> as a start point\r\n\t\t * 2) Append required <code>fileName</code> to start point and test if\r\n\t\t * file exists\r\n\t\t * 3) If it doesn't exists, move start point one level up (to parent folder)\r\n\t\t * and repeat step 2.\r\n\t\t *\r\n\t\t * @param {String} editorFile\r\n\t\t * @param {String} fileName\r\n\t\t * @return {String} Returns null if <code>fileName</code> cannot be located\r\n\t\t */\r\n\t\tlocateFile: function(editorFile, fileName, callback) {\r\n\t\t\tif (isURL(fileName)) {\r\n\t\t\t\treturn callback(fileName);\r\n\t\t\t}\r\n\r\n\t\t\tvar dirname = editorFile\r\n\t\t\tvar filepath;\r\n\t\t\tfileName = fileName.replace(/^\\/+/, '');\r\n\t\t\twhile (dirname && dirname !== path.dirname(dirname)) {\r\n\t\t\t\tdirname = path.dirname(dirname);\r\n\t\t\t\tfilepath = path.join(dirname, fileName);\r\n\t\t\t\tif (fs.existsSync(filepath))\r\n\t\t\t\t\treturn callback(filepath);\r\n\t\t\t}\r\n\r\n\t\t\tcallback(null);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates absolute path by concatenating <code>parent</code> and <code>fileName</code>.\r\n\t\t * If <code>parent</code> points to file, its parent directory is used\r\n\t\t * @param {String} parent\r\n\t\t * @param {String} fileName\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tcreatePath: function(parent, fileName, callback) {\r\n\t\t\tfs.stat(parent, function(err, stat) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\treturn callback(err);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (stat.isFile()) {\r\n\t\t\t\t\tparent = path.dirname(parent);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar filepath = path.resolve(parent, fileName);\r\n\t\t\t\tcallback(null, filepath);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Saves <code>content</code> as <code>file</code>\r\n\t\t * @param {String} file File's absolute path\r\n\t\t * @param {String} content File content\r\n\t\t */\r\n\t\tsave: function(file, content, callback) {\r\n\t\t\tfs.writeFile(file, content, 'ascii', function(err) {\r\n\t\t\t\tcallback(err ? err : null);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns file extension in lower case\r\n\t\t * @param {String} file\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetExt: function(file) {\r\n\t\t\tvar m = (file || '').match(/\\.([\\w\\-]+)$/);\r\n\t\t\treturn m ? m[1].toLowerCase() : '';\r\n\t\t}\r\n\r\n\t});\r\n});\r\n\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"resolver\\\\css.js\":[function(require,module,exports){\r\n/**\r\n * Resolver for fast CSS typing. Handles abbreviations with the following \r\n * notation:<br>\r\n * \r\n * <code>(-vendor prefix)?property(value)*(!)?</code>\r\n * \r\n * <br><br>\r\n * <b>Abbreviation handling</b><br>\r\n * \r\n * By default, Emmet searches for matching snippet definition for provided abbreviation.\r\n * If snippet wasn't found, Emmet automatically generates element with \r\n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\r\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\r\n * <br><br>\r\n * This module will capture all expanded properties and upgrade them with values, \r\n * vendor prefixes and !important declarations. All unmatched abbreviations will \r\n * be automatically transformed into <code>property-name: ${1}</code> snippets. \r\n * \r\n * <b>Vendor prefixes<b><br>\r\n * \r\n * If CSS-property is preceded with dash, resolver should output property with\r\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \r\n * abbreviation generates <code>border-radius: ${value};</code> snippet,\r\n * the <code>-brad</code> abbreviation should generate:\r\n * <pre><code>\r\n * -webkit-border-radius: ${value};\r\n * -moz-border-radius: ${value};\r\n * border-radius: ${value};\r\n * </code></pre>\r\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \r\n * supports unprefixed property.<br><br>\r\n * \r\n * Users can also provide an explicit list of one-character prefixes for any\r\n * CSS property. For example, <code>-wm-float</code> will produce\r\n * \r\n * <pre><code>\r\n * -webkit-float: ${1};\r\n * -moz-float: ${1};\r\n * float: ${1};\r\n * </code></pre>\r\n * \r\n * Although this example looks pointless, users can use this feature to write\r\n * cutting-edge properties implemented by browser vendors recently.  \r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar resources = require('../assets/resources');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar ciu = require('../assets/caniuse');\r\n\tvar utils = require('../utils/common');\r\n\tvar template = require('../utils/template');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\r\n\tvar prefixObj = {\r\n\t\t/** Real vendor prefix name */\r\n\t\tprefix: 'emmet',\r\n\t\t\r\n\t\t/** \r\n\t\t * Indicates this prefix is obsolete and should't be used when user \r\n\t\t * wants to generate all-prefixed properties\r\n\t\t */\r\n\t\tobsolete: false,\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns prefixed CSS property name\r\n\t\t * @param {String} name Unprefixed CSS property\r\n\t\t */\r\n\t\ttransformName: function(name) {\r\n\t\t\treturn '-' + this.prefix + '-' + name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * List of unprefixed CSS properties that supported by \r\n\t\t * current prefix. This list is used to generate all-prefixed property\r\n\t\t * @returns {Array} \r\n\t\t */\r\n\t\tproperties: function() {\r\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if given property is supported by current prefix\r\n\t\t * @param name\r\n\t\t */\r\n\t\tsupports: function(name) {\r\n\t\t\treturn ~this.properties().indexOf(name);\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\t/** \r\n\t * List of registered one-character prefixes. Key is a one-character prefix, \r\n\t * value is an <code>prefixObj</code> object\r\n\t */\r\n\tvar vendorPrefixes = {};\r\n\t\r\n\tvar defaultValue = '${1};';\r\n\t\r\n\t// XXX module preferences\r\n\tprefs.define('css.valueSeparator', ': ',\r\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \r\n\t\t\t+ 'value when expanding CSS abbreviations.');\r\n\tprefs.define('css.propertyEnd', ';',\r\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \r\n\t\t\t+ 'when expanding CSS abbreviations.');\r\n\t\r\n\tprefs.define('stylus.valueSeparator', ' ',\r\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \r\n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\r\n\tprefs.define('stylus.propertyEnd', '',\r\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \r\n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\r\n\t\r\n\tprefs.define('sass.propertyEnd', '',\r\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \r\n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\r\n\r\n\tprefs.define('css.syntaxes', 'css, less, sass, scss, stylus, styl',\r\n\t\t\t'List of syntaxes that should be treated as CSS dialects.');\r\n\t\r\n\tprefs.define('css.autoInsertVendorPrefixes', true,\r\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \r\n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\r\n\t\t\t+ 'properties only when you put dash before abbreviation ' \r\n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you don’t ' \r\n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \r\n\t\t\t+ 'vendor-prefixed properties for you.');\r\n\r\n\tprefs.define('less.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for LESS syntax');\r\n\tprefs.define('scss.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for SCSS syntax');\r\n\tprefs.define('sass.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for SASS syntax');\r\n\tprefs.define('stylus.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for Stylus syntax');\r\n\t\r\n\tvar descTemplate = template('A comma-separated list of CSS properties that may have ' \r\n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\r\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\r\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \r\n\t\t+ 'have <code><%= vendor %></code> prefix.');\r\n\t\r\n\tvar descAddonTemplate = template('A comma-separated list of <em>additional</em> CSS properties ' \r\n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \r\n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \r\n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\r\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\r\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\r\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\r\n\t\r\n\t// properties list is created from cssFeatures.html file\r\n\tvar props = {\r\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\r\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\r\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, wrap-flow, wrap-margin, wrap-through, writing-mode',\r\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\r\n\t};\r\n\t\r\n\tObject.keys(props).forEach(function(k) {\r\n\t\tprefs.define('css.' + k + 'Properties', props[k], descTemplate({vendor: k}));\r\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\r\n\t});\r\n\t\r\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \r\n\t\t\t'The list of properties whose values ​​must not contain units.');\r\n\t\r\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\r\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\r\n\t\r\n\tprefs.define('css.keywords', 'auto, inherit, all', \r\n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\r\n\t\r\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \r\n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\r\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\r\n\t\r\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \r\n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\r\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\r\n\t\r\n\tprefs.define('css.color.short', true, \r\n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\r\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\r\n\t\r\n\tprefs.define('css.color.case', 'keep', \r\n\t\t\t'Letter case of color values generated by abbreviations with color '\r\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\r\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\r\n\t\r\n\tprefs.define('css.fuzzySearch', true, \r\n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \r\n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\r\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\r\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \r\n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\r\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\r\n\t\t\t+ '<code>oh</code>');\r\n\t\r\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \r\n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \r\n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\r\n\t\t\t+ 'higher values may reduce possible matches.');\r\n\t\r\n\tprefs.define('css.alignVendor', false, \r\n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \r\n\t\t\t+ 'will be aligned by real property name.');\r\n\t\r\n\t\r\n\tfunction isNumeric(ch) {\r\n\t\tvar code = ch && ch.charCodeAt(0);\r\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if provided snippet contains only one CSS property and value.\r\n\t * @param {String} snippet\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction isSingleProperty(snippet) {\r\n\t\tsnippet = utils.trim(snippet);\r\n\t\t\r\n\t\t// check if it doesn't contain a comment and a newline\r\n\t\tif (/\\/\\*|\\n|\\r/.test(snippet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// check if it's a valid snippet definition\r\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\treturn snippet.replace(/\\$\\{.+?\\}/g, '').split(':').length == 2;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Normalizes abbreviated value to final CSS one\r\n\t * @param {String} value\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeValue(value) {\r\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\r\n\t\t\tvalue = value.replace(/^\\-+/, '');\r\n\t\t}\r\n\t\t\r\n\t\tvar ch = value.charAt(0);\r\n\t\tif (ch == '#') {\r\n\t\t\treturn normalizeHexColor(value);\r\n\t\t}\r\n\r\n\t\tif (ch == '$') {\r\n\t\t\treturn utils.escapeText(value);\r\n\t\t}\r\n\r\n\t\treturn getKeyword(value);\r\n\t}\r\n\t\r\n\tfunction normalizeHexColor(value) {\r\n\t\tvar hex = value.replace(/^#+/, '') || '0';\r\n\t\tif (hex.toLowerCase() == 't') {\r\n\t\t\treturn 'transparent';\r\n\t\t}\r\n\r\n\t\tvar opacity = '';\r\n\t\thex = hex.replace(/\\.(\\d+)$/, function(str) {\r\n\t\t\topacity = '0' + str;\r\n\t\t\treturn '';\r\n\t\t});\r\n\t\t\r\n\t\tvar repeat = utils.repeatString;\r\n\t\tvar color = null;\r\n\t\tswitch (hex.length) {\r\n\t\t\tcase 1:\r\n\t\t\t\tcolor = repeat(hex, 6);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tcolor = repeat(hex, 3);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tcolor = hex + hex.substr(0, 2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcolor = hex + hex.charAt(0);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tcolor = hex.substr(0, 6);\r\n\t\t}\r\n\r\n\t\tif (opacity) {\r\n\t\t\treturn toRgba(color, opacity);\r\n\t\t}\r\n\t\t\r\n\t\t// color must be shortened?\r\n\t\tif (prefs.get('css.color.short')) {\r\n\t\t\tvar p = color.split('');\r\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\r\n\t\t\t\tcolor = p[0] + p[2] + p[4];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// should transform case?\r\n\t\tswitch (prefs.get('css.color.case')) {\r\n\t\t\tcase 'upper':\r\n\t\t\t\tcolor = color.toUpperCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'lower':\r\n\t\t\t\tcolor = color.toLowerCase();\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\treturn '#' + color;\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms HEX color definition into RGBA one\r\n\t * @param  {String} color   HEX color, 6 characters\r\n\t * @param  {String} opacity Opacity value\r\n\t * @return {String}\r\n\t */\r\n\tfunction toRgba(color, opacity) {\r\n\t\tvar r = parseInt(color.substr(0, 2), 16);\r\n\t\tvar g = parseInt(color.substr(2, 2), 16);\r\n\t\tvar b = parseInt(color.substr(4, 2), 16);\r\n\r\n\t\treturn 'rgba(' + [r, g, b, opacity].join(', ') + ')';\r\n\t}\r\n\t\r\n\tfunction getKeyword(name) {\r\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\r\n\t\treturn name in aliases ? aliases[name] : name;\r\n\t}\r\n\t\r\n\tfunction getUnit(name) {\r\n\t\tvar aliases = prefs.getDict('css.unitAliases');\r\n\t\treturn name in aliases ? aliases[name] : name;\r\n\t}\r\n\t\r\n\tfunction isValidKeyword(keyword) {\r\n\t\treturn ~prefs.getArray('css.keywords').indexOf(getKeyword(keyword));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if passed CSS property support specified vendor prefix \r\n\t * @param {String} property\r\n\t * @param {String} prefix\r\n\t */\r\n\tfunction hasPrefix(property, prefix) {\r\n\t\tvar info = vendorPrefixes[prefix];\r\n\t\t\r\n\t\tif (!info)\r\n\t\t\tinfo = utils.find(vendorPrefixes, function(data) {\r\n\t\t\t\treturn data.prefix == prefix;\r\n\t\t\t});\r\n\t\t\r\n\t\treturn info && info.supports(property);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds available vendor prefixes for given CSS property.\r\n\t * Search is performed within Can I Use database and internal\r\n\t * property list\r\n\t * @param  {String} property CSS property name\r\n\t * @return {Array} Array of resolved prefixes or null if\r\n\t * prefixes are not available for this property at all.\r\n\t * Empty array means prefixes are not available for current\r\n\t * user-define era\r\n\t */\r\n\tfunction findVendorPrefixes(property) {\r\n\t\tvar prefixes = ciu.resolvePrefixes(property);\r\n\t\tif (!prefixes) {\r\n\t\t\t// Can I Use database is disabled or prefixes are not\r\n\t\t\t// available for this property\r\n\t\t\tprefixes = [];\r\n\t\t\tObject.keys(vendorPrefixes).forEach(function(key) {\r\n\t\t\t\tif (hasPrefix(property, key)) {\r\n\t\t\t\t\tprefixes.push(vendorPrefixes[key].prefix);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (!prefixes.length) {\r\n\t\t\t\tprefixes = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn prefixes;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Search for a list of supported prefixes for CSS property. This list\r\n\t * is used to generate all-prefixed snippet\r\n\t * @param {String} property CSS property name\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction findInternalPrefixes(property, noAutofill) {\r\n\t\tvar result = [];\r\n\t\tvar prefixes = findVendorPrefixes(property);\r\n\t\t\r\n\t\tif (prefixes) {\r\n\t\t\tvar prefixMap = {};\r\n\t\t\tObject.keys(vendorPrefixes).forEach(function(key) {\r\n\t\t\t\tprefixMap[vendorPrefixes[key].prefix] = key;\r\n\t\t\t});\r\n\r\n\t\t\tresult = prefixes.map(function(prefix) {\r\n\t\t\t\treturn prefixMap[prefix];\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tif (!result.length && !noAutofill) {\r\n\t\t\t// add all non-obsolete prefixes\r\n\t\t\tObject.keys(vendorPrefixes).forEach(function(prefix) {\r\n\t\t\t\tif (!vendorPrefixes[prefix].obsolete) {\r\n\t\t\t\t\tresult.push(prefix);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tfunction addPrefix(name, obj) {\r\n\t\tif (typeof obj === 'string') {\r\n\t\t\tobj = {prefix: obj};\r\n\t\t}\r\n\t\t\r\n\t\tvendorPrefixes[name] = utils.extend({}, prefixObj, obj);\r\n\t}\r\n\t\r\n\tfunction getSyntaxPreference(name, syntax) {\r\n\t\tif (syntax) {\r\n\t\t\t// hacky alias for Stylus dialect\r\n\t\t\tif (syntax == 'styl') {\r\n\t\t\t\tsyntax = 'stylus';\r\n\t\t\t}\r\n\r\n\t\t\tvar val = prefs.get(syntax + '.' + name);\r\n\t\t\tif (typeof val !== 'undefined') {\r\n\t\t\t\treturn val;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn prefs.get('css.' + name);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Format CSS property according to current syntax dialect\r\n\t * @param {String} property\r\n\t * @param {String} syntax\r\n\t * @returns {String}\r\n\t */\r\n\tfunction formatProperty(property, syntax) {\r\n\t\tvar ix = property.indexOf(':');\r\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \r\n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\r\n\t\t\t+ utils.trim(property.substring(ix + 1));\r\n\t\t\r\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Transforms snippet value if required. For example, this transformation\r\n\t * may add <i>!important</i> declaration to CSS property\r\n\t * @param {String} snippet\r\n\t * @param {Boolean} isImportant\r\n\t * @returns {String}\r\n\t */\r\n\tfunction transformSnippet(snippet, isImportant, syntax) {\r\n\t\tif (typeof snippet !== 'string') {\r\n\t\t\tsnippet = snippet.data;\r\n\t\t}\r\n\t\t\r\n\t\tif (!isSingleProperty(snippet)) {\r\n\t\t\treturn snippet;\r\n\t\t}\r\n\t\t\r\n\t\tif (isImportant) {\r\n\t\t\tif (~snippet.indexOf(';')) {\r\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\r\n\t\t\t} else {\r\n\t\t\t\tsnippet += ' !important';\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn formatProperty(snippet, syntax);\r\n\t}\r\n\t\r\n\tfunction getProperties(key) {\r\n\t\tvar list = prefs.getArray(key);\r\n\t\tvar addon = prefs.getArray(key + 'Addon');\r\n\t\tif (addon) {\r\n\t\t\taddon.forEach(function(prop) {\r\n\t\t\t\tif (prop.charAt(0) == '-') {\r\n\t\t\t\t\tlist = utils.without(list, prop.substr(1));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (prop.charAt(0) == '+')\r\n\t\t\t\t\t\tprop = prop.substr(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.push(prop);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn list;\r\n\t}\r\n\r\n\t/**\r\n\t * Tries to produce properties with vendor-prefixed value\r\n\t * @param  {Object} snippetObj Parsed snippet object\r\n\t * @return {Array} Array of properties with prefixed values\r\n\t */\r\n\tfunction resolvePrefixedValues(snippetObj, isImportant, syntax) {\r\n\t\tvar prefixes = [];\r\n\t\tvar lookup = {};\r\n\r\n\t\tvar parts = cssEditTree.findParts(snippetObj.value);\r\n\t\tparts.reverse();\r\n\t\tparts.forEach(function(p) {\r\n\t\t\tvar partValue = p.substring(snippetObj.value);\r\n\t\t\t(findVendorPrefixes(partValue) || []).forEach(function(prefix) {\r\n\t\t\t\tif (!lookup[prefix]) {\r\n\t\t\t\t\tlookup[prefix] = snippetObj.value;\r\n\t\t\t\t\tprefixes.push(prefix);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlookup[prefix] = utils.replaceSubstring(lookup[prefix], '-' + prefix + '-' + partValue, p);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn prefixes.map(function(prefix) {\r\n\t\t\treturn transformSnippet(snippetObj.name + ':' + lookup[prefix], isImportant, syntax);\r\n\t\t});\r\n\t}\r\n\t\r\n\t\r\n\t// TODO refactor, this looks awkward now\r\n\taddPrefix('w', {\r\n\t\tprefix: 'webkit'\r\n\t});\r\n\taddPrefix('m', {\r\n\t\tprefix: 'moz'\r\n\t});\r\n\taddPrefix('s', {\r\n\t\tprefix: 'ms'\r\n\t});\r\n\taddPrefix('o', {\r\n\t\tprefix: 'o'\r\n\t});\r\n\t\r\n\t\r\n\tmodule = module || {};\r\n\tmodule.exports = {\r\n\t\t/**\r\n\t\t * Adds vendor prefix\r\n\t\t * @param {String} name One-character prefix name\r\n\t\t * @param {Object} obj Object describing vendor prefix\r\n\t\t * @memberOf cssResolver\r\n\t\t */\r\n\t\taddPrefix: addPrefix,\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed CSS property supports specified vendor prefix\r\n\t\t * @param {String} property\r\n\t\t * @param {String} prefix\r\n\t\t */\r\n\t\tsupportsPrefix: hasPrefix,\r\n\r\n\t\tresolve: function(node, syntax) {\r\n\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\r\n\t\t\tif (cssSyntaxes && ~cssSyntaxes.indexOf(syntax) && node.isElement()) {\r\n\t\t\t\treturn this.expandToSnippet(node.abbreviation, syntax);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns prefixed version of passed CSS property, only if this\r\n\t\t * property supports such prefix\r\n\t\t * @param {String} property\r\n\t\t * @param {String} prefix\r\n\t\t * @returns\r\n\t\t */\r\n\t\tprefixed: function(property, prefix) {\r\n\t\t\treturn hasPrefix(property, prefix) \r\n\t\t\t\t? '-' + prefix + '-' + property \r\n\t\t\t\t: property;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns list of all registered vendor prefixes\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlistPrefixes: function() {\r\n\t\t\treturn vendorPrefixes.map(function(obj) {\r\n\t\t\t\treturn obj.prefix;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns object describing vendor prefix\r\n\t\t * @param {String} name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetPrefix: function(name) {\r\n\t\t\treturn vendorPrefixes[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes prefix object\r\n\t\t * @param {String} name\r\n\t\t */\r\n\t\tremovePrefix: function(name) {\r\n\t\t\tif (name in vendorPrefixes)\r\n\t\t\t\tdelete vendorPrefixes[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extract vendor prefixes from abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {Object} Object containing array of prefixes and clean \r\n\t\t * abbreviation name\r\n\t\t */\r\n\t\textractPrefixes: function(abbr) {\r\n\t\t\tif (abbr.charAt(0) != '-') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproperty: abbr,\r\n\t\t\t\t\tprefixes: null\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\r\n\t\t\t// or just dash, meaning that user wants to produce all possible\r\n\t\t\t// prefixed properties\r\n\t\t\tvar i = 1, il = abbr.length, ch;\r\n\t\t\tvar prefixes = [];\r\n\t\t\t\r\n\t\t\twhile (i < il) {\r\n\t\t\t\tch = abbr.charAt(i);\r\n\t\t\t\tif (ch == '-') {\r\n\t\t\t\t\t// end-sequence character found, stop searching\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (ch in vendorPrefixes) {\r\n\t\t\t\t\tprefixes.push(ch);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// no prefix found, meaning user want to produce all\r\n\t\t\t\t\t// vendor-prefixed properties\r\n\t\t\t\t\tprefixes.length = 0;\r\n\t\t\t\t\ti = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reached end of abbreviation and no property name left\r\n\t\t\tif (i == il -1) {\r\n\t\t\t\ti = 1;\r\n\t\t\t\tprefixes.length = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\tproperty: abbr.substring(i),\r\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Search for value substring in abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {String} Value substring\r\n\t\t */\r\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\r\n\t\t\tsyntax = syntax || 'css';\r\n\t\t\t\r\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\r\n\t\t\twhile (i < il) {\r\n\t\t\t\tch = abbr.charAt(i);\r\n\t\t\t\tif (isNumeric(ch) || ch == '#' || ch == '$' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\r\n\t\t\t\t\tvalue = abbr.substring(i);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// try to find keywords in abbreviation\r\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\r\n\t\t\tvar keywords = [];\r\n\t\t\t// try to extract some commonly-used properties\r\n\t\t\twhile (~property.indexOf('-') && !resources.findSnippet(syntax, property)) {\r\n\t\t\t\tvar parts = property.split('-');\r\n\t\t\t\tvar lastPart = parts.pop();\r\n\t\t\t\tif (!isValidKeyword(lastPart)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tkeywords.unshift(lastPart);\r\n\t\t\t\tproperty = parts.join('-');\r\n\t\t\t}\r\n\r\n\t\t\treturn keywords.join('-') + value;\r\n\t\t},\r\n\t\t\r\n\t\tparseValues: function(str) {\r\n\t\t\t/** @type StringStream */\r\n\t\t\tvar stream = stringStream.create(str);\r\n\t\t\tvar values = [];\r\n\t\t\tvar ch = null;\r\n\t\t\t\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (ch == '$') {\r\n\t\t\t\t\tstream.match(/^[^\\$]+/, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t} else if (ch == '#') {\r\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+(\\.\\d+)?/i, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t} else if (ch == '-') {\r\n\t\t\t\t\tif (isValidKeyword(utils.last(values)) || \r\n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn values\r\n\t\t\t\t.filter(function(item) {\r\n\t\t\t\t\treturn !!item;\r\n\t\t\t\t})\r\n\t\t\t\t.map(normalizeValue);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts values from abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {Object} Object containing array of values and clean \r\n\t\t * abbreviation name\r\n\t\t */\r\n\t\textractValues: function(abbr) {\r\n\t\t\t// search for value start\r\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\r\n\t\t\tif (!abbrValues) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproperty: abbr,\r\n\t\t\t\t\tvalues: null\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\r\n\t\t\t\tvalues: this.parseValues(abbrValues)\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Normalizes value, defined in abbreviation.\r\n\t\t * @param {String} value\r\n\t\t * @param {String} property\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tnormalizeValue: function(value, property) {\r\n\t\t\tproperty = (property || '').toLowerCase();\r\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\r\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\r\n\t\t\t\tif (!unit && (val == '0' || ~unitlessProps.indexOf(property)))\r\n\t\t\t\t\treturn val;\r\n\t\t\t\t\r\n\t\t\t\tif (!unit)\r\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\r\n\t\t\t\t\r\n\t\t\t\treturn val + getUnit(unit);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Expands abbreviation into a snippet\r\n\t\t * @param {String} abbr Abbreviation name to expand\r\n\t\t * @param {String} value Abbreviation value\r\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\r\n\t\t * @returns {Object} Array of CSS properties and values or predefined\r\n\t\t * snippet (string or element)\r\n\t\t */\r\n\t\texpand: function(abbr, value, syntax) {\r\n\t\t\tsyntax = syntax || 'css';\r\n\t\t\tvar autoInsertPrefixes = prefs.get(syntax + '.autoInsertVendorPrefixes');\r\n\t\t\t\r\n\t\t\t// check if snippet should be transformed to !important\r\n\t\t\tvar isImportant = /^(.+)\\!$/.test(abbr);\r\n\t\t\tif (isImportant) {\r\n\t\t\t\tabbr = RegExp.$1;\r\n\t\t\t}\r\n\r\n\t\t\t// check if we have abbreviated resource\r\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\r\n\t\t\tif (snippet && !autoInsertPrefixes) {\r\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// no abbreviated resource, parse abbreviation\r\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\r\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\r\n\t\t\tvar abbrData = utils.extend(prefixData, valuesData);\r\n\r\n\t\t\tif (!snippet) {\r\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\r\n\t\t\t} else {\r\n\t\t\t\tabbrData.values = null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\r\n\t\t\t\t// let’s try fuzzy search\r\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!snippet) {\r\n\t\t\t\tif (!abbrData.property || abbrData.property.endsWith(':')) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\r\n\t\t\t} else if (typeof snippet !== 'string') {\r\n\t\t\t\tsnippet = snippet.data;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!isSingleProperty(snippet)) {\r\n\t\t\t\treturn snippet;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\r\n\t\t\tvar result = [];\r\n\t\t\tif (!value && abbrData.values) {\r\n\t\t\t\tvalue = abbrData.values.map(function(val) {\r\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\r\n\t\t\t\t}, this).join(' ') + ';';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsnippetObj.value = value || snippetObj.value;\r\n\r\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \r\n\t\t\t\t? findInternalPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\r\n\t\t\t\t: abbrData.prefixes;\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\tvar names = [], propName;\r\n\t\t\t(prefixes || []).forEach(function(p) {\r\n\t\t\t\tif (p in vendorPrefixes) {\r\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\r\n\t\t\t\t\tnames.push(propName);\r\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\r\n\t\t\t\t\t\t\tisImportant, syntax));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// put the original property\r\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\r\n\t\t\tnames.push(snippetObj.name);\r\n\r\n\t\t\tresult = resolvePrefixedValues(snippetObj, isImportant, syntax).concat(result);\r\n\t\t\t\r\n\t\t\tif (prefs.get('css.alignVendor')) {\r\n\t\t\t\tvar pads = utils.getStringsPads(names);\r\n\t\t\t\tresult = result.map(function(prop, i) {\r\n\t\t\t\t\treturn pads[i] + prop;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Same as <code>expand</code> method but transforms output into \r\n\t\t * Emmet snippet\r\n\t\t * @param {String} abbr\r\n\t\t * @param {String} syntax\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\texpandToSnippet: function(abbr, syntax) {\r\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\r\n\t\t\tif (snippet === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(snippet)) {\r\n\t\t\t\treturn snippet.join('\\n');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof snippet !== 'string') {\r\n\t\t\t\treturn snippet.data;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn snippet + '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Split snippet into a CSS property-value pair\r\n\t\t * @param {String} snippet\r\n\t\t */\r\n\t\tsplitSnippet: function(snippet) {\r\n\t\t\tsnippet = utils.trim(snippet);\r\n\t\t\tif (snippet.indexOf(':') == -1) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: snippet,\r\n\t\t\t\t\tvalue: defaultValue\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar pair = snippet.split(':');\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\tname: utils.trim(pair.shift()),\r\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\r\n\t\t\t\t// where possible\r\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\tgetSyntaxPreference: getSyntaxPreference,\r\n\t\ttransformSnippet: transformSnippet,\r\n\t\tvendorPrefixes: findVendorPrefixes\r\n\t};\r\n\r\n\treturn module.exports;\r\n});\r\n},{\"../assets/caniuse\":\"assets\\\\caniuse.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/template\":\"utils\\\\template.js\"}],\"resolver\\\\cssGradient.js\":[function(require,module,exports){\r\n/**\r\n * 'Expand Abbreviation' handler that parses gradient definition from under \r\n * cursor and updates CSS rule with vendor-prefixed values.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar resources = require('../assets/resources');\r\n\tvar utils = require('../utils/common');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar cssResolver = require('./css');\r\n\tvar range = require('../assets/range');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar linearGradient = require('./gradient/linear');\r\n\r\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\r\n\t\r\n\t// XXX define preferences\r\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\r\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \r\n\t\t\t+ 'be generated.');\r\n\t\r\n\tprefs.define('css.gradient.oldWebkit', false,\r\n\t\t\t'Generate gradient definition for old Webkit implementations');\r\n\t\r\n\tprefs.define('css.gradient.omitDefaultDirection', true,\r\n\t\t'Do not output default direction definition in generated gradients.');\r\n\t\r\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\r\n\t\t'When gradient expanded outside CSS value context, it will produce '\r\n\t\t\t+ 'properties with this name.');\r\n\t\r\n\tprefs.define('css.gradient.fallback', false,\r\n\t\t\t'With this option enabled, CSS gradient generator will produce '\r\n\t\t\t+ '<code>background-color</code> property with gradient first color '\r\n\t\t\t+ 'as fallback for old browsers.');\r\n\r\n\t/**\r\n\t * Resolves property name (abbreviation): searches for snippet definition in \r\n\t * 'resources' and returns new name of matched property\r\n\t */\r\n\tfunction resolvePropertyName(name, syntax) {\r\n\t\tvar snippet = resources.findSnippet(syntax, name);\r\n\t\t\r\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\r\n\t\t\tvar minScore = parseFloat(prefs.get('css.fuzzySearchMinScore'));\r\n\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, name, minScore);\r\n\t\t}\r\n\t\t\r\n\t\tif (snippet) {\r\n\t\t\tif (typeof snippet !== 'string') {\r\n\t\t\t\tsnippet = snippet.data;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn cssResolver.splitSnippet(snippet).name;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns vendor prefixes for given gradient type\r\n\t * @param {String} type Gradient type (currently, 'linear-gradient' \r\n\t * is the only supported value)\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getGradientPrefixes(type) {\r\n\t\tvar prefixes = cssResolver.vendorPrefixes(type);\r\n\t\tif (!prefixes) {\r\n\t\t\t// disabled Can I Use, fallback to property list\r\n\t\t\tprefixes = prefs.getArray('css.gradient.prefixes');\r\n\t\t}\r\n\r\n\t\treturn prefixes || [];\r\n\t}\r\n\t\r\n\tfunction getPrefixedNames(type) {\r\n\t\tvar prefixes = getGradientPrefixes(type);\r\n\t\tvar names = prefixes \r\n\t\t\t? prefixes.map(function(p) {\r\n\t\t\t\treturn '-' + p + '-' + type;\r\n\t\t\t}) \r\n\t\t\t: [];\r\n\t\t\r\n\t\tnames.push(type);\r\n\t\t\r\n\t\treturn names;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns list of CSS properties with gradient\r\n\t * @param {Array} gradient List of gradient objects\r\n\t * @param {CSSEditElement} property Original CSS property\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getPropertiesForGradient(gradients, property) {\r\n\t\tvar props = [];\r\n\t\tvar propertyName = property.name();\r\n\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\r\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\r\n\t\t\tprops.push({\r\n\t\t\t\tname: 'background-color',\r\n\t\t\t\tvalue: '${1:' + gradients[0].gradient.colorStops[0].color + '}'\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tvar value = property.value();\r\n\t\tgetGradientPrefixes('linear-gradient').forEach(function(prefix) {\r\n\t\t\tvar name = cssResolver.prefixed(propertyName, prefix);\r\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tprops.push({\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\t\t\t\t\tprefix: prefix, \r\n\t\t\t\t\t\t\toldWebkit: true,\r\n\t\t\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t} catch(e) {}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprops.push({\r\n\t\t\t\tname: name,\r\n\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\t\t\tprefix: prefix,\r\n\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t})\r\n\t\t\t});\r\n\t\t});\r\n\t\t\r\n\t\treturn props.sort(function(a, b) {\r\n\t\t\treturn b.name.length - a.name.length;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces old gradient definitions in given CSS property value\r\n\t * with new ones, preserving original formatting\r\n\t * @param  {Array} gradients List of CSS gradients\r\n\t * @param  {String} value     Original CSS value\r\n\t * @param  {Object} options   Options for gradient’s stringify() method\r\n\t * @return {String}\r\n\t */\r\n\tfunction insertGradientsIntoCSSValue(gradients, value, options) {\r\n\t\t// gradients *should* passed in order they actually appear in CSS property\r\n\t\t// iterate over it in backward direction to preserve gradient locations\r\n\t\toptions = options || {};\r\n\t\tgradients = utils.clone(gradients);\r\n\t\tgradients.reverse().forEach(function(item, i) {\r\n\t\t\tvar suffix = !i && options.placeholder ? options.placeholder : '';\r\n\t\t\tvar str = options.oldWebkit ? item.gradient.stringifyOldWebkit(options) : item.gradient.stringify(options);\r\n\t\t\tvalue = utils.replaceSubstring(value, str + suffix, item.matchedPart);\r\n\t\t});\r\n\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns list of properties with the same meaning \r\n\t * (e.g. vendor-prefixed + original name)\r\n\t * @param  {String} property CSS property name\r\n\t * @return {Array}\r\n\t */\r\n\tfunction similarPropertyNames(property) {\r\n\t\tif (typeof property !== 'string') {\r\n\t\t\tproperty = property.name();\r\n\t\t}\r\n\r\n\t\tvar similarProps = (cssResolver.vendorPrefixes(property) || []).map(function(prefix) {\r\n\t\t\treturn '-' + prefix + '-' + property;\r\n\t\t});\r\n\t\tsimilarProps.push(property);\r\n\t\treturn similarProps;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\r\n\t * @param {EditElement} property Matched CSS property\r\n\t * @param {Array} gradients List of gradients to insert\r\n\t */\r\n\tfunction pasteGradient(property, gradients) {\r\n\t\tvar rule = property.parent;\r\n\t\tvar alignVendor = prefs.get('css.alignVendor');\r\n\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\r\n\t\t// we may have aligned gradient definitions: find the smallest value\r\n\t\t// separator\r\n\t\tvar sep = property.styleSeparator;\r\n\t\tvar before = property.styleBefore;\r\n\t\t\r\n\t\t// first, remove all properties within CSS rule with the same name and\r\n\t\t// gradient definition\r\n\t\trule.getAll(similarPropertyNames(property)).forEach(function(item) {\r\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\r\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\r\n\t\t\t\t\tsep = item.styleSeparator;\r\n\t\t\t\t}\r\n\t\t\t\tif (item.styleBefore.length < before.length) {\r\n\t\t\t\t\tbefore = item.styleBefore;\r\n\t\t\t\t}\r\n\t\t\t\trule.remove(item);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (alignVendor) {\r\n\t\t\t// update prefix\r\n\t\t\tif (before != property.styleBefore) {\r\n\t\t\t\tvar fullRange = property.fullRange();\r\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\r\n\t\t\t\tproperty.styleBefore = before;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// update separator value\r\n\t\t\tif (sep != property.styleSeparator) {\r\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\r\n\t\t\t\tproperty.styleSeparator = sep;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar value = property.value();\r\n\r\n\t\t// create list of properties to insert\r\n\t\tvar propsToInsert = getPropertiesForGradient(gradients, property);\r\n\t\t\r\n\t\t// align prefixed values\r\n\t\tif (alignVendor) {\r\n\t\t\tvar names = [], values = [];\r\n\t\t\tpropsToInsert.forEach(function(item) {\r\n\t\t\t\tnames.push(item.name);\r\n\t\t\t\tvalues.push(item.value);\r\n\t\t\t});\r\n\t\t\tvalues.push(property.value());\r\n\t\t\tnames.push(property.name());\r\n\t\t\t\r\n\t\t\tvar valuePads = utils.getStringsPads(values.map(function(v) {\r\n\t\t\t\treturn v.substring(0, v.indexOf('('));\r\n\t\t\t}));\r\n\t\t\t\r\n\t\t\tvar namePads = utils.getStringsPads(names);\r\n\t\t\tproperty.name(namePads[namePads.length - 1] + property.name());\r\n\t\t\t\r\n\t\t\tpropsToInsert.forEach(function(prop, i) {\r\n\t\t\t\tprop.name = namePads[i] + prop.name;\r\n\t\t\t\tprop.value = valuePads[i] + prop.value;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tproperty.value(valuePads[valuePads.length - 1] + property.value());\r\n\t\t}\r\n\t\t\r\n\t\t// put vendor-prefixed definitions before current rule\r\n\t\tpropsToInsert.forEach(function(prop) {\r\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\r\n\t\t});\r\n\r\n\t\t// put vanilla-clean gradient definition into current rule\r\n\t\tproperty.value(insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\tplaceholder: '${2}',\r\n\t\t\tomitDefaultDirection: omitDir\r\n\t\t}));\r\n\t}\r\n\r\n\t/**\r\n\t * Validates caret position relatively to located gradients\r\n\t * in CSS rule. In other words, it checks if it’s safe to \r\n\t * expand gradients for current caret position or not.\r\n\t * \r\n\t * See issue https://github.com/sergeche/emmet-sublime/issues/411\r\n\t * \r\n\t * @param  {Array} gradients List of parsed gradients\r\n\t * @param  {Number} caretPos  Current caret position\r\n\t * @param  {String} syntax    Current document syntax\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction isValidCaretPosition(gradients, caretPos, syntax) {\r\n\t\tsyntax = syntax || 'css';\r\n\t\tif (syntax == 'css' || syntax == 'less' || syntax == 'scss') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tvar offset = gradients.property.valueRange(true).start;\r\n\t\tvar parts = gradients.gradients;\r\n\r\n\t\t// in case of preprocessors where properties are separated with\r\n\t\t// newlines, make sure there’s no gradient definition past\r\n\t\t// current caret position. \r\n\t\tfor (var i = parts.length - 1; i >= 0; i--) {\r\n\t\t\tif (parts[i].matchedPart.start + offset >= caretPos) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tmodule = module || {};\r\n\treturn module.exports = {\r\n\t\t/**\r\n\t\t * Search for gradient definitions inside CSS property value\r\n\t\t * @returns {Array} Array of matched gradients\r\n\t\t */\r\n\t\tfindGradients: function(cssProp) {\r\n\t\t\tvar value = cssProp.value();\r\n\t\t\tvar gradients = [];\r\n\t\t\tvar that = this;\r\n\t\t\tcssProp.valueParts().forEach(function(part) {\r\n\t\t\t\tvar partValue = part.substring(value);\r\n\t\t\t\tif (linearGradient.isLinearGradient(partValue)) {\r\n\t\t\t\t\tvar gradient = linearGradient.parse(partValue);\r\n\t\t\t\t\tif (gradient) {\r\n\t\t\t\t\t\tgradients.push({\r\n\t\t\t\t\t\t\tgradient: gradient,\r\n\t\t\t\t\t\t\tmatchedPart: part\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn gradients.length ? gradients : null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns list of gradients found in CSS property\r\n\t\t * of given CSS code in specified (caret) position\r\n\t\t * @param  {String} css CSS code snippet\r\n\t\t * @param  {Number} pos Character index where to start searching for CSS property\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tgradientsFromCSSProperty: function(css, pos) {\r\n\t\t\tvar cssProp = cssEditTree.propertyFromPosition(css, pos);\r\n\t\t\tif (cssProp) {\r\n\t\t\t\tvar grd = this.findGradients(cssProp);\r\n\t\t\t\tif (grd) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tproperty: cssProp,\r\n\t\t\t\t\t\tgradients: grd\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Handler for “Expand Abbreviation” action\r\n\t\t * @param  {IEmmetEditor} editor\r\n\t\t * @param  {String} syntax\r\n\t\t * @param  {String} profile\r\n\t\t * return {Boolean}\r\n\t\t */\r\n\t\texpandAbbreviationHandler: function(editor, syntax, profile) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\r\n\t\t\tif (!~cssSyntaxes.indexOf(info.syntax)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// let's see if we are expanding gradient definition\r\n\t\t\tvar caret = editor.getCaretPos();\r\n\t\t\tvar content = info.content;\r\n\t\t\tvar gradients = this.gradientsFromCSSProperty(content, caret);\r\n\t\t\tif (gradients) {\r\n\t\t\t\tif (!isValidCaretPosition(gradients, caret, info.syntax)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar cssProperty = gradients.property;\r\n\t\t\t\tvar cssRule = cssProperty.parent;\r\n\t\t\t\tvar ruleStart = cssRule.options.offset || 0;\r\n\t\t\t\tvar ruleEnd = ruleStart + cssRule.toString().length;\r\n\t\t\t\t\r\n\t\t\t\t// Handle special case:\r\n\t\t\t\t// user wrote gradient definition between existing CSS \r\n\t\t\t\t// properties and did not finished it with semicolon.\r\n\t\t\t\t// In this case, we have semicolon right after gradient \r\n\t\t\t\t// definition and re-parse rule again\r\n\t\t\t\tif (/[\\n\\r]/.test(cssProperty.value())) {\r\n\t\t\t\t\t// insert semicolon at the end of gradient definition\r\n\t\t\t\t\tvar insertPos = cssProperty.valueRange(true).start + utils.last(gradients.gradients).matchedPart.end;\r\n\t\t\t\t\tcontent = utils.replaceSubstring(content, ';', insertPos);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar _gradients = this.gradientsFromCSSProperty(content, caret);\r\n\t\t\t\t\tif (_gradients) {\r\n\t\t\t\t\t\tgradients = _gradients;\r\n\t\t\t\t\t\tcssProperty = gradients.property;\r\n\t\t\t\t\t\tcssRule = cssProperty.parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// make sure current property has terminating semicolon\r\n\t\t\t\tcssProperty.end(';');\r\n\t\t\t\t\r\n\t\t\t\t// resolve CSS property name\r\n\t\t\t\tvar resolvedName = resolvePropertyName(cssProperty.name(), syntax);\r\n\t\t\t\tif (resolvedName) {\r\n\t\t\t\t\tcssProperty.name(resolvedName);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tpasteGradient(cssProperty, gradients.gradients);\r\n\t\t\t\teditor.replaceContent(cssRule.toString(), ruleStart, ruleEnd, true);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this.expandGradientOutsideValue(editor, syntax);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Tries to expand gradient outside CSS value \r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {String} syntax\r\n\t\t */\r\n\t\texpandGradientOutsideValue: function(editor, syntax) {\r\n\t\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\r\n\t\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\t\r\n\t\t\tif (!propertyName) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// assuming that gradient definition is written on new line,\r\n\t\t\t// do a simplified parsing\r\n\t\t\tvar content = String(editor.getContent());\r\n\t\t\t/** @type Range */\r\n\t\t\tvar lineRange = range.create(editor.getCurrentLineRange());\r\n\t\t\t\r\n\t\t\t// get line content and adjust range with padding\r\n\t\t\tvar line = lineRange.substring(content)\r\n\t\t\t\t.replace(/^\\s+/, function(pad) {\r\n\t\t\t\t\tlineRange.start += pad.length;\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t})\r\n\t\t\t\t.replace(/\\s+$/, function(pad) {\r\n\t\t\t\t\tlineRange.end -= pad.length;\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t});\r\n\r\n\t\t\t// trick parser: make it think that we’re parsing actual CSS property\r\n\t\t\tvar fakeCSS = 'a{' + propertyName + ': ' + line + ';}';\r\n\t\t\tvar gradients = this.gradientsFromCSSProperty(fakeCSS, fakeCSS.length - 2);\r\n\t\t\tif (gradients) {\r\n\t\t\t\tvar props = getPropertiesForGradient(gradients.gradients, gradients.property);\r\n\t\t\t\tprops.push({\r\n\t\t\t\t\tname: gradients.property.name(),\r\n\t\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients.gradients, gradients.property.value(), {\r\n\t\t\t\t\t\tplaceholder: '${2}',\r\n\t\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tvar sep = cssResolver.getSyntaxPreference('valueSeparator', syntax);\r\n\t\t\t\tvar end = cssResolver.getSyntaxPreference('propertyEnd', syntax);\r\n\t\t\t\t\r\n\t\t\t\tif (prefs.get('css.alignVendor')) {\r\n\t\t\t\t\tvar pads = utils.getStringsPads(props.map(function(prop) {\r\n\t\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\r\n\t\t\t\t\t}));\r\n\t\t\t\t\tprops.forEach(function(prop, i) {\r\n\t\t\t\t\t\tprop.value = pads[i] + prop.value;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tprops = props.map(function(item) {\r\n\t\t\t\t\treturn item.name + sep + item.value + end;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Handler for “Reflect CSS Value“ action\r\n\t\t * @param  {String} property\r\n\t\t */\r\n\t\treflectValueHandler: function(property) {\r\n\t\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\tvar gradients = this.findGradients(property);\r\n\t\t\tif (!gradients) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar that = this;\r\n\t\t\tvar value = property.value();\r\n\t\t\t\r\n\t\t\t// reflect value for properties with the same name\r\n\t\t\tproperty.parent.getAll(similarPropertyNames(property)).forEach(function(prop) {\r\n\t\t\t\tif (prop === property) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// make sure current property contains gradient definition,\r\n\t\t\t\t// otherwise – skip it\r\n\t\t\t\tvar localGradients = that.findGradients(prop);\r\n\t\t\t\tif (localGradients) {\r\n\t\t\t\t\t// detect vendor prefix for current property\r\n\t\t\t\t\tvar localValue = prop.value();\r\n\t\t\t\t\tvar dfn = localGradients[0].matchedPart.substring(localValue);\r\n\t\t\t\t\tvar prefix = '';\r\n\t\t\t\t\tif (/^\\s*\\-([a-z]+)\\-/.test(dfn)) {\r\n\t\t\t\t\t\tprefix = RegExp.$1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tprop.value(insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\t\t\t\tprefix: prefix,\r\n\t\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\",\"./css\":\"resolver\\\\css.js\",\"./gradient/linear\":\"resolver\\\\gradient\\\\linear.js\"}],\"resolver\\\\gradient\\\\linear.js\":[function(require,module,exports){\r\n/**\r\n * CSS linear gradient definition\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar stringStream = require('../../assets/stringStream');\r\n\tvar utils = require('../../utils/common');\r\n\r\n\t// all directions are expressed in “new style” degrees\r\n\tvar directions = {\r\n\t\t'bottom': 0,\r\n\t\t'bottom left': 45,\r\n\t\t'left': 90,\r\n\t\t'top left': 135,\r\n\t\t'top': 180,\r\n\t\t'top right': 225,\r\n\t\t'right': 270,\r\n\t\t'bottom right': 315,\r\n\t\t\r\n\t\t'to top': 0,\r\n\t\t'to top right': 45,\r\n\t\t'to right': 90,\r\n\t\t'to bottom right': 135,\r\n\t\t'to bottom': 180,\r\n\t\t'to bottom left': 225,\r\n\t\t'to left': 270,\r\n\t\t'to top left': 315\r\n\t};\r\n\r\n\tvar defaultDirections = ['top', 'to bottom', '0deg'];\r\n\r\n\r\n\tvar reLinearGradient = /^\\s*(\\-[a-z]+\\-)?(lg|linear\\-gradient)\\s*\\(/i;\r\n\tvar reDeg = /(\\d+)deg/i;\r\n\tvar reKeyword = /top|bottom|left|right/i;\r\n\r\n\tfunction LinearGradient(dfn) {\r\n\t\tthis.colorStops = [];\r\n\t\tthis.direction = 180;\r\n\r\n\t\t// extract tokens\r\n\t\tvar stream = stringStream.create(utils.trim(dfn));\r\n\t\tvar ch, cur;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (stream.peek() == ',') {\r\n\t\t\t\t// Is it a first entry? Check if it’s a direction\r\n\t\t\t\tcur = stream.current();\r\n\r\n\t\t\t\tif (!this.colorStops.length && (reDeg.test(cur) || reKeyword.test(cur))) {\r\n\t\t\t\t\tthis.direction = resolveDirection(cur);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addColorStop(cur);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstream.next();\r\n\t\t\t\tstream.eatSpace();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\r\n\t\t\t\tstream.skipTo(')');\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// add last token\r\n\t\tthis.addColorStop(stream.current());\t\t\r\n\t}\r\n\r\n\tLinearGradient.prototype = {\r\n\t\ttype: 'linear-gradient',\r\n\t\taddColorStop: function(color, ix) {\r\n\t\t\tcolor = normalizeSpace(color || '');\r\n\t\t\tif (!color) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tcolor = this.parseColorStop(color);\r\n\r\n\t\t\tif (typeof ix === 'undefined') {\r\n\t\t\t\tthis.colorStops.push(color);\r\n\t\t\t} else {\r\n\t\t\t\tthis.colorStops.splice(ix, 0, color);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses color stop definition\r\n\t\t * @param {String} colorStop\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tparseColorStop: function(colorStop) {\r\n\t\t\tcolorStop = normalizeSpace(colorStop);\r\n\t\t\t\r\n\t\t\t// find color declaration\r\n\t\t\t// first, try complex color declaration, like rgb(0,0,0)\r\n\t\t\tvar color = null;\r\n\t\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\r\n\t\t\t\tcolor = c;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (!color) {\r\n\t\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\r\n\t\t\t\tvar parts = colorStop.split(' ');\r\n\t\t\t\tcolor = parts[0];\r\n\t\t\t\tcolorStop = parts[1] || '';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar result = {\r\n\t\t\t\tcolor: color\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (colorStop) {\r\n\t\t\t\t// there's position in color stop definition\r\n\t\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\r\n\t\t\t\t\tresult.position = pos;\r\n\t\t\t\t\tif (~pos.indexOf('.')) {\r\n\t\t\t\t\t\tunit = '';\r\n\t\t\t\t\t} else if (!unit) {\r\n\t\t\t\t\t\tunit = '%';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (unit) {\r\n\t\t\t\t\t\tresult.unit = unit;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\tstringify: function(options) {\r\n\t\t\toptions = options || {};\r\n\t\t\tvar fn = 'linear-gradient';\r\n\t\t\tif (options.prefix) {\r\n\t\t\t\tfn = '-' + options.prefix + '-' + fn;\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\t// transform color-stops\r\n\t\t\tvar parts = this.colorStops.map(function(cs) {\r\n\t\t\t\tvar pos = cs.position ? ' ' + cs.position + (cs.unit || '') : '';\r\n\t\t\t\treturn cs.color + pos;\r\n\t\t\t});\r\n\r\n\t\t\tvar dir = stringifyDirection(this.direction, !!options.prefix);\r\n\t\t\tif (!options.omitDefaultDirection || !~defaultDirections.indexOf(dir)) {\r\n\t\t\t\tparts.unshift(dir);\r\n\t\t\t}\r\n\r\n\t\t\treturn fn + '(' + parts.join(', ') + ')';\r\n\t\t},\r\n\r\n\t\tstringifyOldWebkit: function() {\r\n\t\t\tvar colorStops = this.colorStops.map(function(item) {\r\n\t\t\t\treturn utils.clone(item);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// normalize color-stops position\r\n\t\t\tcolorStops.forEach(function(cs) {\r\n\t\t\t\tif (!('position' in cs)) // implied position\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\r\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tthis._fillImpliedPositions(colorStops);\r\n\t\t\t\r\n\t\t\t// transform color-stops into string representation\r\n\t\t\tcolorStops = colorStops.map(function(cs, i) {\r\n\t\t\t\tif (!cs.position && !i) {\r\n\t\t\t\t\treturn 'from(' + cs.color + ')';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1) {\r\n\t\t\t\t\treturn 'to(' + cs.color + ')';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn '-webkit-gradient(linear, ' \r\n\t\t\t\t+ oldWebkitDirection((this.direction + 180) % 360)\r\n\t\t\t\t+ ', '\r\n\t\t\t\t+ colorStops.join(', ')\r\n\t\t\t\t+ ')';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Fills-out implied positions in color-stops. This function is useful for\r\n\t\t * old Webkit gradient definitions\r\n\t\t */\r\n\t\t_fillImpliedPositions: function(colorStops) {\r\n\t\t\tvar from = 0;\r\n\t\t\t\r\n\t\t\tcolorStops.forEach(function(cs, i) {\r\n\t\t\t\t// make sure that first and last positions are defined\r\n\t\t\t\tif (!i) {\r\n\t\t\t\t\treturn cs.position = cs.position || 0;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (i == colorStops.length - 1 && !('position' in cs)) {\r\n\t\t\t\t\tcs.position = 1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif ('position' in cs) {\r\n\t\t\t\t\tvar start = colorStops[from].position || 0;\r\n\t\t\t\t\tvar step = (cs.position - start) / (i - from);\r\n\t\t\t\t\tcolorStops.slice(from, i).forEach(function(cs2, j) {\r\n\t\t\t\t\t\tcs2.position = start + step * j;\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\tfrom = i;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.stringify();\r\n\t\t}\r\n\t};\r\n\r\n\tfunction normalizeSpace(str) {\r\n\t\treturn utils.trim(str).replace(/\\s+/g, ' ');\r\n\t}\r\n\r\n\t/**\r\n\t * Resolves textual direction to degrees\r\n\t * @param  {String} dir Direction to resolve\r\n\t * @return {Number}\r\n\t */\r\n\tfunction resolveDirection(dir) {\r\n\t\tif (typeof dir == 'number') {\r\n\t\t\treturn dir;\r\n\t\t}\r\n\r\n\t\tdir = normalizeSpace(dir).toLowerCase();\r\n\t\tif (reDeg.test(dir)) {\r\n\t\t\treturn +RegExp.$1;\r\n\t\t}\r\n\r\n\t\tvar prefix = /^to\\s/.test(dir) ? 'to ' : '';\r\n\t\tvar left   = ~dir.indexOf('left')   && 'left';\r\n\t\tvar right  = ~dir.indexOf('right')  && 'right';\r\n\t\tvar top    = ~dir.indexOf('top')    && 'top';\r\n\t\tvar bottom = ~dir.indexOf('bottom') && 'bottom';\r\n\r\n\t\tvar key = normalizeSpace(prefix + (top || bottom || '') + ' ' + (left || right || ''));\r\n\t\treturn directions[key] || 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Tries to find keyword for given direction, expressed in degrees\r\n\t * @param  {Number} dir Direction (degrees)\r\n\t * @param {Boolean} oldStyle Use old style keywords (e.g. \"top\" instead of \"to bottom\")\r\n\t * @return {String}     Keyword or <code>Ndeg</code> expression\r\n\t */\r\n\tfunction stringifyDirection(dir, oldStyle) {\r\n\t\tvar reNewStyle = /^to\\s/;\r\n\t\tvar keys = Object.keys(directions).filter(function(k) {\r\n\t\t\tvar hasPrefix = reNewStyle.test(k);\r\n\t\t\treturn oldStyle ? !hasPrefix : hasPrefix;\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tif (directions[keys[i]] == dir) {\r\n\t\t\t\treturn keys[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (oldStyle) {\r\n\t\t\tdir = (dir + 270) % 360;\r\n\t\t}\r\n\r\n\t\treturn dir + 'deg';\r\n\t}\r\n\r\n\t/**\r\n\t * Creates direction definition for old Webkit gradients\r\n\t * @param {String} direction\r\n\t * @returns {String}\r\n\t */\r\n\tfunction oldWebkitDirection(dir) {\r\n\t\tdir = stringifyDirection(dir, true);\r\n\t\t\r\n\t\tif(reDeg.test(dir)) {\r\n\t\t\tthrow \"The direction is an angle that can’t be converted.\";\r\n\t\t}\r\n\t\t\r\n\t\tvar v = function(pos) {\r\n\t\t\treturn ~dir.indexOf(pos) ? '100%' : '0';\r\n\t\t};\r\n\t\t\r\n\t\treturn v('left') + ' ' + v('top') + ', ' + v('right') + ' ' + v('bottom');\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Parses gradient definition into an object.\r\n\t\t * This object can be used to transform gradient into various\r\n\t\t * forms\r\n\t\t * @param  {String} gradient Gradient definition\r\n\t\t * @return {LinearGradient}\r\n\t\t */\r\n\t\tparse: function(gradient) {\r\n\t\t\t// cut out all redundant data\r\n\t\t\tif (this.isLinearGradient(gradient)) {\r\n\t\t\t\tgradient = gradient.replace(/^\\s*[\\-a-z]+\\s*\\(|\\)\\s*$/ig, '');\r\n\t\t\t} else {\r\n\t\t\t\tthrow 'Invalid linear gradient definition:\\n' + gradient;\r\n\t\t\t}\r\n\r\n\t\t\treturn new LinearGradient(gradient);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if given string can be parsed as linear gradient\r\n\t\t * @param  {String}  str\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisLinearGradient: function(str) {\r\n\t\t\treturn reLinearGradient.test(str);\r\n\t\t},\r\n\r\n\t\tresolveDirection: resolveDirection,\r\n\t\tstringifyDirection: stringifyDirection\r\n\t};\r\n});\r\n},{\"../../assets/stringStream\":\"assets\\\\stringStream.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"resolver\\\\tagName.js\":[function(require,module,exports){\r\n/**\r\n * Module for resolving tag names: returns best matched tag name for child\r\n * element based on passed parent's tag name. Also provides utility function\r\n * for element type detection (inline, block-level, empty)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\t\r\n\tvar elementTypes = {\r\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\r\n\t\tempty: [],\r\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\r\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\r\n\t};\r\n\t\r\n\tvar elementMap = {\r\n\t\t'p': 'span',\r\n\t\t'ul': 'li',\r\n\t\t'ol': 'li',\r\n\t\t'table': 'tr',\r\n\t\t'tr': 'td',\r\n\t\t'tbody': 'tr',\r\n\t\t'thead': 'tr',\r\n\t\t'tfoot': 'tr',\r\n\t\t'colgroup': 'col',\r\n\t\t'select': 'option',\r\n\t\t'optgroup': 'option',\r\n\t\t'audio': 'source',\r\n\t\t'video': 'source',\r\n\t\t'object': 'param',\r\n\t\t'map': 'area'\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Returns best matched child element name for passed parent's\r\n\t\t * tag name\r\n\t\t * @param {String} name\r\n\t\t * @returns {String}\r\n\t\t * @memberOf tagName\r\n\t\t */\r\n\t\tresolve: function(name) {\r\n\t\t\tname = (name || '').toLowerCase();\r\n\t\t\t\r\n\t\t\tif (name in elementMap)\r\n\t\t\t\treturn this.getMapping(name);\r\n\t\t\t\r\n\t\t\tif (this.isInlineLevel(name))\r\n\t\t\t\treturn 'span';\r\n\t\t\t\r\n\t\t\treturn 'div';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns mapped child element name for passed parent's name \r\n\t\t * @param {String} name\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetMapping: function(name) {\r\n\t\t\treturn elementMap[name.toLowerCase()];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element name belongs to inline-level element\r\n\t\t * @param {String} name\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisInlineLevel: function(name) {\r\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element belongs to block-level element.\r\n\t\t * For better matching of unknown elements (for XML, for example), \r\n\t\t * you should use <code>!this.isInlineLevel(name)</code>\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisBlockLevel: function(name) {\r\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element is void (i.e. should not have closing tag).\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisEmptyElement: function(name) {\r\n\t\t\treturn this.isTypeOf(name, 'empty');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Generic function for testing if element name belongs to specified\r\n\t\t * elements collection\r\n\t\t * @param {String} name Element name\r\n\t\t * @param {String} type Collection name\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisTypeOf: function(name, type) {\r\n\t\t\treturn ~elementTypes[type].indexOf(name);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new parent–child mapping\r\n\t\t * @param {String} parent\r\n\t\t * @param {String} child\r\n\t\t */\r\n\t\taddMapping: function(parent, child) {\r\n\t\t\telementMap[parent] = child;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes parent-child mapping\r\n\t\t */\r\n\t\tremoveMapping: function(parent) {\r\n\t\t\tif (parent in elementMap)\r\n\t\t\t\tdelete elementMap[parent];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new element into collection\r\n\t\t * @param {String} name Element name\r\n\t\t * @param {String} collection Collection name\r\n\t\t */\r\n\t\taddElementToCollection: function(name, collection) {\r\n\t\t\tif (!elementTypes[collection])\r\n\t\t\t\telementTypes[collection] = [];\r\n\t\t\t\r\n\t\t\tvar col = this.getCollection(collection);\r\n\t\t\tif (!~col.indexOf(name)) {\r\n\t\t\t\tcol.push(name);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes element name from specified collection\r\n\t\t * @param {String} name Element name\r\n\t\t * @param {String} collection Collection name\r\n\t\t * @returns\r\n\t\t */\r\n\t\tremoveElementFromCollection: function(name, collection) {\r\n\t\t\tif (collection in elementTypes) {\r\n\t\t\t\telementTypes[collection] = utils.without(this.getCollection(collection), name);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns elements name collection\r\n\t\t * @param {String} name Collection name\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetCollection: function(name) {\r\n\t\t\treturn elementTypes[name];\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"snippets.json\":[function(require,module,exports){\r\nmodule.exports={\r\n\t\"variables\": {\r\n\t\t\"lang\": \"en\",\r\n\t\t\"locale\": \"en-US\",\r\n\t\t\"charset\": \"UTF-8\",\r\n\t\t\"indentation\": \"\\t\",\r\n\t\t\"newline\": \"\\n\"\r\n\t},\r\n\t\r\n\t\"css\": {\r\n\t\t\"filters\": \"css\",\r\n\t\t\"profile\": \"css\",\r\n\t\t\"snippets\": {\r\n\t\t\t\"@i\": \"@import url(|);\",\r\n\t\t\t\"@import\": \"@import url(|);\",\r\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\r\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\r\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\r\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\r\n\r\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\r\n\r\n\t\t\t\"anim\": \"animation:|;\",\r\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\r\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\r\n\t\t\t\r\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\r\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\r\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\r\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\r\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\r\n\t\t\t\r\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\r\n\t\t\t\r\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\r\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\r\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\r\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\r\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\r\n\t\t\t\r\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\r\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\r\n\t\t\t\r\n\t\t\t\"animn\": \"animation-name:${1:none};\",\r\n\r\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\r\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\r\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\r\n\r\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\r\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\r\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\r\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\r\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\r\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\r\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\r\n\t\t\t\r\n\t\t\t\"ap\": \"appearance:${none};\",\r\n\r\n\t\t\t\"!\": \"!important\",\r\n\t\t\t\"pos\": \"position:${1:relative};\",\r\n\t\t\t\"pos:s\": \"position:static;\",\r\n\t\t\t\"pos:a\": \"position:absolute;\",\r\n\t\t\t\"pos:r\": \"position:relative;\",\r\n\t\t\t\"pos:f\": \"position:fixed;\",\r\n\t\t\t\"t\": \"top:|;\",\r\n\t\t\t\"t:a\": \"top:auto;\",\r\n\t\t\t\"r\": \"right:|;\",\r\n\t\t\t\"r:a\": \"right:auto;\",\r\n\t\t\t\"b\": \"bottom:|;\",\r\n\t\t\t\"b:a\": \"bottom:auto;\",\r\n\t\t\t\"l\": \"left:|;\",\r\n\t\t\t\"l:a\": \"left:auto;\",\r\n\t\t\t\"z\": \"z-index:|;\",\r\n\t\t\t\"z:a\": \"z-index:auto;\",\r\n\t\t\t\"fl\": \"float:${1:left};\",\r\n\t\t\t\"fl:n\": \"float:none;\",\r\n\t\t\t\"fl:l\": \"float:left;\",\r\n\t\t\t\"fl:r\": \"float:right;\",\r\n\t\t\t\"cl\": \"clear:${1:both};\",\r\n\t\t\t\"cl:n\": \"clear:none;\",\r\n\t\t\t\"cl:l\": \"clear:left;\",\r\n\t\t\t\"cl:r\": \"clear:right;\",\r\n\t\t\t\"cl:b\": \"clear:both;\",\r\n\r\n\t\t\t\"colm\": \"columns:|;\",\r\n\t\t\t\"colmc\": \"column-count:|;\",\r\n\t\t\t\"colmf\": \"column-fill:|;\",\r\n\t\t\t\"colmg\": \"column-gap:|;\",\r\n\t\t\t\"colmr\": \"column-rule:|;\",\r\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\r\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\r\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\r\n\t\t\t\"colms\": \"column-span:|;\",\r\n\t\t\t\"colmw\": \"column-width:|;\",\r\n\r\n\t\t\t\"d\": \"display:${1:block};\",\r\n\t\t\t\"d:n\": \"display:none;\",\r\n\t\t\t\"d:b\": \"display:block;\",\r\n\t\t\t\"d:f\": \"display:flex;\",\r\n\t\t\t\"d:if\": \"display:inline-flex;\",\r\n\t\t\t\"d:i\": \"display:inline;\",\r\n\t\t\t\"d:ib\": \"display:inline-block;\",\r\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\r\n\t\t\t\"d:li\": \"display:list-item;\",\r\n\t\t\t\"d:ri\": \"display:run-in;\",\r\n\t\t\t\"d:cp\": \"display:compact;\",\r\n\t\t\t\"d:tb\": \"display:table;\",\r\n\t\t\t\"d:itb\": \"display:inline-table;\",\r\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\r\n\t\t\t\"d:tbcl\": \"display:table-column;\",\r\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\r\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\r\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\r\n\t\t\t\"d:tbr\": \"display:table-row;\",\r\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\r\n\t\t\t\"d:tbc\": \"display:table-cell;\",\r\n\t\t\t\"d:rb\": \"display:ruby;\",\r\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\r\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\r\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\r\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\r\n\t\t\t\"v\": \"visibility:${1:hidden};\",\r\n\t\t\t\"v:v\": \"visibility:visible;\",\r\n\t\t\t\"v:h\": \"visibility:hidden;\",\r\n\t\t\t\"v:c\": \"visibility:collapse;\",\r\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\r\n\t\t\t\"ov:v\": \"overflow:visible;\",\r\n\t\t\t\"ov:h\": \"overflow:hidden;\",\r\n\t\t\t\"ov:s\": \"overflow:scroll;\",\r\n\t\t\t\"ov:a\": \"overflow:auto;\",\r\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\r\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\r\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\r\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\r\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\r\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\r\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\r\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\r\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\r\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\r\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\r\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\r\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\r\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\r\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\r\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\r\n\t\t\t\"zoo\": \"zoom:1;\",\r\n\t\t\t\"zm\": \"zoom:1;\",\r\n\t\t\t\"cp\": \"clip:|;\",\r\n\t\t\t\"cp:a\": \"clip:auto;\",\r\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\r\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\r\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\r\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\r\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\r\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\r\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\r\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\r\n\t\t\t\"m\": \"margin:|;\",\r\n\t\t\t\"m:a\": \"margin:auto;\",\r\n\t\t\t\"mt\": \"margin-top:|;\",\r\n\t\t\t\"mt:a\": \"margin-top:auto;\",\r\n\t\t\t\"mr\": \"margin-right:|;\",\r\n\t\t\t\"mr:a\": \"margin-right:auto;\",\r\n\t\t\t\"mb\": \"margin-bottom:|;\",\r\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\r\n\t\t\t\"ml\": \"margin-left:|;\",\r\n\t\t\t\"ml:a\": \"margin-left:auto;\",\r\n\t\t\t\"p\": \"padding:|;\",\r\n\t\t\t\"pt\": \"padding-top:|;\",\r\n\t\t\t\"pr\": \"padding-right:|;\",\r\n\t\t\t\"pb\": \"padding-bottom:|;\",\r\n\t\t\t\"pl\": \"padding-left:|;\",\r\n\t\t\t\"w\": \"width:|;\",\r\n\t\t\t\"w:a\": \"width:auto;\",\r\n\t\t\t\"h\": \"height:|;\",\r\n\t\t\t\"h:a\": \"height:auto;\",\r\n\t\t\t\"maw\": \"max-width:|;\",\r\n\t\t\t\"maw:n\": \"max-width:none;\",\r\n\t\t\t\"mah\": \"max-height:|;\",\r\n\t\t\t\"mah:n\": \"max-height:none;\",\r\n\t\t\t\"miw\": \"min-width:|;\",\r\n\t\t\t\"mih\": \"min-height:|;\",\r\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\r\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\r\n\t\t\t\"ori\": \"orientation:|;\",\r\n\t\t\t\"ori:l\": \"orientation:landscape;\",\r\n\t\t\t\"ori:p\": \"orientation:portrait;\",\r\n\t\t\t\"ol\": \"outline:|;\",\r\n\t\t\t\"ol:n\": \"outline:none;\",\r\n\t\t\t\"olo\": \"outline-offset:|;\",\r\n\t\t\t\"olw\": \"outline-width:|;\",\r\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\r\n\t\t\t\"olw:m\": \"outline-width:medium;\",\r\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\r\n\t\t\t\"ols\": \"outline-style:|;\",\r\n\t\t\t\"ols:n\": \"outline-style:none;\",\r\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\r\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\r\n\t\t\t\"ols:s\": \"outline-style:solid;\",\r\n\t\t\t\"ols:db\": \"outline-style:double;\",\r\n\t\t\t\"ols:g\": \"outline-style:groove;\",\r\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\r\n\t\t\t\"ols:i\": \"outline-style:inset;\",\r\n\t\t\t\"ols:o\": \"outline-style:outset;\",\r\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\r\n\t\t\t\"olc:i\": \"outline-color:invert;\",\r\n\t\t\t\"bfv\": \"backface-visibility:|;\",\r\n\t\t\t\"bfv:h\": \"backface-visibility:hidden;\",\r\n\t\t\t\"bfv:v\": \"backface-visibility:visible;\",\r\n\t\t\t\"bd\": \"border:|;\",\r\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bd:n\": \"border:none;\",\r\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\r\n\t\t\t\"bdbk:c\": \"border-break:close;\",\r\n\t\t\t\"bdcl\": \"border-collapse:|;\",\r\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\r\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\r\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\r\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\r\n\t\t\t\"bdi\": \"border-image:url(|);\",\r\n\t\t\t\"bdi:n\": \"border-image:none;\",\r\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\r\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\r\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\r\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\r\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\r\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\r\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\r\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\r\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\r\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\r\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\r\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\r\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\r\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\r\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\r\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\r\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\r\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\r\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\r\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\r\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\r\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\r\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\r\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\r\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\r\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\r\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\r\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\r\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\r\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\r\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\r\n\t\t\t\"bdlen\": \"border-length:|;\",\r\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\r\n\t\t\t\"bdsp\": \"border-spacing:|;\",\r\n\t\t\t\"bds\": \"border-style:|;\",\r\n\t\t\t\"bds:n\": \"border-style:none;\",\r\n\t\t\t\"bds:h\": \"border-style:hidden;\",\r\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\r\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\r\n\t\t\t\"bds:s\": \"border-style:solid;\",\r\n\t\t\t\"bds:db\": \"border-style:double;\",\r\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\r\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\r\n\t\t\t\"bds:w\": \"border-style:wave;\",\r\n\t\t\t\"bds:g\": \"border-style:groove;\",\r\n\t\t\t\"bds:r\": \"border-style:ridge;\",\r\n\t\t\t\"bds:i\": \"border-style:inset;\",\r\n\t\t\t\"bds:o\": \"border-style:outset;\",\r\n\t\t\t\"bdw\": \"border-width:|;\",\r\n\t\t\t\"bdtw\": \"border-top-width:|;\",\r\n\t\t\t\"bdrw\": \"border-right-width:|;\",\r\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\r\n\t\t\t\"bdlw\": \"border-left-width:|;\",\r\n\t\t\t\"bdt\": \"border-top:|;\",\r\n\t\t\t\"bt\": \"border-top:|;\",\r\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdt:n\": \"border-top:none;\",\r\n\t\t\t\"bdts\": \"border-top-style:|;\",\r\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\r\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\r\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\r\n\t\t\t\"bdr\": \"border-right:|;\",\r\n\t\t\t\"br\": \"border-right:|;\",\r\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdr:n\": \"border-right:none;\",\r\n\t\t\t\"bdrst\": \"border-right-style:|;\",\r\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\r\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\r\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\r\n\t\t\t\"bdb\": \"border-bottom:|;\",\r\n\t\t\t\"bb\": \"border-bottom:|;\",\r\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\r\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\r\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\r\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\r\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\r\n\t\t\t\"bdl\": \"border-left:|;\",\r\n\t\t\t\"bl\": \"border-left:|;\",\r\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdl:n\": \"border-left:none;\",\r\n\t\t\t\"bdls\": \"border-left-style:|;\",\r\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\r\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\r\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\r\n\t\t\t\"bdrs\": \"border-radius:|;\",\r\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\r\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\r\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\r\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\r\n\t\t\t\"bg\": \"background:#${1:000};\",\r\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\r\n\t\t\t\"bg:n\": \"background:none;\",\r\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\r\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\r\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\r\n\t\t\t\"bgi\": \"background-image:url(|);\",\r\n\t\t\t\"bgi:n\": \"background-image:none;\",\r\n\t\t\t\"bgr\": \"background-repeat:|;\",\r\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\r\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\r\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\r\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\r\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\r\n\t\t\t\"bga\": \"background-attachment:|;\",\r\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\r\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\r\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\r\n\t\t\t\"bgpx\": \"background-position-x:|;\",\r\n\t\t\t\"bgpy\": \"background-position-y:|;\",\r\n\t\t\t\"bgbk\": \"background-break:|;\",\r\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\r\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\r\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\r\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\r\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\r\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\r\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\r\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\r\n\t\t\t\"bgo\": \"background-origin:|;\",\r\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\r\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\r\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\r\n\t\t\t\"bgsz\": \"background-size:|;\",\r\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\r\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\r\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\r\n\t\t\t\"c\": \"color:#${1:000};\",\r\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\r\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\r\n\t\t\t\"cm\": \"/* |${child} */\",\r\n\t\t\t\"cnt\": \"content:'|';\",\r\n\t\t\t\"cnt:n\": \"content:normal;\",\r\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\r\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\r\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\r\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\r\n\t\t\t\"cnt:a\": \"content:attr(|);\",\r\n\t\t\t\"cnt:c\": \"content:counter(|);\",\r\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\r\n\r\n\t\t\t\"tbl\": \"table-layout:|;\",\r\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\r\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\r\n\t\t\t\"cps\": \"caption-side:|;\",\r\n\t\t\t\"cps:t\": \"caption-side:top;\",\r\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\r\n\t\t\t\"ec\": \"empty-cells:|;\",\r\n\t\t\t\"ec:s\": \"empty-cells:show;\",\r\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\r\n\t\t\t\"lis\": \"list-style:|;\",\r\n\t\t\t\"lis:n\": \"list-style:none;\",\r\n\t\t\t\"lisp\": \"list-style-position:|;\",\r\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\r\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\r\n\t\t\t\"list\": \"list-style-type:|;\",\r\n\t\t\t\"list:n\": \"list-style-type:none;\",\r\n\t\t\t\"list:d\": \"list-style-type:disc;\",\r\n\t\t\t\"list:c\": \"list-style-type:circle;\",\r\n\t\t\t\"list:s\": \"list-style-type:square;\",\r\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\r\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\r\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\r\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\r\n\t\t\t\"lisi\": \"list-style-image:|;\",\r\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\r\n\t\t\t\"q\": \"quotes:|;\",\r\n\t\t\t\"q:n\": \"quotes:none;\",\r\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\r\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\r\n\t\t\t\"ct\": \"content:|;\",\r\n\t\t\t\"ct:n\": \"content:normal;\",\r\n\t\t\t\"ct:oq\": \"content:open-quote;\",\r\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\r\n\t\t\t\"ct:cq\": \"content:close-quote;\",\r\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\r\n\t\t\t\"ct:a\": \"content:attr(|);\",\r\n\t\t\t\"ct:c\": \"content:counter(|);\",\r\n\t\t\t\"ct:cs\": \"content:counters(|);\",\r\n\t\t\t\"coi\": \"counter-increment:|;\",\r\n\t\t\t\"cor\": \"counter-reset:|;\",\r\n\t\t\t\"va\": \"vertical-align:${1:top};\",\r\n\t\t\t\"va:sup\": \"vertical-align:super;\",\r\n\t\t\t\"va:t\": \"vertical-align:top;\",\r\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\r\n\t\t\t\"va:m\": \"vertical-align:middle;\",\r\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\r\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\r\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\r\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\r\n\t\t\t\"ta\": \"text-align:${1:left};\",\r\n\t\t\t\"ta:l\": \"text-align:left;\",\r\n\t\t\t\"ta:c\": \"text-align:center;\",\r\n\t\t\t\"ta:r\": \"text-align:right;\",\r\n\t\t\t\"ta:j\": \"text-align:justify;\",\r\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\r\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\r\n\t\t\t\"tal:l\": \"text-align-last:left;\",\r\n\t\t\t\"tal:c\": \"text-align-last:center;\",\r\n\t\t\t\"tal:r\": \"text-align-last:right;\",\r\n\t\t\t\"td\": \"text-decoration:${1:none};\",\r\n\t\t\t\"td:n\": \"text-decoration:none;\",\r\n\t\t\t\"td:u\": \"text-decoration:underline;\",\r\n\t\t\t\"td:o\": \"text-decoration:overline;\",\r\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\r\n\t\t\t\"te\": \"text-emphasis:|;\",\r\n\t\t\t\"te:n\": \"text-emphasis:none;\",\r\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\r\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\r\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\r\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\r\n\t\t\t\"te:b\": \"text-emphasis:before;\",\r\n\t\t\t\"te:a\": \"text-emphasis:after;\",\r\n\t\t\t\"th\": \"text-height:|;\",\r\n\t\t\t\"th:a\": \"text-height:auto;\",\r\n\t\t\t\"th:f\": \"text-height:font-size;\",\r\n\t\t\t\"th:t\": \"text-height:text-size;\",\r\n\t\t\t\"th:m\": \"text-height:max-size;\",\r\n\t\t\t\"ti\": \"text-indent:|;\",\r\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\r\n\t\t\t\"tj\": \"text-justify:|;\",\r\n\t\t\t\"tj:a\": \"text-justify:auto;\",\r\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\r\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\r\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\r\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\r\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\r\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\r\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\r\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\r\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\r\n\t\t\t\"to\": \"text-outline:|;\",\r\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\r\n\t\t\t\"to:n\": \"text-outline:none;\",\r\n\t\t\t\"tr\": \"text-replace:|;\",\r\n\t\t\t\"tr:n\": \"text-replace:none;\",\r\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\r\n\t\t\t\"tt:n\": \"text-transform:none;\",\r\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\r\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\r\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\r\n\t\t\t\"tw\": \"text-wrap:|;\",\r\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\r\n\t\t\t\"tw:no\": \"text-wrap:none;\",\r\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\r\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\r\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\r\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\r\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\r\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\r\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\r\n\t\t\t\"trf\": \"transform:|;\",\r\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\r\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\r\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\r\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\r\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\r\n\t\t\t\"trf:scz\": \"transform: scaleZ(${1:z});\",\r\n\t\t\t\"trf:sc3\": \"transform: scale3d(${1:x}, ${2:y}, ${3:z});\",\r\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\r\n\t\t\t\"trf:rx\": \"transform: rotateX(${1:angle});\",\r\n\t\t\t\"trf:ry\": \"transform: rotateY(${1:angle});\",\r\n\t\t\t\"trf:rz\": \"transform: rotateZ(${1:angle});\",\r\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\r\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\r\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\r\n\t\t\t\"trf:tz\": \"transform: translateZ(${1:z});\",\r\n\t\t\t\"trf:t3\": \"transform: translate3d(${1:tx}, ${2:ty}, ${3:tz});\",\r\n\t\t\t\"trfo\": \"transform-origin:|;\",\r\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\r\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\r\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\r\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\r\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\r\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\r\n\t\t\t\"lh\": \"line-height:|;\",\r\n\t\t\t\"whs\": \"white-space:|;\",\r\n\t\t\t\"whs:n\": \"white-space:normal;\",\r\n\t\t\t\"whs:p\": \"white-space:pre;\",\r\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\r\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\r\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\r\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\r\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\r\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\r\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\r\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\r\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\r\n\t\t\t\"wob\": \"word-break:|;\",\r\n\t\t\t\"wob:n\": \"word-break:normal;\",\r\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\r\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\r\n\t\t\t\"wos\": \"word-spacing:|;\",\r\n\t\t\t\"wow\": \"word-wrap:|;\",\r\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\r\n\t\t\t\"wow:n\": \"word-wrap:none;\",\r\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\r\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\r\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\r\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\r\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\r\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\r\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\r\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\r\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\r\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\r\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\r\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\r\n\t\t\t\"lts\": \"letter-spacing:|;\",\r\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\r\n\t\t\t\"f\": \"font:|;\",\r\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\r\n\t\t\t\"fw\": \"font-weight:|;\",\r\n\t\t\t\"fw:n\": \"font-weight:normal;\",\r\n\t\t\t\"fw:b\": \"font-weight:bold;\",\r\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\r\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\r\n\t\t\t\"fs\": \"font-style:${italic};\",\r\n\t\t\t\"fs:n\": \"font-style:normal;\",\r\n\t\t\t\"fs:i\": \"font-style:italic;\",\r\n\t\t\t\"fs:o\": \"font-style:oblique;\",\r\n\t\t\t\"fv\": \"font-variant:|;\",\r\n\t\t\t\"fv:n\": \"font-variant:normal;\",\r\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\r\n\t\t\t\"fz\": \"font-size:|;\",\r\n\t\t\t\"fza\": \"font-size-adjust:|;\",\r\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\r\n\t\t\t\"ff\": \"font-family:|;\",\r\n\t\t\t\"ff:s\": \"font-family:serif;\",\r\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\r\n\t\t\t\"ff:c\": \"font-family:cursive;\",\r\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\r\n\t\t\t\"ff:m\": \"font-family:monospace;\",\r\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\r\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\r\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\r\n\t\t\t\"fef\": \"font-effect:|;\",\r\n\t\t\t\"fef:n\": \"font-effect:none;\",\r\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\r\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\r\n\t\t\t\"fef:o\": \"font-effect:outline;\",\r\n\t\t\t\"fem\": \"font-emphasize:|;\",\r\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\r\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\r\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\r\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\r\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\r\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\r\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\r\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\r\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\r\n\t\t\t\"fsm\": \"font-smooth:|;\",\r\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\r\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\r\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\r\n\t\t\t\"fst\": \"font-stretch:|;\",\r\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\r\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\r\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\r\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\r\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\r\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\r\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\r\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\r\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\r\n\t\t\t\"op\": \"opacity:|;\",\r\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\r\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\r\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\r\n\t\t\t\"rsz\": \"resize:|;\",\r\n\t\t\t\"rsz:n\": \"resize:none;\",\r\n\t\t\t\"rsz:b\": \"resize:both;\",\r\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\r\n\t\t\t\"rsz:v\": \"resize:vertical;\",\r\n\t\t\t\"cur\": \"cursor:${pointer};\",\r\n\t\t\t\"cur:a\": \"cursor:auto;\",\r\n\t\t\t\"cur:d\": \"cursor:default;\",\r\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\r\n\t\t\t\"cur:ha\": \"cursor:hand;\",\r\n\t\t\t\"cur:he\": \"cursor:help;\",\r\n\t\t\t\"cur:m\": \"cursor:move;\",\r\n\t\t\t\"cur:p\": \"cursor:pointer;\",\r\n\t\t\t\"cur:t\": \"cursor:text;\",\r\n\t\t\t\"fxd\": \"flex-direction:|;\",\r\n\t\t\t\"fxd:r\": \"flex-direction:row;\",\r\n\t\t\t\"fxd:rr\": \"flex-direction:row-reverse;\",\r\n\t\t\t\"fxd:c\": \"flex-direction:column;\",\r\n\t\t\t\"fxd:cr\": \"flex-direction:column-reverse;\",\r\n\t\t\t\"fxw\": \"flex-wrap: |;\",\r\n\t\t\t\"fxw:n\": \"flex-wrap:nowrap;\",\r\n\t\t\t\"fxw:w\": \"flex-wrap:wrap;\",\r\n\t\t\t\"fxw:wr\": \"flex-wrap:wrap-reverse;\",\r\n\t\t\t\"fxf\": \"flex-flow:|;\",\r\n\t\t\t\"jc\": \"justify-content:|;\",\r\n\t\t\t\"jc:fs\": \"justify-content:flex-start;\",\r\n\t\t\t\"jc:fe\": \"justify-content:flex-end;\",\r\n\t\t\t\"jc:c\": \"justify-content:center;\",\r\n\t\t\t\"jc:sb\": \"justify-content:space-between;\",\r\n\t\t\t\"jc:sa\": \"justify-content:space-around;\",\r\n\t\t\t\"ai\": \"align-items:|;\",\r\n\t\t\t\"ai:fs\": \"align-items:flex-start;\",\r\n\t\t\t\"ai:fe\": \"align-items:flex-end;\",\r\n\t\t\t\"ai:c\": \"align-items:center;\",\r\n\t\t\t\"ai:b\": \"align-items:baseline;\",\r\n\t\t\t\"ai:s\": \"align-items:stretch;\",\r\n\t\t\t\"ac\": \"align-content:|;\",\r\n\t\t\t\"ac:fs\": \"align-content:flex-start;\",\r\n\t\t\t\"ac:fe\": \"align-content:flex-end;\",\r\n\t\t\t\"ac:c\": \"align-content:center;\",\r\n\t\t\t\"ac:sb\": \"align-content:space-between;\",\r\n\t\t\t\"ac:sa\": \"align-content:space-around;\",\r\n\t\t\t\"ac:s\": \"align-content:stretch;\",\r\n\t\t\t\"ord\": \"order:|;\",\r\n\t\t\t\"fxg\": \"flex-grow:|;\",\r\n\t\t\t\"fxsh\": \"flex-shrink:|;\",\r\n\t\t\t\"fxb\": \"flex-basis:|;\",\r\n\t\t\t\"fx\": \"flex:|;\",\r\n\t\t\t\"as\": \"align-self:|;\",\r\n\t\t\t\"as:a\": \"align-self:auto;\",\r\n\t\t\t\"as:fs\": \"align-self:flex-start;\",\r\n\t\t\t\"as:fe\": \"align-self:flex-end;\",\r\n\t\t\t\"as:c\": \"align-self:center;\",\r\n\t\t\t\"as:b\": \"align-self:baseline;\",\r\n\t\t\t\"as:s\": \"align-self:stretch;\",\r\n\t\t\t\"pgbb\": \"page-break-before:|;\",\r\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\r\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\r\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\r\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\r\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\r\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\r\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\r\n\t\t\t\"pgba\": \"page-break-after:|;\",\r\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\r\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\r\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\r\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\r\n\t\t\t\"orp\": \"orphans:|;\",\r\n\t\t\t\"us\": \"user-select:${none};\",\r\n\t\t\t\"wid\": \"widows:|;\",\r\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\r\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\r\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\r\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\r\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"html\": {\r\n\t\t\"filters\": \"html\",\r\n\t\t\"profile\": \"html\",\r\n\t\t\"snippets\": {\r\n\t\t\t\"!!!\":    \"<!DOCTYPE html>\",\r\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\r\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\r\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\r\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\r\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\r\n\r\n\t\t\t\"c\": \"<!-- |${child} -->\",\r\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\r\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\r\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\r\n\t\t},\r\n\t\t\r\n\t\t\"abbreviations\": {\r\n\t\t\t\"!\": \"html:5\",\r\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\r\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\r\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\r\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\r\n\t\t\t\"acr|acronym\": \"<acronym title=\\\"\\\">\",\r\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\r\n\t\t\t\"basefont\": \"<basefont/>\",\r\n\t\t\t\"br\": \"<br/>\",\r\n\t\t\t\"frame\": \"<frame/>\",\r\n\t\t\t\"hr\": \"<hr/>\",\r\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\r\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\r\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\r\n\t\t\t\"col\": \"<col/>\",\r\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\r\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\r\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\r\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\r\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\r\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\r\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\r\n\t\t\t\"link:im|link:import\": \"<link rel=\\\"import\\\" href=\\\"${1:component}.html\\\" />\",\r\n\t\t\t\"meta\": \"<meta/>\",\r\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\r\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\r\n\t\t\t\"meta:edge\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:ie=edge}\\\" />\",\r\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, initial-scale=${3:1.0}\\\" />\",\r\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\r\n\t\t\t\"meta:redirect\": \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=${1:http://example.com}\\\" />\",\r\n\t\t\t\"style\": \"<style>\",\r\n\t\t\t\"script\": \"<script !src=\\\"\\\">\",\r\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\r\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"img:s|img:srcset\": \"<img srcset=\\\"\\\" src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"img:z|img:sizes\": \"<img sizes=\\\"\\\" srcset=\\\"\\\" src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"picture\": \"<picture>\",\r\n\t\t\t\"src|source\": \"<source/>\",\r\n\t\t\t\"src:sc|source:src\": \"<source src=\\\"\\\" type=\\\"\\\"/>\",\r\n\t\t\t\"src:s|source:srcset\": \"<source srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:m|source:media\": \"<source media=\\\"(${1:min-width: })\\\" srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:t|source:type\": \"<source srcset=\\\"|\\\" type=\\\"${1:image/}\\\"/>\",\r\n\t\t\t\"src:z|source:sizes\": \"<source sizes=\\\"\\\" srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:mt|source:media:type\": \"<source media=\\\"(${1:min-width: })\\\" srcset=\\\"\\\" type=\\\"${2:image/}\\\"/>\",\r\n\t\t\t\"src:mz|source:media:sizes\": \"<source media=\\\"(${1:min-width: })\\\" sizes=\\\"\\\" srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:zt|source:sizes:type\": \"<source sizes=\\\"\\\" srcset=\\\"\\\" type=\\\"${1:image/}\\\"/>\",\r\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\r\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\r\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\r\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\r\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\r\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\r\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\r\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\r\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\r\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\r\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\r\n\t\t\t\"input:h|input:hidden\": \"input[type=hidden name]\",\r\n\t\t\t\"input:t|input:text\": \"inp\",\r\n\t\t\t\"input:search\": \"inp[type=search]\",\r\n\t\t\t\"input:email\": \"inp[type=email]\",\r\n\t\t\t\"input:url\": \"inp[type=url]\",\r\n\t\t\t\"input:p|input:password\": \"inp[type=password]\",\r\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\r\n\t\t\t\"input:date\": \"inp[type=date]\",\r\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\r\n\t\t\t\"input:month\": \"inp[type=month]\",\r\n\t\t\t\"input:week\": \"inp[type=week]\",\r\n\t\t\t\"input:time\": \"inp[type=time]\",\r\n\t\t\t\"input:tel\": \"inp[type=tel]\",\r\n\t\t\t\"input:number\": \"inp[type=number]\",\r\n\t\t\t\"input:color\": \"inp[type=color]\",\r\n\t\t\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\r\n\t\t\t\"input:r|input:radio\": \"inp[type=radio]\",\r\n\t\t\t\"input:range\": \"inp[type=range]\",\r\n\t\t\t\"input:f|input:file\": \"inp[type=file]\",\r\n\t\t\t\"input:s|input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\r\n\t\t\t\"input:i|input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"input:b|input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\r\n\t\t\t\"isindex\": \"<isindex/>\",\r\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\r\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\r\n\t\t\t\"select:d|select:disabled\": \"select[disabled.]\",\r\n\t\t\t\"opt|option\": \"<option value=\\\"\\\">\",\r\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\r\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\r\n\t\t\t\"menu:c|menu:context\": \"menu[type=context]>\",\r\n\t\t\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]>\",\r\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\r\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\r\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\r\n\t\t\t\"keygen\": \"<keygen/>\",\r\n\t\t\t\"command\": \"<command/>\",\r\n\t\t\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\r\n\t\t\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\r\n\t\t\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\r\n\t\t\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\r\n\t\t\t\r\n\t\t\t\"bq\": \"blockquote\",\r\n\t\t\t\"fig\": \"figure\",\r\n\t\t\t\"figc\": \"figcaption\",\r\n\t\t\t\"pic\": \"picture\",\r\n\t\t\t\"ifr\": \"iframe\",\r\n\t\t\t\"emb\": \"embed\",\r\n\t\t\t\"obj\": \"object\",\r\n\t\t\t\"cap\": \"caption\",\r\n\t\t\t\"colg\": \"colgroup\",\r\n\t\t\t\"fst\": \"fieldset\",\r\n\t\t\t\"btn\": \"button\",\r\n\t\t\t\"optg\": \"optgroup\",\r\n\t\t\t\"tarea\": \"textarea\",\r\n\t\t\t\"leg\": \"legend\",\r\n\t\t\t\"sect\": \"section\",\r\n\t\t\t\"art\": \"article\",\r\n\t\t\t\"hdr\": \"header\",\r\n\t\t\t\"ftr\": \"footer\",\r\n\t\t\t\"adr\": \"address\",\r\n\t\t\t\"dlg\": \"dialog\",\r\n\t\t\t\"str\": \"strong\",\r\n\t\t\t\"prog\": \"progress\",\r\n\t\t\t\"mn\": \"main\",\r\n\t\t\t\"tem\": \"template\",\r\n\t\t\t\"fset\": \"fieldset\",\r\n\t\t\t\"datag\": \"datagrid\",\r\n\t\t\t\"datal\": \"datalist\",\r\n\t\t\t\"kg\": \"keygen\",\r\n\t\t\t\"out\": \"output\",\r\n\t\t\t\"det\": \"details\",\r\n\t\t\t\"cmd\": \"command\",\r\n\r\n\t\t\t\"doc\": \"html>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\r\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\r\n\r\n\t\t\t\"ri:d|ri:dpr\": \"img:s\",\r\n\t\t\t\"ri:v|ri:viewport\": \"img:z\",\r\n\t\t\t\"ri:a|ri:art\": \"pic>src:m+img\",\r\n\t\t\t\"ri:t|ri:type\": \"pic>src:t+img\",\r\n\r\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\r\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\r\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\r\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\r\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\r\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\r\n\t\t\t\r\n\t\t\t\"ol+\": \"ol>li\",\r\n\t\t\t\"ul+\": \"ul>li\",\r\n\t\t\t\"dl+\": \"dl>dt+dd\",\r\n\t\t\t\"map+\": \"map>area\",\r\n\t\t\t\"table+\": \"table>tr>td\",\r\n\t\t\t\"colgroup+\": \"colgroup>col\",\r\n\t\t\t\"colg+\": \"colgroup>col\",\r\n\t\t\t\"tr+\": \"tr>td\",\r\n\t\t\t\"select+\": \"select>option\",\r\n\t\t\t\"optgroup+\": \"optgroup>option\",\r\n\t\t\t\"optg+\": \"optgroup>option\",\r\n\t\t\t\"pic+\": \"picture>source:srcset+img\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"xml\": {\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\",\r\n\t\t\"filters\": \"html\"\r\n\t},\r\n\t\r\n\t\"svg\": {\r\n\t\t\"filters\": \"html\",\r\n\t\t\"profile\": \"xml\",\r\n\t\t\"snippets\": {\r\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\",\r\n\t\t\t\"svgdoc\": \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\"\r\n\t\t},\r\n\t\t\"abbreviations\": {\r\n\t\t\t\"!svg\": \"!!!+svgdoc+svg\",\r\n\t\t\t\"svg\": \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\",\r\n\t\t\t\"a\": \"<a xlink:href=\\\"\\\">\",\r\n\t\t\t\"ag\": \"altGliph\",\r\n\t\t\t\"agd\": \"altGliphDef\",\r\n\t\t\t\"agi\": \"altGliphItem\",\r\n\t\t\t\"anim|animate\": \"<animate attributeType=\\\"\\\" attributeName=\\\"\\\" from=\\\"\\\" to=\\\"\\\" dur=\\\"\\\" repeatCount=\\\"indefinite\\\">\",\r\n\t\t\t\"ac\": \"<animateColor>\",\r\n\t\t\t\"am\": \"<animateMotion>\",\r\n\t\t\t\"at\": \"<animateTransform>\",\r\n\t\t\t\"c\": \"circle\",\r\n\t\t\t\"cp\": \"colorPath\",\r\n\t\t\t\"c-p\": \"color-profile\",\r\n\t\t\t\"cur\": \"cursor\",\r\n\t\t\t\"df\": \"defs\",\r\n\t\t\t\"e|ellipse\": \"<ellipse  cx=\\\"\\\" cy=\\\"\\\" rx=\\\"\\\" ry=\\\"\\\"/>\",\r\n\t\t\t\"ff\": \"<font-face>\",\r\n\t\t\t\"fff\": \"<font-face-format>\",\r\n\t\t\t\"ffn\": \"<font-face-name>\",\r\n\t\t\t\"ffs\": \"<font-face-src>\",\r\n\t\t\t\"ffu\": \"<font-face-uri>\",\r\n\t\t\t\"fo\": \"<foreignObject>\",\r\n\t\t\t\"g\": \"<g>\",\r\n\t\t\t\"gl\": \"<glyph>\",\r\n\t\t\t\"glr\": \"<glyphRef>\",\r\n\t\t\t\"hk\": \"<hkern>\",\r\n\t\t\t\"i|image\": \"<image xlink:href=\\\"\\\" x=\\\"\\\" y=\\\"\\\" width=\\\"\\\" height=\\\"\\\"/>\",\r\n\t\t\t\"l\": \"<line>\",\r\n\t\t\t\"lg\": \"<linearGradient>\",\r\n\t\t\t\"marker\": \"<marker>\",\r\n\t\t\t\"mask\": \"<mask>\",\r\n\t\t\t\"md\": \"<metadata>\",\r\n\t\t\t\"mg\": \"<missing-glyph>\",\r\n\t\t\t\"mp\": \"<mpath>\",\r\n\t\t\t\"path\": \"<path d=\\\"\\\">\",\r\n\t\t\t\"patt\": \"<pattern>\",\r\n\t\t\t\"pg\": \"<polygon points=\\\"\\\">\",\r\n\t\t\t\"pl\": \"<polyline points=\\\"\\\">\",\r\n\t\t\t\"rg\": \"<radialGradient>\",\r\n\t\t\t\"r\": \"<rect x=\\\"\\\" y=\\\"\\\" width=\\\"\\\" height=\\\"\\\"/>\",\r\n\t\t\t\"scr\": \"<script>\",\r\n\t\t\t\"sb\": \"<symbol>\",\r\n\t\t\t\"txt\": \"<text>\",\r\n\t\t\t\"tp\": \"<textPath>\",\r\n\t\t\t\"ts\": \"<tspan>\",\r\n\t\t\t\"u|use\": \"<use xlink:href=\\\"\\\"/>\",\r\n\t\t\t\"v\": \"<view>\",\r\n\t\t\t\"vk\": \"<vkern>\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"xsl\": {\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\",\r\n\t\t\"filters\": \"html, xsl\",\r\n\t\t\"abbreviations\": {\r\n\t\t\t\"tm|tmatch\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\r\n\t\t\t\"tn|tname\": \"<xsl:template name=\\\"\\\">\",\r\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\r\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\r\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\r\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\r\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\r\n\r\n\t\t\t\"ch\": \"<xsl:choose>\",\r\n\t\t\t\"wh|xsl:when\": \"<xsl:when test=\\\"\\\">\",\r\n\t\t\t\"ot\": \"<xsl:otherwise>\",\r\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\r\n\r\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\r\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\r\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\r\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\r\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\r\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\r\n\r\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\r\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\r\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\r\n\r\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\r\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\r\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\r\n\t\t\t\"for|each\": \"<xsl:for-each select=\\\"\\\">\",\r\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\r\n\r\n\t\t\t\"com\": \"<xsl:comment>\",\r\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\r\n\t\t\t\"fall\": \"<xsl:fallback>\",\r\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\r\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\r\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\r\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\r\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\r\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\r\n\r\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\r\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\r\n\t\t}, \r\n\t\t\"snippets\": {\r\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"haml\": {\r\n\t\t\"filters\": \"haml\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\r\n\t\"jade\": {\r\n\t\t\"filters\": \"jade\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\r\n\t\"jsx\": {\r\n\t\t\"filters\": \"jsx, html\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\r\n\t\"slim\": {\r\n\t\t\"filters\": \"slim\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\t\r\n\t\"scss\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\t\r\n\t\"sass\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\t\r\n\t\"less\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\t\r\n\t\"stylus\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\r\n\t\"styl\": {\r\n\t\t\"extends\": \"stylus\"\r\n\t}\r\n}\r\n\r\n},{}],\"utils\\\\abbreviation.js\":[function(require,module,exports){\r\n/**\r\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\r\n * @param {Function} require\r\n * @param {Underscore} _\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar elements = require('../assets/elements');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar utils = require('../utils/common');\r\n\tvar tagName = require('../resolver/tagName');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Test if passed node is unary (no closing tag)\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisUnary: function(node) {\r\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar r = node.data('resource');\r\n\t\t\treturn r && r.is_empty;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisInline: function(node) {\r\n\t\t\treturn node.isTextNode() \r\n\t\t\t\t|| !node.name() \r\n\t\t\t\t|| tagName.isInlineLevel(node.name());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if passed node is block-level\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisBlock: function(node) {\r\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if given node is a snippet\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisSnippet: function(node) {\r\n\t\t\treturn elements.is(node.data('resource'), 'snippet');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * This function tests if passed node content contains HTML tags. \r\n\t\t * This function is mostly used for output formatting\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\thasTagsInContent: function(node) {\r\n\t\t\treturn utils.matchesTag(node.content);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if current element contains block-level children\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\thasBlockChildren: function(node) {\r\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \r\n\t\t\t\t|| node.children.some(function(child) {\r\n\t\t\t\t\treturn this.isBlock(child);\r\n\t\t\t\t}, this);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Utility function that inserts content instead of <code>${child}</code>\r\n\t\t * variables on <code>text</code>\r\n\t\t * @param {String} text Text where child content should be inserted\r\n\t\t * @param {String} childContent Content to insert\r\n\t\t * @param {Object} options\r\n\t\t * @returns {String\r\n\t\t */\r\n\t\tinsertChildContent: function(text, childContent, options) {\r\n\t\t\toptions = utils.extend({\r\n\t\t\t\tkeepVariable: true,\r\n\t\t\t\tappendIfNoChild: true\r\n\t\t\t}, options || {});\r\n\t\t\t\r\n\t\t\tvar childVariableReplaced = false;\r\n\t\t\ttext = tabStops.replaceVariables(text, function(variable, name, data) {\r\n\t\t\t\tvar output = variable;\r\n\t\t\t\tif (name == 'child') {\r\n\t\t\t\t\t// add correct indentation\r\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\r\n\t\t\t\t\tchildVariableReplaced = true;\r\n\t\t\t\t\tif (options.keepVariable)\r\n\t\t\t\t\t\toutput += variable;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn output;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\r\n\t\t\t\ttext += childContent;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn text;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/elements\":\"assets\\\\elements.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../resolver/tagName\":\"resolver\\\\tagName.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"utils\\\\action.js\":[function(require,module,exports){\r\n/**\r\n * Utility methods for Emmet actions\r\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar cssSections = require('./cssSections');\r\n\tvar abbreviationParser = require('../parser/abbreviation');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\tvar range = require('../assets/range');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\treturn {\r\n\t\tmimeTypes: {\r\n\t\t\t'gif' : 'image/gif',\r\n\t\t\t'png' : 'image/png',\r\n\t\t\t'jpg' : 'image/jpeg',\r\n\t\t\t'jpeg': 'image/jpeg',\r\n\t\t\t'svg' : 'image/svg+xml',\r\n\t\t\t'html': 'text/html',\r\n\t\t\t'htm' : 'text/html'\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts abbreviations from text stream, starting from the end\r\n\t\t * @param {String} str\r\n\t\t * @return {String} Abbreviation or empty string\r\n\t\t * @memberOf emmet.actionUtils\r\n\t\t */\r\n\t\textractAbbreviation: function(str) {\r\n\t\t\tvar curOffset = str.length;\r\n\t\t\tvar startIndex = -1;\r\n\t\t\tvar groupCount = 0;\r\n\t\t\tvar braceCount = 0;\r\n\t\t\tvar textCount = 0;\r\n\t\t\t\r\n\t\t\twhile (true) {\r\n\t\t\t\tcurOffset--;\r\n\t\t\t\tif (curOffset < 0) {\r\n\t\t\t\t\t// moved to the beginning of the line\r\n\t\t\t\t\tstartIndex = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar ch = str.charAt(curOffset);\r\n\t\t\t\t\r\n\t\t\t\tif (ch == ']') {\r\n\t\t\t\t\tbraceCount++;\r\n\t\t\t\t} else if (ch == '[') {\r\n\t\t\t\t\tif (!braceCount) { // unexpected brace\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbraceCount--;\r\n\t\t\t\t} else if (ch == '}') {\r\n\t\t\t\t\ttextCount++;\r\n\t\t\t\t} else if (ch == '{') {\r\n\t\t\t\t\tif (!textCount) { // unexpected brace\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttextCount--;\r\n\t\t\t\t} else if (ch == ')') {\r\n\t\t\t\t\tgroupCount++;\r\n\t\t\t\t} else if (ch == '(') {\r\n\t\t\t\t\tif (!groupCount) { // unexpected brace\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroupCount--;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (braceCount || textCount) \r\n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\telse if (!abbreviationParser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\r\n\t\t\t\t\t\t// found stop symbol\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \r\n\t\t\t\t// found something, remove some invalid symbols from the \r\n\t\t\t\t// beginning and return abbreviation\r\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\r\n\t\t\telse\r\n\t\t\t\treturn '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Gets image size from image byte stream.\r\n\t\t * @author http://romeda.org/rePublish/\r\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\r\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\r\n\t\t */\r\n\t\tgetImageSize: function(stream) {\r\n\t\t\tvar pngMagicNum = \"\\211PNG\\r\\n\\032\\n\",\r\n\t\t\t\tjpgMagicNum = \"\\377\\330\",\r\n\t\t\t\tgifMagicNum = \"GIF8\",\r\n\t\t\t\tpos = 0,\r\n\t\t\t\tnextByte = function() {\r\n\t\t\t\t\treturn stream.charCodeAt(pos++);\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\r\n\t\t\t\t// PNG. Easy peasy.\r\n\t\t\t\tpos = stream.indexOf('IHDR') + 4;\r\n\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth:  (nextByte() << 24) | (nextByte() << 16) | (nextByte() <<  8) | nextByte(),\r\n\t\t\t\t\theight: (nextByte() << 24) | (nextByte() << 16) | (nextByte() <<  8) | nextByte()\r\n\t\t\t\t};\r\n\t\t\t\r\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\r\n\t\t\t\tpos = 6;\r\n\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\r\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\r\n\t\t\t\t};\r\n\t\t\t\r\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\r\n\t\t\t\tpos = 2;\r\n\t\t\t\r\n\t\t\t\tvar l = stream.length;\r\n\t\t\t\twhile (pos < l) {\r\n\t\t\t\t\tif (nextByte() != 0xFF) return;\r\n\t\t\t\t\r\n\t\t\t\t\tvar marker = nextByte();\r\n\t\t\t\t\tif (marker == 0xDA) break;\r\n\t\t\t\t\r\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\r\n\t\t\t\t\r\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\r\n\t\t\t\t\t\tpos += 1;\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\theight: (nextByte() << 8) | nextByte(),\r\n\t\t\t\t\t\t\twidth: (nextByte() << 8) | nextByte()\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpos += size - 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Captures context XHTML element from editor under current caret position.\r\n\t\t * This node can be used as a helper for abbreviation extraction\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tcaptureContext: function(editor, pos) {\r\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1, 'jsx': 1};\r\n\t\t\tvar syntax = editor.getSyntax();\r\n\t\t\tif (syntax in allowedSyntaxes) {\r\n\t\t\t\tvar content = editor.getContent();\r\n\t\t\t\tif (typeof pos === 'undefined') {\r\n\t\t\t\t\tpos = editor.getCaretPos();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar tag = htmlMatcher.find(content, pos);\r\n\t\t\t\tif (tag && tag.type == 'tag') {\r\n\t\t\t\t\tvar startTag = tag.open;\r\n\t\t\t\t\tvar contextNode = {\r\n\t\t\t\t\t\tname: startTag.name,\r\n\t\t\t\t\t\tattributes: [],\r\n\t\t\t\t\t\tmatch: tag\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t// parse attributes\r\n\t\t\t\t\tvar tagTree = xmlEditTree.parse(startTag.range.substring(content));\r\n\t\t\t\t\tif (tagTree) {\r\n\t\t\t\t\t\tcontextNode.attributes = tagTree.getAll().map(function(item) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\tname: item.name(),\r\n\t\t\t\t\t\t\t\tvalue: item.value()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn contextNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Find expression bounds in current editor at caret position. \r\n\t\t * On each character a <code>fn</code> function will be called and must \r\n\t\t * return <code>true</code> if current character meets requirements, \r\n\t\t * <code>false</code> otherwise\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {Function} fn Function to test each character of expression\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tfindExpressionBounds: function(editor, fn) {\r\n\t\t\tvar content = String(editor.getContent());\r\n\t\t\tvar il = content.length;\r\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\r\n\t\t\tvar exprEnd = exprStart + 1;\r\n\t\t\t\t\r\n\t\t\t// start by searching left\r\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\r\n\t\t\t\r\n\t\t\t// then search right\r\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\r\n\t\t\t\r\n\t\t\tif (exprEnd > exprStart) {\r\n\t\t\t\treturn range([++exprStart, exprEnd]);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {Object} data\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tcompoundUpdate: function(editor, data) {\r\n\t\t\tif (data) {\r\n\t\t\t\tvar sel = editor.getSelectionRange();\r\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\r\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Common syntax detection method for editors that doesn’t provide any\r\n\t\t * info about current syntax scope. \r\n\t\t * @param {IEmmetEditor} editor Current editor\r\n\t\t * @param {String} hint Any syntax hint that editor can provide \r\n\t\t * for syntax detection. Default is 'html'\r\n\t\t * @returns {String} \r\n\t\t */\r\n\t\tdetectSyntax: function(editor, hint) {\r\n\t\t\tvar syntax = hint || 'html';\r\n\t\t\t\r\n\t\t\tif (!resources.hasSyntax(syntax)) {\r\n\t\t\t\tsyntax = 'html';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\r\n\t\t\t\tsyntax = 'css';\r\n\t\t\t}\r\n\r\n\t\t\tif (syntax == 'styl') {\r\n\t\t\t\tsyntax = 'stylus';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn syntax;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Common method for detecting output profile\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tdetectProfile: function(editor) {\r\n\t\t\tvar syntax = editor.getSyntax();\r\n\t\t\t\r\n\t\t\t// get profile from syntax definition\r\n\t\t\tvar profile = resources.findItem(syntax, 'profile');\r\n\t\t\tif (profile) {\r\n\t\t\t\treturn profile;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tswitch(syntax) {\r\n\t\t\t\tcase 'xml':\r\n\t\t\t\tcase 'xsl':\r\n\t\t\t\t\treturn 'xml';\r\n\t\t\t\tcase 'css':\r\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\r\n\t\t\t\t\t\treturn 'line';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'html':\r\n\t\t\t\t\tprofile = resources.getVariable('profile');\r\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\r\n\t\t\t\t\t\t// html or xhtml?\r\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn profile;\r\n\t\t\t}\r\n\r\n\t\t\treturn 'xhtml';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Tries to detect if current document is XHTML one.\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisXHTML: function(editor) {\r\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if current caret position is inside &lt;style&gt; tag\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Range} Inner range of &lt;style&gt; tag\r\n\t\t */\r\n\t\tisStyle: function(editor) {\r\n\t\t\treturn !!cssSections.styleTagRange(editor.getContent(), editor.getCaretPos());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if given CSS dialect is supported by CSS actions\r\n\t\t * @param  {String}  syntax\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisSupportedCSS: function(syntax) {\r\n\t\t\treturn syntax == 'css' || syntax == 'less' || syntax == 'scss';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\r\n\t\t * element\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Range} Inner range of style attribute\r\n\t\t */\r\n\t\tisInlineCSS: function(editor) {\r\n\t\t\treturn !!cssSections.styleAttrRange(editor.getContent(), editor.getCaretPos());\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"./common\":\"utils\\\\common.js\",\"./cssSections\":\"utils\\\\cssSections.js\"}],\"utils\\\\base64.js\":[function(require,module,exports){\r\n/**\r\n * @author Sergey Chikuyonok (serge.che@gmail.com)\r\n * @link http://chikuyonok.ru\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Encodes data using base64 algorithm\r\n\t\t * @author Tyler Akins (http://rumkin.com)\r\n\t\t * @param {String} input\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tencode : function(input) {\r\n\t\t\tvar output = [];\r\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\r\n\t\t\tvar i = 0, il = input.length, b64 = chars;\r\n\r\n\t\t\twhile (i < il) {\r\n\r\n\t\t\t\tcdp1 = input.charCodeAt(i++);\r\n\t\t\t\tcdp2 = input.charCodeAt(i++);\r\n\t\t\t\tcdp3 = input.charCodeAt(i++);\r\n\r\n\t\t\t\tchr1 = cdp1 & 0xff;\r\n\t\t\t\tchr2 = cdp2 & 0xff;\r\n\t\t\t\tchr3 = cdp3 & 0xff;\r\n\r\n\t\t\t\tenc1 = chr1 >> 2;\r\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n\t\t\t\tenc4 = chr3 & 63;\r\n\r\n\t\t\t\tif (isNaN(cdp2)) {\r\n\t\t\t\t\tenc3 = enc4 = 64;\r\n\t\t\t\t} else if (isNaN(cdp3)) {\r\n\t\t\t\t\tenc4 = 64;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\r\n\t\t\t}\r\n\r\n\t\t\treturn output.join('');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Decodes string using MIME base64 algorithm\r\n\t\t * \r\n\t\t * @author Tyler Akins (http://rumkin.com)\r\n\t\t * @param {String} data\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tdecode : function(data) {\r\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\r\n\t\t\tvar b64 = chars, il = data.length;\r\n\r\n\t\t\tif (!data) {\r\n\t\t\t\treturn data;\r\n\t\t\t}\r\n\r\n\t\t\tdata += '';\r\n\r\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\r\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\r\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\r\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\r\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\r\n\r\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\r\n\r\n\t\t\t\to1 = bits >> 16 & 0xff;\r\n\t\t\t\to2 = bits >> 8 & 0xff;\r\n\t\t\t\to3 = bits & 0xff;\r\n\r\n\t\t\t\tif (h3 == 64) {\r\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\r\n\t\t\t\t} else if (h4 == 64) {\r\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\r\n\t\t\t\t}\r\n\t\t\t} while (i < il);\r\n\r\n\t\t\treturn tmpArr.join('');\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"utils\\\\comments.js\":[function(require,module,exports){\r\n/**\r\n * Utility module for working with comments in source code\r\n * (mostly stripping it from source)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar range = require('../assets/range');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar reHasComment = /\\/\\*|\\/\\//;\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Replaces all comments in given CSS source with spaces,\r\n\t\t * which allows more reliable (and faster) token search\r\n\t\t * in CSS content\r\n\t\t * @param  {String} content CSS content\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tstrip: function(content) {\r\n\t\t\tif (!reHasComment.test(content)) {\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tvar replaceRanges = [];\r\n\t\t\tvar ch, ch2;\r\n\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (ch === '/') {\r\n\t\t\t\t\tch2 = stream.peek();\r\n\t\t\t\t\tif (ch2 === '*') { // multiline CSS comment\r\n\t\t\t\t\t\tstream.start = stream.pos - 1;\r\n\r\n\t\t\t\t\t\tif (stream.skipTo('*/')) {\r\n\t\t\t\t\t\t\tstream.pos += 2;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// unclosed comment\r\n\t\t\t\t\t\t\tstream.skipToEnd();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\r\n\t\t\t\t\t} else if (ch2 === '/') {\r\n\t\t\t\t\t\t// preprocessor’s single line comments\r\n\t\t\t\t\t\tstream.start = stream.pos - 1;\r\n\t\t\t\t\t\twhile ((ch2 = stream.next())) {\r\n\t\t\t\t\t\t\tif (ch2 === '\\n' || ch2 == '\\r') {\r\n\t\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream.skipQuoted();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn utils.replaceWith(content, replaceRanges, ' ');\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\common.js\":[function(require,module,exports){\r\n/**\r\n * Common utility helper for Emmet\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\r\n\t/** \r\n\t * Special token used as a placeholder for caret positions inside \r\n\t * generated output \r\n\t */\r\n\tvar caretPlaceholder = '${0}';\r\n\t\r\n\treturn {\r\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\r\n\r\n\t\tdefaultSyntax: function() {\r\n\t\t\treturn 'html';\r\n\t\t},\r\n\r\n\t\tdefaultProfile: function() {\r\n\t\t\treturn 'plain';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\r\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \r\n\t\t * @param {String} str\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tendsWithTag: function(str) {\r\n\t\t\treturn this.reTag.test(str);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed symbol is a number\r\n\t\t * @param {String} ch\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisNumeric: function(ch) {\r\n\t\t\tif (typeof(ch) == 'string')\r\n\t\t\t\tch = ch.charCodeAt(0);\r\n\t\t\t\t\r\n\t\t\treturn (ch && ch > 47 && ch < 58);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Trim whitespace from string\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\ttrim: (function() {\r\n\t\t\tif (String.prototype.trim) {\r\n\t\t\t\treturn function(text) {\r\n\t\t\t\t\treturn text ? text.trim() : '';\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function(text) {\r\n\t\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t}\r\n\t\t})(),\r\n\t\t\r\n\t\t/**\r\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\r\n\t\t * empty lines\r\n\t\t * @param {String} text Text to split\r\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tsplitByLines: function(text, removeEmpty) {\r\n\t\t\t// IE fails to split string by regexp, \r\n\t\t\t// need to normalize newlines first\r\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\r\n\t\t\tvar nl = '\\n';\r\n\t\t\tvar lines = (text || '')\r\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\r\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\r\n\t\t\t\t.replace(/\\r/g, '\\n')\r\n\t\t\t\t.replace(/\\n/g, nl)\r\n\t\t\t\t.split(nl);\r\n\t\t\t\r\n\t\t\tif (removeEmpty) {\r\n\t\t\t\tlines = lines.filter(function(line) {\r\n\t\t\t\t\treturn line.length && !!this.trim(line);\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn lines;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Repeats string <code>howMany</code> times\r\n\t\t * @param {String} str\r\n\t\t * @param {Number} how_many\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\trepeatString: function(str, howMany) {\r\n\t\t\tvar out = '';\r\n\t\t\twhile (howMany--) {\r\n\t\t\t\tout += str;\r\n\t\t\t}\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns list of paddings that should be used to align passed string\r\n\t\t * @param {Array} strings\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetStringsPads: function(strings) {\r\n\t\t\tvar lengths = strings.map(function(s) {\r\n\t\t\t\treturn typeof s === 'string' ? s.length : +s;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tvar max = lengths.reduce(function(prev, cur) {\r\n\t\t\t\treturn typeof prev === 'undefined' ? cur : Math.max(prev, cur);\r\n\t\t\t});\r\n\t\t\treturn lengths.map(function(l) {\r\n\t\t\t\tvar pad = max - l;\r\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indents text with padding\r\n\t\t * @param {String} text Text to indent\r\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tpadString: function(text, pad) {\r\n\t\t\tvar result = [];\r\n\t\t\tvar lines = this.splitByLines(text);\r\n\t\t\tvar nl = '\\n';\r\n\t\t\t\t\r\n\t\t\tresult.push(lines[0]);\r\n\t\t\tfor (var j = 1; j < lines.length; j++) \r\n\t\t\t\tresult.push(nl + pad + lines[j]);\r\n\t\t\t\t\r\n\t\t\treturn result.join('');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Pad string with zeroes\r\n\t\t * @param {String} str String to pad\r\n\t\t * @param {Number} pad Desired string length\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tzeroPadString: function(str, pad) {\r\n\t\t\tvar padding = '';\r\n\t\t\tvar il = str.length;\r\n\t\t\t\t\r\n\t\t\twhile (pad > il++) padding += '0';\r\n\t\t\treturn padding + str; \r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes padding at the beginning of each text's line\r\n\t\t * @param {String} text\r\n\t\t * @param {String} pad\r\n\t\t */\r\n\t\tunindentString: function(text, pad) {\r\n\t\t\tvar lines = this.splitByLines(text);\r\n\t\t\tvar pl = pad.length;\r\n\t\t\tfor (var i = 0, il = lines.length, line; i < il; i++) {\r\n\t\t\t\tline = lines[i];\r\n\t\t\t\tif (line.substr(0, pl) === pad) {\r\n\t\t\t\t\tlines[i] = line.substr(pl);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn lines.join('\\n');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\r\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\r\n\t\t * @param {String} str Original string\r\n\t\t * @param {String} symbol Symbol to replace\r\n\t\t * @param {String} replace Symbol replacement. Might be a function that \r\n\t\t * returns new value\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\r\n\t\t\tvar i = 0;\r\n\t\t\tvar il = str.length;\r\n\t\t\tvar sl = symbol.length;\r\n\t\t\tvar matchCount = 0;\r\n\t\t\t\t\r\n\t\t\twhile (i < il) {\r\n\t\t\t\tif (str.charAt(i) == '\\\\') {\r\n\t\t\t\t\t// escaped symbol, skip next character\r\n\t\t\t\t\ti += sl + 1;\r\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\r\n\t\t\t\t\t// have match\r\n\t\t\t\t\tvar curSl = sl;\r\n\t\t\t\t\tmatchCount++;\r\n\t\t\t\t\tvar newValue = replace;\r\n\t\t\t\t\tif (typeof replace === 'function') {\r\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\r\n\t\t\t\t\t\tif (replaceData) {\r\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\r\n\t\t\t\t\t\t\tnewValue = replaceData[1];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewValue = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (newValue === false) { // skip replacement\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\r\n\t\t\t\t\t// adjust indexes\r\n\t\t\t\t\til = str.length;\r\n\t\t\t\t\ti += newValue.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn str;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\r\n\t\t * @param {String} str String where character should be replaced\r\n\t\t * @param {String} value New value\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceCounter: function(str, value, total) {\r\n\t\t\tvar symbol = '$';\r\n\t\t\t// in case we received strings from Java, convert the to native strings\r\n\t\t\tstr = String(str);\r\n\t\t\tvalue = String(value);\r\n\t\t\t\r\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\r\n\t\t\t\tvalue = +value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\r\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\r\n\t\t\t\t\t// it's a variable, skip it\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// replace sequense of $ symbols with padded number  \r\n\t\t\t\tvar j = pos + 1;\r\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\r\n\t\t\t\tvar pad = j - pos;\r\n\t\t\t\t\r\n\t\t\t\t// get counter base\r\n\t\t\t\tvar base = 0, decrement = false, m;\r\n\t\t\t\tif ((m = str.substr(j).match(/^@(\\-?)(\\d*)/))) {\r\n\t\t\t\t\tj += m[0].length;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (m[1]) {\r\n\t\t\t\t\t\tdecrement = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbase = parseInt(m[2] || 1, 10) - 1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (decrement && total && typeof value === 'number') {\r\n\t\t\t\t\tvalue = total - value + 1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvalue += base;\r\n\t\t\t\t\r\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if string matches against <code>reTag</code> regexp. This \r\n\t\t * function may be used to test if provided string contains HTML tags\r\n\t\t * @param {String} str\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tmatchesTag: function(str) {\r\n\t\t\treturn this.reTag.test(str || '');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\r\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\r\n\t\t * to make sure that existing special characters won't be altered\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tescapeText: function(text) {\r\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tunescapeText: function(text) {\r\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns caret placeholder\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetCaretPlaceholder: function() {\r\n\t\t\treturn typeof caretPlaceholder === 'function'\r\n\t\t\t\t? caretPlaceholder.apply(this, arguments)\r\n\t\t\t\t: caretPlaceholder;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets new representation for carets in generated output\r\n\t\t * @param {String} value New caret placeholder. Might be a \r\n\t\t * <code>Function</code>\r\n\t\t */\r\n\t\tsetCaretPlaceholder: function(value) {\r\n\t\t\tcaretPlaceholder = value;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns line padding\r\n\t\t * @param {String} line\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetLinePadding: function(line) {\r\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Helper function that returns padding of line of <code>pos</code>\r\n\t\t * position in <code>content</code>\r\n\t\t * @param {String} content\r\n\t\t * @param {Number} pos\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetLinePaddingFromPosition: function(content, pos) {\r\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\r\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\r\n\t\t * regular expressions\r\n\t\t * @param {String} str\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tescapeForRegexp: function(str) {\r\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\r\n\t\t\treturn str.replace(specials, \"\\\\$&\");\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Make decimal number look good: convert it to fixed precision end remove\r\n\t\t * traling zeroes \r\n\t\t * @param {Number} num\r\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tprettifyNumber: function(num, fraction) {\r\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replace substring of <code>str</code> with <code>value</code>\r\n\t\t * @param {String} str String where to replace substring\r\n\t\t * @param {String} value New substring value\r\n\t\t * @param {Number} start Start index of substring to replace. May also\r\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\r\n\t\t * argument is not required\r\n\t\t * @param {Number} end End index of substring to replace. If ommited, \r\n\t\t * <code>start</code> argument is used\r\n\t\t */\r\n\t\treplaceSubstring: function(str, value, start, end) {\r\n\t\t\tif (typeof start === 'object' && 'end' in start) {\r\n\t\t\t\tend = start.end;\r\n\t\t\t\tstart = start.start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof end === 'string') {\r\n\t\t\t\tend = start + end.length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof end === 'undefined') {\r\n\t\t\t\tend = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (start < 0 || start > str.length)\r\n\t\t\t\treturn str;\r\n\t\t\t\r\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Fills substrings in `content`, defined by given ranges,\r\n\t\t * wich `ch` character\r\n\t\t * @param  {String} content\r\n\t\t * @param  {Array} ranges\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceWith: function(content, ranges, ch, noRepeat) {\r\n\t\t\tif (ranges.length) {\r\n\t\t\t\tvar offset = 0, fragments = [];\r\n\t\t\t\tranges.forEach(function(r) {\r\n\t\t\t\t\tvar repl = noRepeat ? ch : this.repeatString(ch, r[1] - r[0]);\r\n\t\t\t\t\tfragments.push(content.substring(offset, r[0]), repl);\r\n\t\t\t\t\toffset = r[1];\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tcontent = fragments.join('') + content.substring(offset);\r\n\t\t\t}\r\n\r\n\t\t\treturn content;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Narrows down text range, adjusting selection to non-space characters\r\n\t\t * @param {String} text\r\n\t\t * @param {Number} start Starting range in <code>text</code> where \r\n\t\t * slection should be adjusted. Can also be any object that is accepted\r\n\t\t * by <code>Range</code> class\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tnarrowToNonSpace: function(text, start, end) {\r\n\t\t\tvar rng = range.create(start, end);\r\n\t\t\t\r\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\r\n\t\t\t// narrow down selection until first non-space character\r\n\t\t\twhile (rng.start < rng.end) {\r\n\t\t\t\tif (!reSpace.test(text.charAt(rng.start)))\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\trng.start++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile (rng.end > rng.start) {\r\n\t\t\t\trng.end--;\r\n\t\t\t\tif (!reSpace.test(text.charAt(rng.end))) {\r\n\t\t\t\t\trng.end++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rng;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Find start and end index of text line for <code>from</code> index\r\n\t\t * @param {String} text \r\n\t\t * @param {Number} from\r\n\t\t */\r\n\t\tfindNewlineBounds: function(text, from) {\r\n\t\t\tvar len = text.length,\r\n\t\t\t\tstart = 0,\r\n\t\t\t\tend = len - 1, \r\n\t\t\t\tch;\r\n\r\n\t\t\t\r\n\t\t\t// search left\r\n\t\t\tfor (var i = from - 1; i > 0; i--) {\r\n\t\t\t\tch = text.charAt(i);\r\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\r\n\t\t\t\t\tstart = i + 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// search right\r\n\t\t\tfor (var j = from; j < len; j++) {\r\n\t\t\t\tch = text.charAt(j);\r\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\r\n\t\t\t\t\tend = j;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn range.create(start, end - start);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\r\n\t\t */\r\n\t\tdeepMerge: function() {\r\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\t\t\ttarget = arguments[0] || {},\r\n\t\t\t\ti = 1,\r\n\t\t\t\tlength = arguments.length;\r\n\r\n\r\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\r\n\t\t\tif (typeof target !== 'object' && typeof target !== 'function') {\r\n\t\t\t\ttarget = {};\r\n\t\t\t}\r\n\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t// Only deal with non-null/undefined values\r\n\t\t\t\tif ( (options = arguments[ i ]) !== null ) {\r\n\t\t\t\t\t// Extend the base object\r\n\t\t\t\t\tfor ( name in options ) {\r\n\t\t\t\t\t\tsrc = target[ name ];\r\n\t\t\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\t\t\tif ( target === copy ) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\t\t\tif ( copy && ( typeof copy === 'object' || (copyIsArray = Array.isArray(copy)) ) ) {\r\n\t\t\t\t\t\t\tif ( copyIsArray ) {\r\n\t\t\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tclone = src && typeof src === 'object' ? src : {};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\r\n\r\n\t\t\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Return the modified object\r\n\t\t\treturn target;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Dead simple string-to-JSON parser\r\n\t\t * @param {String} str\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tparseJSON: function(str) {\r\n\t\t\tif (typeof str == 'object') {\r\n\t\t\t\treturn str;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\treturn JSON.parse(str);\r\n\t\t\t} catch(e) {\r\n\t\t\t\treturn {};\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\t/**************************\r\n\t\t * Utility belt\r\n\t\t **************************/\r\n\t\tunique: function(arr, comparator) {\r\n\t\t\tvar lookup = [];\r\n\t\t\treturn arr.filter(function(item) {\r\n\t\t\t\tvar val = comparator ? comparator(item) : item;\r\n\t\t\t\tif (lookup.indexOf(val) < 0) {\r\n\t\t\t\t\tlookup.push(val);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Return a copy of the object, filtered to only have values for \r\n\t\t * the whitelisted keys. \r\n\t\t * @param  {Object} obj\r\n\t\t * @return {Object}\r\n\t\t */\r\n\t\tpick: function(obj) {\r\n\t\t\tvar result = {};\r\n\t\t\tvar keys = this.toArray(arguments, 1);\r\n\t\t\tObject.keys(obj).forEach(function(key) {\r\n\t\t\t\tif (~keys.indexOf(key)) {\r\n\t\t\t\t\tresult[key] = obj[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\tfind: function(arr, comparator, ctx) {\r\n\t\t\tvar result;\r\n\t\t\tif (ctx) {\r\n\t\t\t\tcomparator = comparator.bind(ctx);\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(arr)) {\r\n\t\t\t\tarr.some(function(item, i) {\r\n\t\t\t\t\tif (comparator(item, i)) {\r\n\t\t\t\t\t\treturn result = item;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tObject.keys(arr).some(function(key, i) {\r\n\t\t\t\t\tif (comparator(arr[key], i)) {\r\n\t\t\t\t\t\treturn result = arr[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\ttoArray: function(obj, sliceIx) {\r\n\t\t\tif (Array.isArray(obj) && !sliceIx) {\r\n\t\t\t\treturn obj;\r\n\t\t\t}\r\n\t\t\treturn Array.prototype.slice.call(obj, sliceIx || 0);\r\n\t\t},\r\n\r\n\t\textend: function(obj) {\r\n\t\t\tfor (var i = 1, il = arguments.length, a; i < il; i++) {\r\n\t\t\t\ta = arguments[i];\r\n\t\t\t\tif (a) {\r\n\t\t\t\t\tObject.keys(a).forEach(function(key) {\r\n\t\t\t\t\t\tobj[key] = a[key];\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tdefaults: function(obj) {\r\n\t\t\tfor (var i = 1, il = arguments.length, a; i < il; i++) {\r\n\t\t\t\ta = arguments[i];\r\n\t\t\t\tif (a) {\r\n\t\t\t\t\tObject.keys(a).forEach(function(key) {\r\n\t\t\t\t\t\tif (!(key in obj)) {\r\n\t\t\t\t\t\t\tobj[key] = a[key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tflatten: function(arr, out) {\r\n\t\t\tout = out || [];\r\n\t\t\tvar self = this;\r\n\t\t\tself.toArray(arr).forEach(function(item) {\r\n\t\t\t\tif (Array.isArray(item)) {\r\n\t\t\t\t\tself.flatten(item, out);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tout.push(item);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\tclone: function(obj) {\r\n\t\t\tif (Array.isArray(obj)) {\r\n\t\t\t\treturn obj.slice(0);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.extend({}, obj);\r\n\t\t},\r\n\r\n\t\twithout: function(arr) {\r\n\t\t\tthis.toArray(arguments, 1).forEach(function(item) {\r\n\t\t\t\tvar ix;\r\n\t\t\t\twhile (~(ix = arr.indexOf(item))) {\r\n\t\t\t\t\tarr.splice(ix, 1);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn arr;\r\n\t\t},\r\n\r\n\t\tlast: function(arr) {\r\n\t\t\treturn arr[arr.length - 1];\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/range\":\"assets\\\\range.js\"}],\"utils\\\\cssSections.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar commentsUtils = require('./comments');\r\n\tvar range = require('../assets/range');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar cssParser = require('../parser/css');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\r\n\tvar idCounter = 1;\r\n\tvar maxId = 1000000;\r\n\r\n\tvar reSpaceTrim = /^(\\s*).+?(\\s*)$/;\r\n\tvar reSpace = /\\s/g;\r\n\tvar reComma = /,/;\r\n\r\n\tfunction isQuote(ch) {\r\n\t\treturn ch == '\"' || ch == \"'\";\r\n\t}\r\n\r\n\tfunction getId() {\r\n\t\tidCounter = (idCounter + 1) % maxId;\r\n\t\treturn 's' + idCounter;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Range} range Full selector range with additional\r\n\t * properties for matching name and content (@see findAllRules())\r\n\t * @param {String} source CSS source\r\n\t */\r\n\tfunction CSSSection(rng, source) {\r\n\t\tthis.id = getId();\r\n\t\t/** @type {CSSSection} */\r\n\t\tthis.parent = null;\r\n\t\t/** @type {CSSSection} */\r\n\t\tthis.nextSibling = null;\r\n\t\t/** @type {CSSSection} */\r\n\t\tthis.previousSibling = null;\r\n\t\tthis._source = source;\r\n\t\tthis._name = null;\r\n\t\tthis._content = null;\r\n\r\n\t\t/**\r\n\t\t * Custom data for current nodes, used by other modules for\r\n\t\t * caching etc.\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis._data = {};\r\n\r\n\t\tif (!rng && source) {\r\n\t\t\trng = range(0, source);\r\n\t\t}\r\n\r\n\t\tthis.range = rng;\r\n\t\tthis.children = [];\r\n\t}\r\n\r\n\tCSSSection.prototype = {\r\n\t\taddChild: function(section) {\r\n\t\t\tif (!(section instanceof CSSSection)) {\r\n\t\t\t\tsection = new CSSSection(section);\r\n\t\t\t}\r\n\r\n\t\t\tvar lastChild = utils.last(this.children);\r\n\t\t\tif (lastChild) {\r\n\t\t\t\tlastChild.nextSibling = section;\r\n\t\t\t\tsection.previousSibling = lastChild;\r\n\t\t\t}\r\n\t\t\tsection.parent = this;\r\n\r\n\t\t\tthis.children.push(section);\r\n\t\t\treturn section;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns root node\r\n\t\t * @return {CSSSection}\r\n\t\t */\r\n\t\troot: function() {\r\n\t\t\tvar root = this;\r\n\t\t\tdo {\r\n\t\t\t\tif (!root.parent) {\r\n\t\t\t\t\treturn root;\r\n\t\t\t\t}\r\n\t\t\t} while(root = root.parent);\r\n\r\n\t\t\treturn root;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns currect CSS source\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tsource: function() {\r\n\t\t\treturn this._source || this.root()._source;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns section name\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tname: function() {\r\n\t\t\tif (this._name === null) {\r\n\t\t\t\tvar range = this.nameRange();\r\n\t\t\t\tif (range) {\r\n\t\t\t\t\tthis._name = range.substring(this.source());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns section name range\r\n\t\t * @return {[type]} [description]\r\n\t\t */\r\n\t\tnameRange: function() {\r\n\t\t\tif (this.range && '_selectorEnd' in this.range) {\r\n\t\t\t\treturn range.create2(this.range.start, this.range._selectorEnd);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns deepest child of current section (or section itself) \r\n\t\t * which includes given position.\r\n\t\t * @param  {Number} pos\r\n\t\t * @return {CSSSection}\r\n\t\t */\r\n\t\tmatchDeep: function(pos) {\r\n\t\t\tif (!this.range.inside(pos)) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0, il = this.children.length, m; i < il; i++) {\r\n\t\t\t\tm = this.children[i].matchDeep(pos);\r\n\t\t\t\tif (m) {\r\n\t\t\t\t\treturn m;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\treturn this.parent ? this : null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns current and all nested sections ranges\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tallRanges: function() {\r\n\t\t\tvar out = [];\r\n\t\t\tif (this.parent) {\r\n\t\t\t\t// add current range if it is not root node\r\n\t\t\t\tout.push(this.range);\r\n\t\t\t}\r\n\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tout = out.concat(child.allRanges());\r\n\t\t\t});\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\tdata: function(key, value) {\r\n\t\t\tif (typeof value !== 'undefined') {\r\n\t\t\t\tthis._data[key] = value;\r\n\t\t\t}\r\n\r\n\t\t\treturn this._data[key];\r\n\t\t},\r\n\r\n\t\tstringify: function(indent) {\r\n\t\t\tindent = indent || '';\r\n\t\t\tvar out = '';\r\n\t\t\tthis.children.forEach(function(item) {\r\n\t\t\t\tout += indent + item.name().replace(/\\n/g, '\\\\n') + '\\n';\r\n\t\t\t\tout += item.stringify(indent + '--');\r\n\t\t\t});\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns current section’s actual content,\r\n\t\t * e.g. content without nested sections\r\n\t\t * @return {String} \r\n\t\t */\r\n\t\tcontent: function() {\r\n\t\t\tif (this._content !== null) {\r\n\t\t\t\treturn this._content;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.range || !('_contentStart' in this.range)) {\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\r\n\t\t\tvar r = range.create2(this.range._contentStart + 1, this.range.end - 1);\r\n\t\t\tvar source = this.source();\r\n\t\t\tvar start = r.start;\r\n\t\t\tvar out = '';\r\n\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tout += source.substring(start, child.range.start);\r\n\t\t\t\tstart = child.range.end;\r\n\t\t\t});\r\n\r\n\t\t\tout += source.substring(start, r.end);\r\n\t\t\treturn this._content = utils.trim(out);\r\n\t\t}\r\n\t};\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Finds all CSS rules‘ ranges in given CSS source\r\n\t\t * @param  {String} content CSS source\r\n\t\t * @return {Array} Array of ranges\r\n\t\t */\r\n\t\tfindAllRules: function(content) {\r\n\t\t\tcontent = this.sanitize(content);\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tvar ranges = [], matchedRanges;\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tvar saveRule = function(r) {\r\n\t\t\t\tvar selRange = self.extractSelector(content, r.start);\r\n\t\t\t\tvar rule = range.create2(selRange.start, r.end);\r\n\t\t\t\trule._selectorEnd = selRange.end;\r\n\t\t\t\trule._contentStart = r.start;\r\n\t\t\t\tranges.push(rule);\r\n\t\t\t};\r\n\r\n\t\t\tvar ch;\r\n\t\t\twhile (ch = stream.next()) {\r\n\t\t\t\tif (isQuote(ch)) {\r\n\t\t\t\t\tif (!stream.skipString(ch)) {\r\n\t\t\t\t\t\tbreak; // unterminated string\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ch == '{') {\r\n\t\t\t\t\tmatchedRanges = this.matchBracesRanges(content, stream.pos - 1);\r\n\t\t\t\t\tmatchedRanges.forEach(saveRule);\r\n\r\n\t\t\t\t\tif (matchedRanges.length) {\r\n\t\t\t\t\t\tstream.pos = utils.last(matchedRanges).end;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t} \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn ranges.sort(function(a, b) {\r\n\t\t\t\treturn a.start - b.start;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Matches curly braces content right after given position\r\n\t\t * @param  {String} content CSS content. Must not contain comments!\r\n\t\t * @param  {Number} pos     Search start position\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tmatchBracesRanges: function(content, pos, sanitize) {\r\n\t\t\tif (sanitize) {\r\n\t\t\t\tcontent = this.sanitize(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tstream.start = stream.pos = pos;\r\n\t\t\tvar stack = [], ranges = [];\r\n\t\t\tvar ch;\r\n\t\t\twhile (ch = stream.next()) {\r\n\t\t\t\tif (ch == '{') {\r\n\t\t\t\t\tstack.push(stream.pos - 1);\r\n\t\t\t\t} else if (ch == '}') {\r\n\t\t\t\t\tif (!stack.length) {\r\n\t\t\t\t\t\tthrow 'Invalid source structure (check for curly braces)';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tranges.push(range.create2(stack.pop(), stream.pos));\r\n\t\t\t\t\tif (!stack.length) {\r\n\t\t\t\t\t\treturn ranges;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream.skipQuoted();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn ranges;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts CSS selector from CSS document from\r\n\t\t * given position. The selector is located by moving backward\r\n\t\t * from given position which means that passed position\r\n\t\t * must point to the end of selector \r\n\t\t * @param  {String}  content CSS source\r\n\t\t * @param  {Number}  pos     Search position\r\n\t\t * @param  {Boolean} sanitize Sanitize CSS source before processing.\r\n\t\t * Off by default and assumes that CSS must be comment-free already\r\n\t\t * (for performance)\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\textractSelector: function(content, pos, sanitize) {\r\n\t\t\tif (sanitize) {\r\n\t\t\t\tcontent = this.sanitize(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar skipString = function() {\r\n\t\t\t\tvar quote = content.charAt(pos);\r\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\r\n\t\t\t\t\twhile (--pos >= 0) {\r\n\t\t\t\t\t\tif (content.charAt(pos) == quote && content.charAt(pos - 1) != '\\\\') {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\t// find CSS selector\r\n\t\t\tvar ch;\r\n\t\t\tvar endPos = pos;\r\n\t\t\twhile (--pos >= 0) {\r\n\t\t\t\tif (skipString()) continue;\r\n\r\n\t\t\t\tch = content.charAt(pos);\r\n\t\t\t\tif (ch == ')') {\r\n\t\t\t\t\t// looks like it’s a preprocessor thing,\r\n\t\t\t\t\t// most likely a mixin arguments list, e.g.\r\n\t\t\t\t\t// .mixin (@arg1; @arg2) {...}\r\n\t\t\t\t\twhile (--pos >= 0) {\r\n\t\t\t\t\t\tif (skipString()) continue;\r\n\r\n\t\t\t\t\t\tif (content.charAt(pos) == '(') {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ch == '{' || ch == '}' || ch == ';') {\r\n\t\t\t\t\tpos++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pos < 0) {\r\n\t\t\t\tpos = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar selector = content.substring(pos, endPos);\r\n\r\n\t\t\t// trim whitespace from matched selector\r\n\t\t\tvar m = selector.replace(reSpace, ' ').match(reSpaceTrim);\r\n\t\t\tif (m) {\r\n\t\t\t\tpos += m[1].length;\r\n\t\t\t\tendPos -= m[2].length;\r\n\t\t\t}\r\n\r\n\t\t\treturn range.create2(pos, endPos);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Search for nearest CSS rule/section that contains\r\n\t\t * given position\r\n\t\t * @param  {String} content CSS content or matched CSS rules (array of ranges)\r\n\t\t * @param  {Number} pos     Search position\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tmatchEnclosingRule: function(content, pos) {\r\n\t\t\tif (typeof content === 'string') {\r\n\t\t\t\tcontent = this.findAllRules(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar rules = content.filter(function(r) {\r\n\t\t\t\treturn r.inside(pos);\r\n\t\t\t});\r\n\r\n\t\t\treturn utils.last(rules);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Locates CSS rule next or before given position\r\n\t\t * @param  {String}  content    CSS content\r\n\t\t * @param  {Number}  pos        Search start position\r\n\t\t * @param  {Boolean} isBackward Search backward (find previous rule insteaf of next one)\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tlocateRule: function(content, pos, isBackward) {\r\n\t\t\t// possible case: editor reported that current syntax is\r\n\t\t\t// CSS, but it’s actually a HTML document (either `style` tag or attribute)\r\n\t\t\tvar offset = 0;\r\n\t\t\tvar subrange = this.styleTagRange(content, pos);\r\n\t\t\tif (subrange) {\r\n\t\t\t\toffset = subrange.start;\r\n\t\t\t\tpos -= subrange.start;\r\n\t\t\t\tcontent = subrange.substring(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar rules = this.findAllRules(content);\r\n\t\t\tvar ctxRule = this.matchEnclosingRule(rules, pos);\r\n\r\n\t\t\tif (ctxRule) {\r\n\t\t\t\treturn ctxRule.shift(offset);\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0, il = rules.length; i < il; i++) {\r\n\t\t\t\tif (rules[i].start > pos) {\r\n\t\t\t\t\treturn rules[isBackward && i > 0 ? i - 1 : i].shift(offset);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sanitizes given CSS content: replaces content that may \r\n\t\t * interfere with parsing (comments, interpolations, etc.)\r\n\t\t * with spaces. Sanitized content MUST NOT be used for\r\n\t\t * editing or outputting, it just simplifies searching\r\n\t\t * @param  {String} content CSS content\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tsanitize: function(content) {\r\n\t\t\tcontent = commentsUtils.strip(content);\r\n\r\n\t\t\t// remove preprocessor string interpolations like #{var}\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tvar replaceRanges = [];\r\n\t\t\tvar ch, ch2;\r\n\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (isQuote(ch)) {\r\n\t\t\t\t\t// skip string\r\n\t\t\t\t\tstream.skipString(ch)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (ch === '#' || ch === '@') {\r\n\t\t\t\t\tch2 = stream.peek();\r\n\t\t\t\t\tif (ch2 === '{') { // string interpolation\r\n\t\t\t\t\t\tstream.start = stream.pos - 1;\r\n\r\n\t\t\t\t\t\tif (stream.skipTo('}')) {\r\n\t\t\t\t\t\t\tstream.pos += 1;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow 'Invalid string interpolation at ' + stream.start;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn utils.replaceWith(content, replaceRanges, 'a');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses and returns all sections in given CSS\r\n\t\t * as tree-like structure, e.g. provides nesting\r\n\t\t * info\r\n\t\t * @param  {String} content CSS content\r\n\t\t * @return {CSSSection}\r\n\t\t */\r\n\t\tsectionTree: function(content) {\r\n\t\t\tvar root = new CSSSection(null, content);\r\n\t\t\tvar rules = this.findAllRules(content);\r\n\r\n\t\t\t// rules are sorted in order they appear in CSS source\r\n\t\t\t// so we can optimize their nesting routine\r\n\t\t\tvar insert = function(range, ctx) {\r\n\t\t\t\twhile (ctx && ctx.range) {\r\n\t\t\t\t\tif (ctx.range.contains(range)) {\r\n\t\t\t\t\t\treturn ctx.addChild(range);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tctx = ctx.parent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if we are here then given range is a top-level section\r\n\t\t\t\treturn root.addChild(range);\r\n\t\t\t};\r\n\r\n\t\t\tvar ctx = root;\r\n\t\t\trules.forEach(function(r) {\r\n\t\t\t\tctx = insert(r, ctx);\r\n\t\t\t});\r\n\r\n\t\t\treturn root;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns ranges for all nested sections, available in\r\n\t\t * given CSS rule\r\n\t\t * @param  {CSSEditContainer} rule\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tnestedSectionsInRule: function(rule) {\r\n\t\t\tvar offset = rule.valueRange(true).start;\r\n\t\t\tvar nestedSections = this.findAllRules(rule.valueRange().substring(rule.source));\r\n\t\t\tnestedSections.forEach(function(section) {\r\n\t\t\t\tsection.start += offset;\r\n\t\t\t\tsection.end += offset;\r\n\t\t\t\tsection._selectorEnd += offset;\r\n\t\t\t\tsection._contentStart += offset;\r\n\t\t\t});\r\n\t\t\treturn nestedSections;\r\n\t\t},\r\n\r\n\t\tstyleTagRange: function(content, pos) {\r\n\t\t\tvar tag = htmlMatcher.tag(content, pos);\r\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \r\n\t\t\t\t&& tag.innerRange.cmp(pos, 'lte', 'gte')\r\n\t\t\t\t&& tag.innerRange;\r\n\t\t},\r\n\r\n\t\tstyleAttrRange: function(content, pos) {\r\n\t\t\tvar tree = xmlEditTree.parseFromPosition(content, pos, true);\r\n\t\t\tif (tree) {\r\n\t\t\t\tvar attr = tree.itemFromPosition(pos, true);\r\n\t\t\t\treturn attr && attr.name().toLowerCase() == 'style' \r\n\t\t\t\t\t&& attr.valueRange(true).cmp(pos, 'lte', 'gte')\r\n\t\t\t\t\t&& attr.valueRange(true);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tCSSSection: CSSSection\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/css\":\"parser\\\\css.js\",\"./comments\":\"utils\\\\comments.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\editor.js\":[function(require,module,exports){\r\n/**\r\n * Utility module used to prepare text for pasting into back-end editor\r\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\treturn  {\r\n\t\t/**\r\n\t\t * Check if cursor is placed inside XHTML tag\r\n\t\t * @param {String} html Contents of the document\r\n\t\t * @param {Number} caretPos Current caret position inside tag\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisInsideTag: function(html, caretPos) {\r\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\r\n\t\t\t\r\n\t\t\t// search left to find opening brace\r\n\t\t\tvar pos = caretPos;\r\n\t\t\twhile (pos > -1) {\r\n\t\t\t\tif (html.charAt(pos) == '<') \r\n\t\t\t\t\tbreak;\r\n\t\t\t\tpos--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (pos != -1) {\r\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\r\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sanitizes incoming editor data and provides default values for\r\n\t\t * output-specific info\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {String} syntax\r\n\t\t * @param {String} profile\r\n\t\t */\r\n\t\toutputInfo: function(editor, syntax, profile) {\r\n\t\t\t// most of this code makes sense for Java/Rhino environment\r\n\t\t\t// because string that comes from Java are not actually JS string\r\n\t\t\t// but Java String object so the have to be explicitly converted\r\n\t\t\t// to native string\r\n\t\t\tprofile = profile || editor.getProfileName();\r\n\t\t\treturn  {\r\n\t\t\t\t/** @memberOf outputInfo */\r\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\r\n\t\t\t\tprofile: profile || null,\r\n\t\t\t\tcontent: String(editor.getContent())\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Unindent content, thus preparing text for tag wrapping\r\n\t\t * @param {IEmmetEditor} editor Editor instance\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tunindent: function(editor, text) {\r\n\t\t\treturn utils.unindentString(text, this.getCurrentLinePadding(editor));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns padding of current editor's line\r\n\t\t * @param {IEmmetEditor} Editor instance\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetCurrentLinePadding: function(editor) {\r\n\t\t\treturn utils.getLinePadding(editor.getCurrentLine());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Normalizes content according to given preferences, e.g.\r\n\t\t * replaces newlines and indentation with ones defined in\r\n\t\t * `options`. If options are not provided or incomplete, \r\n\t\t * values will be taken from current user environment\r\n\t\t * @param {String} text\r\n\t\t * @param {Object} options\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tnormalize: function(text, options) {\r\n\t\t\toptions = utils.extend({\r\n\t\t\t\tnewline: resources.getNewline(),\r\n\t\t\t\tindentation: resources.getVariable('indentation')\r\n\t\t\t}, options);\r\n\r\n\t\t\tvar indent = function(tabs) {\r\n\t\t\t\treturn utils.repeatString(options.indentation, tabs.length);\r\n\t\t\t};\r\n\r\n\t\t\tvar lines = utils.splitByLines(text);\r\n\r\n\t\t\t// normailze indentation if it’s not tabs\r\n\t\t\tif (options.indentation !== '\\t') {\r\n\t\t\t\tlines = lines.map(function(line) {\r\n\t\t\t\t\treturn line.replace(/^\\s+/, function(space) {\r\n\t\t\t\t\t\treturn space.replace(/\\t/g, indent);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// normalize newlines\r\n\t\t\treturn lines.join(options.newline);\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/resources\":\"assets\\\\resources.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\math.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/*\r\n\t Source: https://github.com/silentmatt/js-expression-eval\r\n\r\n\t Based on ndef.parser, by Raphael Graf(r@undefined.ch)\r\n\t http://www.undefined.ch/mparser/index.html\r\n\r\n\t Ported to JavaScript and modified by Matthew Crumley (email@matthewcrumley.com, http://silentmatt.com/)\r\n\r\n\t You are free to use and modify this code in anyway you find useful. Please leave this comment in the code\r\n\t to acknowledge its original source. If you feel like it, I enjoy hearing about projects that use my code,\r\n\t but don't feel like you have to let me know or ask permission.\r\n\t*/\r\n\r\n\tfunction object(o) {\r\n\t\tfunction F() {}\r\n\t\tF.prototype = o;\r\n\t\treturn new F();\r\n\t}\r\n\r\n\tvar TNUMBER = 0;\r\n\tvar TOP1 = 1;\r\n\tvar TOP2 = 2;\r\n\tvar TVAR = 3;\r\n\tvar TFUNCALL = 4;\r\n\r\n\tfunction Token(type_, index_, prio_, number_) {\r\n\t\tthis.type_ = type_;\r\n\t\tthis.index_ = index_ || 0;\r\n\t\tthis.prio_ = prio_ || 0;\r\n\t\tthis.number_ = (number_ !== undefined && number_ !== null) ? number_ : 0;\r\n\t\tthis.toString = function () {\r\n\t\t\tswitch (this.type_) {\r\n\t\t\tcase TNUMBER:\r\n\t\t\t\treturn this.number_;\r\n\t\t\tcase TOP1:\r\n\t\t\tcase TOP2:\r\n\t\t\tcase TVAR:\r\n\t\t\t\treturn this.index_;\r\n\t\t\tcase TFUNCALL:\r\n\t\t\t\treturn \"CALL\";\r\n\t\t\tdefault:\r\n\t\t\t\treturn \"Invalid Token\";\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction Expression(tokens, ops1, ops2, functions) {\r\n\t\tthis.tokens = tokens;\r\n\t\tthis.ops1 = ops1;\r\n\t\tthis.ops2 = ops2;\r\n\t\tthis.functions = functions;\r\n\t}\r\n\r\n\t// Based on http://www.json.org/json2.js\r\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n        escapable = /[\\\\\\'\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n        meta = {    // table of character substitutions\r\n            '\\b': '\\\\b',\r\n            '\\t': '\\\\t',\r\n            '\\n': '\\\\n',\r\n            '\\f': '\\\\f',\r\n            '\\r': '\\\\r',\r\n            \"'\" : \"\\\\'\",\r\n            '\\\\': '\\\\\\\\'\r\n        };\r\n\r\n\tfunction escapeValue(v) {\r\n\t\tif (typeof v === \"string\") {\r\n\t\t\tescapable.lastIndex = 0;\r\n\t        return escapable.test(v) ?\r\n\t            \"'\" + v.replace(escapable, function (a) {\r\n\t                var c = meta[a];\r\n\t                return typeof c === 'string' ? c :\r\n\t                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n\t            }) + \"'\" :\r\n\t            \"'\" + v + \"'\";\r\n\t\t}\r\n\t\treturn v;\r\n\t}\r\n\r\n\tExpression.prototype = {\r\n\t\tsimplify: function (values) {\r\n\t\t\tvalues = values || {};\r\n\t\t\tvar nstack = [];\r\n\t\t\tvar newexpression = [];\r\n\t\t\tvar n1;\r\n\t\t\tvar n2;\r\n\t\t\tvar f;\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TNUMBER) {\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TVAR && (item.index_ in values)) {\r\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, values[item.index_]);\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP2 && nstack.length > 1) {\r\n\t\t\t\t\tn2 = nstack.pop();\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops2[item.index_];\r\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, f(n1.number_, n2.number_));\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP1 && nstack.length > 0) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops1[item.index_];\r\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, f(n1.number_));\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\twhile (nstack.length > 0) {\r\n\t\t\t\t\t\tnewexpression.push(nstack.shift());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewexpression.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (nstack.length > 0) {\r\n\t\t\t\tnewexpression.push(nstack.shift());\r\n\t\t\t}\r\n\r\n\t\t\treturn new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));\r\n\t\t},\r\n\r\n\t\tsubstitute: function (variable, expr) {\r\n\t\t\tif (!(expr instanceof Expression)) {\r\n\t\t\t\texpr = new Parser().parse(String(expr));\r\n\t\t\t}\r\n\t\t\tvar newexpression = [];\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TVAR && item.index_ === variable) {\r\n\t\t\t\t\tfor (var j = 0; j < expr.tokens.length; j++) {\r\n\t\t\t\t\t\tvar expritem = expr.tokens[j];\r\n\t\t\t\t\t\tvar replitem = new Token(expritem.type_, expritem.index_, expritem.prio_, expritem.number_);\r\n\t\t\t\t\t\tnewexpression.push(replitem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewexpression.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar ret = new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));\r\n\t\t\treturn ret;\r\n\t\t},\r\n\r\n\t\tevaluate: function (values) {\r\n\t\t\tvalues = values || {};\r\n\t\t\tvar nstack = [];\r\n\t\t\tvar n1;\r\n\t\t\tvar n2;\r\n\t\t\tvar f;\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TNUMBER) {\r\n\t\t\t\t\tnstack.push(item.number_);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP2) {\r\n\t\t\t\t\tn2 = nstack.pop();\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops2[item.index_];\r\n\t\t\t\t\tnstack.push(f(n1, n2));\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TVAR) {\r\n\t\t\t\t\tif (item.index_ in values) {\r\n\t\t\t\t\t\tnstack.push(values[item.index_]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (item.index_ in this.functions) {\r\n\t\t\t\t\t\tnstack.push(this.functions[item.index_]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"undefined variable: \" + item.index_);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP1) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops1[item.index_];\r\n\t\t\t\t\tnstack.push(f(n1));\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TFUNCALL) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = nstack.pop();\r\n\t\t\t\t\tif (f.apply && f.call) {\r\n\t\t\t\t\t\tif (Object.prototype.toString.call(n1) == \"[object Array]\") {\r\n\t\t\t\t\t\t\tnstack.push(f.apply(undefined, n1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnstack.push(f.call(undefined, n1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(f + \" is not a function\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error(\"invalid Expression\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nstack.length > 1) {\r\n\t\t\t\tthrow new Error(\"invalid Expression (parity)\");\r\n\t\t\t}\r\n\t\t\treturn nstack[0];\r\n\t\t},\r\n\r\n\t\ttoString: function (toJS) {\r\n\t\t\tvar nstack = [];\r\n\t\t\tvar n1;\r\n\t\t\tvar n2;\r\n\t\t\tvar f;\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TNUMBER) {\r\n\t\t\t\t\tnstack.push(escapeValue(item.number_));\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP2) {\r\n\t\t\t\t\tn2 = nstack.pop();\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = item.index_;\r\n\t\t\t\t\tif (toJS && f == \"^\") {\r\n\t\t\t\t\t\tnstack.push(\"Math.pow(\" + n1 + \",\" + n2 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tnstack.push(\"(\" + n1 + f + n2 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TVAR) {\r\n\t\t\t\t\tnstack.push(item.index_);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP1) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = item.index_;\r\n\t\t\t\t\tif (f === \"-\") {\r\n\t\t\t\t\t\tnstack.push(\"(\" + f + n1 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tnstack.push(f + \"(\" + n1 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TFUNCALL) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = nstack.pop();\r\n\t\t\t\t\tnstack.push(f + \"(\" + n1 + \")\");\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error(\"invalid Expression\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nstack.length > 1) {\r\n\t\t\t\tthrow new Error(\"invalid Expression (parity)\");\r\n\t\t\t}\r\n\t\t\treturn nstack[0];\r\n\t\t},\r\n\r\n\t\tvariables: function () {\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar vars = [];\r\n\t\t\tfor (var i = 0; i < L; i++) {\r\n\t\t\t\tvar item = this.tokens[i];\r\n\t\t\t\tif (item.type_ === TVAR && (vars.indexOf(item.index_) == -1)) {\r\n\t\t\t\t\tvars.push(item.index_);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn vars;\r\n\t\t},\r\n\r\n\t\ttoJSFunction: function (param, variables) {\r\n\t\t\tvar f = new Function(param, \"with(Parser.values) { return \" + this.simplify(variables).toString(true) + \"; }\");\r\n\t\t\treturn f;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction add(a, b) {\r\n\t\treturn Number(a) + Number(b);\r\n\t}\r\n\tfunction sub(a, b) {\r\n\t\treturn a - b; \r\n\t}\r\n\tfunction mul(a, b) {\r\n\t\treturn a * b;\r\n\t}\r\n\tfunction div(a, b) {\r\n\t\treturn a / b;\r\n\t}\r\n\tfunction mod(a, b) {\r\n\t\treturn a % b;\r\n\t}\r\n\tfunction concat(a, b) {\r\n\t\treturn \"\" + a + b;\r\n\t}\r\n\r\n\tfunction neg(a) {\r\n\t\treturn -a;\r\n\t}\r\n\r\n\tfunction random(a) {\r\n\t\treturn Math.random() * (a || 1);\r\n\t}\r\n\tfunction fac(a) { //a!\r\n\t\ta = Math.floor(a);\r\n\t\tvar b = a;\r\n\t\twhile (a > 1) {\r\n\t\t\tb = b * (--a);\r\n\t\t}\r\n\t\treturn b;\r\n\t}\r\n\r\n\t// TODO: use hypot that doesn't overflow\r\n\tfunction pyt(a, b) {\r\n\t\treturn Math.sqrt(a * a + b * b);\r\n\t}\r\n\r\n\tfunction append(a, b) {\r\n\t\tif (Object.prototype.toString.call(a) != \"[object Array]\") {\r\n\t\t\treturn [a, b];\r\n\t\t}\r\n\t\ta = a.slice();\r\n\t\ta.push(b);\r\n\t\treturn a;\r\n\t}\r\n\r\n\tfunction Parser() {\r\n\t\tthis.success = false;\r\n\t\tthis.errormsg = \"\";\r\n\t\tthis.expression = \"\";\r\n\r\n\t\tthis.pos = 0;\r\n\r\n\t\tthis.tokennumber = 0;\r\n\t\tthis.tokenprio = 0;\r\n\t\tthis.tokenindex = 0;\r\n\t\tthis.tmpprio = 0;\r\n\r\n\t\tthis.ops1 = {\r\n\t\t\t\"sin\": Math.sin,\r\n\t\t\t\"cos\": Math.cos,\r\n\t\t\t\"tan\": Math.tan,\r\n\t\t\t\"asin\": Math.asin,\r\n\t\t\t\"acos\": Math.acos,\r\n\t\t\t\"atan\": Math.atan,\r\n\t\t\t\"sqrt\": Math.sqrt,\r\n\t\t\t\"log\": Math.log,\r\n\t\t\t\"abs\": Math.abs,\r\n\t\t\t\"ceil\": Math.ceil,\r\n\t\t\t\"floor\": Math.floor,\r\n\t\t\t\"round\": Math.round,\r\n\t\t\t\"-\": neg,\r\n\t\t\t\"exp\": Math.exp\r\n\t\t};\r\n\r\n\t\tthis.ops2 = {\r\n\t\t\t\"+\": add,\r\n\t\t\t\"-\": sub,\r\n\t\t\t\"*\": mul,\r\n\t\t\t\"/\": div,\r\n\t\t\t\"%\": mod,\r\n\t\t\t\"^\": Math.pow,\r\n\t\t\t\",\": append,\r\n\t\t\t\"||\": concat\r\n\t\t};\r\n\r\n\t\tthis.functions = {\r\n\t\t\t\"random\": random,\r\n\t\t\t\"fac\": fac,\r\n\t\t\t\"min\": Math.min,\r\n\t\t\t\"max\": Math.max,\r\n\t\t\t\"pyt\": pyt,\r\n\t\t\t\"pow\": Math.pow,\r\n\t\t\t\"atan2\": Math.atan2\r\n\t\t};\r\n\r\n\t\tthis.consts = {\r\n\t\t\t\"E\": Math.E,\r\n\t\t\t\"PI\": Math.PI\r\n\t\t};\r\n\t}\r\n\r\n\tParser.parse = function (expr) {\r\n\t\treturn new Parser().parse(expr);\r\n\t};\r\n\r\n\tParser.evaluate = function (expr, variables) {\r\n\t\treturn Parser.parse(expr).evaluate(variables);\r\n\t};\r\n\r\n\tParser.Expression = Expression;\r\n\r\n\tParser.values = {\r\n\t\tsin: Math.sin,\r\n\t\tcos: Math.cos,\r\n\t\ttan: Math.tan,\r\n\t\tasin: Math.asin,\r\n\t\tacos: Math.acos,\r\n\t\tatan: Math.atan,\r\n\t\tsqrt: Math.sqrt,\r\n\t\tlog: Math.log,\r\n\t\tabs: Math.abs,\r\n\t\tceil: Math.ceil,\r\n\t\tfloor: Math.floor,\r\n\t\tround: Math.round,\r\n\t\trandom: random,\r\n\t\tfac: fac,\r\n\t\texp: Math.exp,\r\n\t\tmin: Math.min,\r\n\t\tmax: Math.max,\r\n\t\tpyt: pyt,\r\n\t\tpow: Math.pow,\r\n\t\tatan2: Math.atan2,\r\n\t\tE: Math.E,\r\n\t\tPI: Math.PI\r\n\t};\r\n\r\n\tvar PRIMARY      = 1 << 0;\r\n\tvar OPERATOR     = 1 << 1;\r\n\tvar FUNCTION     = 1 << 2;\r\n\tvar LPAREN       = 1 << 3;\r\n\tvar RPAREN       = 1 << 4;\r\n\tvar COMMA        = 1 << 5;\r\n\tvar SIGN         = 1 << 6;\r\n\tvar CALL         = 1 << 7;\r\n\tvar NULLARY_CALL = 1 << 8;\r\n\r\n\tParser.prototype = {\r\n\t\tparse: function (expr) {\r\n\t\t\tthis.errormsg = \"\";\r\n\t\t\tthis.success = true;\r\n\t\t\tvar operstack = [];\r\n\t\t\tvar tokenstack = [];\r\n\t\t\tthis.tmpprio = 0;\r\n\t\t\tvar expected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\tvar noperators = 0;\r\n\t\t\tthis.expression = expr;\r\n\t\t\tthis.pos = 0;\r\n\r\n\t\t\twhile (this.pos < this.expression.length) {\r\n\t\t\t\tif (this.isOperator()) {\r\n\t\t\t\t\tif (this.isSign() && (expected & SIGN)) {\r\n\t\t\t\t\t\tif (this.isNegativeSign()) {\r\n\t\t\t\t\t\t\tthis.tokenprio = 2;\r\n\t\t\t\t\t\t\tthis.tokenindex = \"-\";\r\n\t\t\t\t\t\t\tnoperators++;\r\n\t\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.isComment()) {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif ((expected & OPERATOR) === 0) {\r\n\t\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected operator\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\r\n\t\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isNumber()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected number\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, this.tokennumber);\r\n\t\t\t\t\ttokenstack.push(token);\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isString()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected string\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, this.tokennumber);\r\n\t\t\t\t\ttokenstack.push(token);\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isLeftParenth()) {\r\n\t\t\t\t\tif ((expected & LPAREN) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\"(\\\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (expected & CALL) {\r\n\t\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\t\tthis.tokenprio = -2;\r\n\t\t\t\t\t\tthis.tokenindex = -1;\r\n\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TFUNCALL);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN | NULLARY_CALL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isRightParenth()) {\r\n\t\t\t\t    if (expected & NULLARY_CALL) {\r\n\t\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, []);\r\n\t\t\t\t\t\ttokenstack.push(token);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ((expected & RPAREN) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\")\\\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isComma()) {\r\n\t\t\t\t\tif ((expected & COMMA) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\",\\\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\r\n\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isConst()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected constant\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar consttoken = new Token(TNUMBER, 0, 0, this.tokennumber);\r\n\t\t\t\t\ttokenstack.push(consttoken);\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isOp2()) {\r\n\t\t\t\t\tif ((expected & FUNCTION) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected function\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\r\n\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\texpected = (LPAREN);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isOp1()) {\r\n\t\t\t\t\tif ((expected & FUNCTION) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected function\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP1);\r\n\t\t\t\t\tnoperators++;\r\n\t\t\t\t\texpected = (LPAREN);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isVar()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected variable\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar vartoken = new Token(TVAR, this.tokenindex, 0, 0);\r\n\t\t\t\t\ttokenstack.push(vartoken);\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isWhite()) {\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (this.errormsg === \"\") {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unknown character\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, this.errormsg);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.tmpprio < 0 || this.tmpprio >= 10) {\r\n\t\t\t\tthis.error_parsing(this.pos, \"unmatched \\\"()\\\"\");\r\n\t\t\t}\r\n\t\t\twhile (operstack.length > 0) {\r\n\t\t\t\tvar tmp = operstack.pop();\r\n\t\t\t\ttokenstack.push(tmp);\r\n\t\t\t}\r\n\t\t\tif (noperators + 1 !== tokenstack.length) {\r\n\t\t\t\t//print(noperators + 1);\r\n\t\t\t\t//print(tokenstack);\r\n\t\t\t\tthis.error_parsing(this.pos, \"parity\");\r\n\t\t\t}\r\n\r\n\t\t\treturn new Expression(tokenstack, object(this.ops1), object(this.ops2), object(this.functions));\r\n\t\t},\r\n\r\n\t\tevaluate: function (expr, variables) {\r\n\t\t\treturn this.parse(expr).evaluate(variables);\r\n\t\t},\r\n\r\n\t\terror_parsing: function (column, msg) {\r\n\t\t\tthis.success = false;\r\n\t\t\tthis.errormsg = \"parse error [column \" + (column) + \"]: \" + msg;\r\n\t\t\tthrow new Error(this.errormsg);\r\n\t\t},\r\n\r\n//\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\r\n\r\n\t\taddfunc: function (tokenstack, operstack, type_) {\r\n\t\t\tvar operator = new Token(type_, this.tokenindex, this.tokenprio + this.tmpprio, 0);\r\n\t\t\twhile (operstack.length > 0) {\r\n\t\t\t\tif (operator.prio_ <= operstack[operstack.length - 1].prio_) {\r\n\t\t\t\t\ttokenstack.push(operstack.pop());\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toperstack.push(operator);\r\n\t\t},\r\n\r\n\t\tisNumber: function () {\r\n\t\t\tvar r = false;\r\n\t\t\tvar str = \"\";\r\n\t\t\twhile (this.pos < this.expression.length) {\r\n\t\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\t\tif ((code >= 48 && code <= 57) || code === 46) {\r\n\t\t\t\t\tstr += this.expression.charAt(this.pos);\r\n\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\tthis.tokennumber = parseFloat(str);\r\n\t\t\t\t\tr = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\t// Ported from the yajjl JSON parser at http://code.google.com/p/yajjl/\r\n\t\tunescape: function(v, pos) {\r\n\t\t\tvar buffer = [];\r\n\t\t\tvar escaping = false;\r\n\r\n\t\t\tfor (var i = 0; i < v.length; i++) {\r\n\t\t\t\tvar c = v.charAt(i);\r\n\t\r\n\t\t\t\tif (escaping) {\r\n\t\t\t\t\tswitch (c) {\r\n\t\t\t\t\tcase \"'\":\r\n\t\t\t\t\t\tbuffer.push(\"'\");\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase '\\\\':\r\n\t\t\t\t\t\tbuffer.push('\\\\');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase '/':\r\n\t\t\t\t\t\tbuffer.push('/');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\tbuffer.push('\\b');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'f':\r\n\t\t\t\t\t\tbuffer.push('\\f');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'n':\r\n\t\t\t\t\t\tbuffer.push('\\n');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'r':\r\n\t\t\t\t\t\tbuffer.push('\\r');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tbuffer.push('\\t');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'u':\r\n\t\t\t\t\t\t// interpret the following 4 characters as the hex of the unicode code point\r\n\t\t\t\t\t\tvar codePoint = parseInt(v.substring(i + 1, i + 5), 16);\r\n\t\t\t\t\t\tbuffer.push(String.fromCharCode(codePoint));\r\n\t\t\t\t\t\ti += 4;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow this.error_parsing(pos + i, \"Illegal escape sequence: '\\\\\" + c + \"'\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tescaping = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (c == '\\\\') {\r\n\t\t\t\t\t\tescaping = true;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbuffer.push(c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn buffer.join('');\r\n\t\t},\r\n\r\n\t\tisString: function () {\r\n\t\t\tvar r = false;\r\n\t\t\tvar str = \"\";\r\n\t\t\tvar startpos = this.pos;\r\n\t\t\tif (this.pos < this.expression.length && this.expression.charAt(this.pos) == \"'\") {\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\twhile (this.pos < this.expression.length) {\r\n\t\t\t\t\tvar code = this.expression.charAt(this.pos);\r\n\t\t\t\t\tif (code != \"'\" || str.slice(-1) == \"\\\\\") {\r\n\t\t\t\t\t\tstr += this.expression.charAt(this.pos);\r\n\t\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\t\tthis.tokennumber = this.unescape(str, startpos);\r\n\t\t\t\t\t\tr = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\tisConst: function () {\r\n\t\t\tvar str;\r\n\t\t\tfor (var i in this.consts) {\r\n\t\t\t\tif (true) {\r\n\t\t\t\t\tvar L = i.length;\r\n\t\t\t\t\tstr = this.expression.substr(this.pos, L);\r\n\t\t\t\t\tif (i === str) {\r\n\t\t\t\t\t\tthis.tokennumber = this.consts[i];\r\n\t\t\t\t\t\tthis.pos += L;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisOperator: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 43) { // +\r\n\t\t\t\tthis.tokenprio = 0;\r\n\t\t\t\tthis.tokenindex = \"+\";\r\n\t\t\t}\r\n\t\t\telse if (code === 45) { // -\r\n\t\t\t\tthis.tokenprio = 0;\r\n\t\t\t\tthis.tokenindex = \"-\";\r\n\t\t\t}\r\n\t\t\telse if (code === 124) { // |\r\n\t\t\t\tif (this.expression.charCodeAt(this.pos + 1) === 124) {\r\n\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\tthis.tokenprio = 0;\r\n\t\t\t\t\tthis.tokenindex = \"||\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (code === 42) { // *\r\n\t\t\t\tthis.tokenprio = 1;\r\n\t\t\t\tthis.tokenindex = \"*\";\r\n\t\t\t}\r\n\t\t\telse if (code === 47) { // /\r\n\t\t\t\tthis.tokenprio = 2;\r\n\t\t\t\tthis.tokenindex = \"/\";\r\n\t\t\t}\r\n\t\t\telse if (code === 37) { // %\r\n\t\t\t\tthis.tokenprio = 2;\r\n\t\t\t\tthis.tokenindex = \"%\";\r\n\t\t\t}\r\n\t\t\telse if (code === 94) { // ^\r\n\t\t\t\tthis.tokenprio = 3;\r\n\t\t\t\tthis.tokenindex = \"^\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tthis.pos++;\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\tisSign: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 45 || code === 43) { // -\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisPositiveSign: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 43) { // -\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisNegativeSign: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 45) { // -\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisLeftParenth: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 40) { // (\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\tthis.tmpprio += 10;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisRightParenth: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 41) { // )\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\tthis.tmpprio -= 10;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisComma: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 44) { // ,\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\tthis.tokenprio = -1;\r\n\t\t\t\tthis.tokenindex = \",\";\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisWhite: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 32 || code === 9 || code === 10 || code === 13) {\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisOp1: function () {\r\n\t\t\tvar str = \"\";\r\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\r\n\t\t\t\tvar c = this.expression.charAt(i);\r\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\r\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstr += c;\r\n\t\t\t}\r\n\t\t\tif (str.length > 0 && (str in this.ops1)) {\r\n\t\t\t\tthis.tokenindex = str;\r\n\t\t\t\tthis.tokenprio = 5;\r\n\t\t\t\tthis.pos += str.length;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisOp2: function () {\r\n\t\t\tvar str = \"\";\r\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\r\n\t\t\t\tvar c = this.expression.charAt(i);\r\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\r\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstr += c;\r\n\t\t\t}\r\n\t\t\tif (str.length > 0 && (str in this.ops2)) {\r\n\t\t\t\tthis.tokenindex = str;\r\n\t\t\t\tthis.tokenprio = 5;\r\n\t\t\t\tthis.pos += str.length;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisVar: function () {\r\n\t\t\tvar str = \"\";\r\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\r\n\t\t\t\tvar c = this.expression.charAt(i);\r\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\r\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstr += c;\r\n\t\t\t}\r\n\t\t\tif (str.length > 0) {\r\n\t\t\t\tthis.tokenindex = str;\r\n\t\t\t\tthis.tokenprio = 4;\r\n\t\t\t\tthis.pos += str.length;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisComment: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 47 && this.expression.charCodeAt(this.pos) === 42) {\r\n\t\t\t\tthis.pos = this.expression.indexOf(\"*/\", this.pos) + 2;\r\n\t\t\t\tif (this.pos === 1) {\r\n\t\t\t\t\tthis.pos = this.expression.length;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\treturn Parser;\r\n});\r\n},{}],\"utils\\\\template.js\":[function(require,module,exports){\r\n/**\r\n * A very simple, ERB-style templating. Basically, just as string substitution.\r\n * The reason to not use default Lo-dash’es `_.template()` implementation\r\n * is because it fails to run in CSP-enabled environments (Chrome extension, Atom)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar utils = require('./common');\r\n\r\n\tfunction parseArgs(str) {\r\n\t\tvar args = [];\r\n\t\tvar stream = stringStream(str);\r\n\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tif (stream.peek() == ',') {\r\n\t\t\t\targs.push(utils.trim(stream.current()));\r\n\t\t\t\tstream.next();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t\tstream.next();\r\n\t\t}\r\n\r\n\t\targs.push(utils.trim(stream.current()));\r\n\t\treturn args.filter(function(a) {\r\n\t\t\treturn !!a;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction parseFunctionCall(str) {\r\n\t\tvar fnName = null, args;\r\n\t\tvar stream = stringStream(str);\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tif (stream.peek() == '(') {\r\n\t\t\t\tfnName = stream.current();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\tstream.skipToPair('(', ')', true);\r\n\t\t\t\targs = stream.current();\r\n\t\t\t\targs = parseArgs(args.substring(1, args.length - 1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tstream.next();\r\n\t\t}\r\n\r\n\t\treturn fnName && {\r\n\t\t\tname: fnName,\r\n\t\t\targs: args\r\n\t\t};\r\n\t}\r\n\r\n\tfunction evalArg(arg, context) {\r\n\t\tif (/^['\"]/.test(arg)) {\r\n\t\t\t// plain string\r\n\t\t\treturn arg.replace(/^(['\"])(.+?)\\1$/, '$2');\r\n\t\t}\r\n\r\n\t\tif (!isNaN(+arg)) {\r\n\t\t\t// a number\r\n\t\t\treturn +arg;\r\n\t\t}\r\n\r\n\t\t// otherwise, treat argument as a property name\r\n\t\tif (arg) {\r\n\t\t\tvar parts = arg.split('.');\r\n\t\t\tvar prop = context;\r\n\t\t\twhile (parts.length) {\r\n\t\t\t\tprop = prop[parts.shift()];\r\n\t\t\t}\r\n\r\n\t\t\treturn prop;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction process(template, context) {\r\n\t\treturn template.replace(/<%[=\\-](.+?)%>/g, function(str, match) {\r\n\t\t\tmatch = utils.trim(match);\r\n\t\t\tvar fn = parseFunctionCall(match);\r\n\t\t\tif (fn) {\r\n\t\t\t\tvar fnArgs = fn.args.map(function(arg) {\r\n\t\t\t\t\treturn evalArg(arg, context);\r\n\t\t\t\t});\r\n\t\t\t\treturn context[fn.name].apply(context, fnArgs);\r\n\t\t\t}\r\n\r\n\t\t\treturn evalArg(match, context);\r\n\t\t});\r\n\t}\r\n\r\n\treturn function(template, context) {\r\n\t\treturn context ? process(template, context) : function(context) {\r\n\t\t\treturn process(template, context);\r\n\t\t};\r\n\t};\r\n});\r\n},{\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"./common\":\"utils\\\\common.js\"}],\"vendor\\\\klass.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\r\n\t/**\r\n\t * Shared empty constructor function to aid in prototype-chain creation.\r\n\t */\r\n\tvar ctor = function(){};\r\n\r\n\t/**\r\n\t * Helper function to correctly set up the prototype chain, for subclasses.\r\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\r\n\t * class properties to be extended.\r\n\t * Took it from Backbone.\r\n\t * @param {Object} parent\r\n\t * @param {Object} protoProps\r\n\t * @param {Object} staticProps\r\n\t * @returns {Object}\r\n\t */\r\n\tfunction inherits(parent, protoProps, staticProps) {\r\n\t\tvar child;\r\n\r\n\t\t// The constructor function for the new subclass is either defined by\r\n\t\t// you (the \"constructor\" property in your `extend` definition), or\r\n\t\t// defaulted by us to simply call the parent's constructor.\r\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\r\n\t\t\tchild = protoProps.constructor;\r\n\t\t} else {\r\n\t\t\tchild = function() {\r\n\t\t\t\tparent.apply(this, arguments);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Inherit class (static) properties from parent.\r\n\t\tutils.extend(child, parent);\r\n\r\n\t\t// Set the prototype chain to inherit from `parent`, without calling\r\n\t\t// `parent`'s constructor function.\r\n\t\tctor.prototype = parent.prototype;\r\n\t\tchild.prototype = new ctor();\r\n\r\n\t\t// Add prototype properties (instance properties) to the subclass,\r\n\t\t// if supplied.\r\n\t\tif (protoProps)\r\n\t\t\tutils.extend(child.prototype, protoProps);\r\n\r\n\t\t// Add static properties to the constructor function, if supplied.\r\n\t\tif (staticProps)\r\n\t\t\tutils.extend(child, staticProps);\r\n\r\n\t\t// Correctly set child's `prototype.constructor`.\r\n\t\tchild.prototype.constructor = child;\r\n\r\n\t\t// Set a convenience property in case the parent's prototype is needed\r\n\t\t// later.\r\n\t\tchild.__super__ = parent.prototype;\r\n\r\n\t\treturn child;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * The self-propagating extend function for classes.\r\n\t\t * Took it from Backbone \r\n\t\t * @param {Object} protoProps\r\n\t\t * @param {Object} classProps\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\textend: function(protoProps, classProps) {\r\n\t\t\tvar child = inherits(this, protoProps, classProps);\r\n\t\t\tchild.extend = this.extend;\r\n\t\t\t// a hack required to WSH inherit `toString` method\r\n\t\t\tif (protoProps.hasOwnProperty('toString'))\r\n\t\t\t\tchild.prototype.toString = protoProps.toString;\r\n\t\t\treturn child;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"vendor\\\\stringScore.js\":[function(require,module,exports){\r\n/*!\r\n * string_score.js: String Scoring Algorithm 0.1.10 \r\n *\r\n * http://joshaven.com/string_score\r\n * https://github.com/joshaven/string_score\r\n *\r\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\r\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\r\n * MIT license: http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Date: Tue Mar 1 2011\r\n*/\r\n\r\n/**\r\n * Scores a string against another string.\r\n *  'Hello World'.score('he');     //=> 0.5931818181818181\r\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\treturn {\r\n\t\tscore: function(string, abbreviation, fuzziness) {\r\n\t\t\t// If the string is equal to the abbreviation, perfect match.\r\n\t\t\t  if (string == abbreviation) {return 1;}\r\n\t\t\t  //if it's not a perfect match and is empty return 0\r\n\t\t\t  if(abbreviation == \"\") {return 0;}\r\n\r\n\t\t\t  var total_character_score = 0,\r\n\t\t\t      abbreviation_length = abbreviation.length,\r\n\t\t\t      string_length = string.length,\r\n\t\t\t      start_of_string_bonus,\r\n\t\t\t      abbreviation_score,\r\n\t\t\t      fuzzies=1,\r\n\t\t\t      final_score;\r\n\t\t\t  \r\n\t\t\t  // Walk through abbreviation and add up scores.\r\n\t\t\t  for (var i = 0,\r\n\t\t\t         character_score/* = 0*/,\r\n\t\t\t         index_in_string/* = 0*/,\r\n\t\t\t         c/* = ''*/,\r\n\t\t\t         index_c_lowercase/* = 0*/,\r\n\t\t\t         index_c_uppercase/* = 0*/,\r\n\t\t\t         min_index/* = 0*/;\r\n\t\t\t     i < abbreviation_length;\r\n\t\t\t     ++i) {\r\n\t\t\t    \r\n\t\t\t    // Find the first case-insensitive match of a character.\r\n\t\t\t    c = abbreviation.charAt(i);\r\n\t\t\t    \r\n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\r\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\r\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\r\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\r\n\t\t\t    \r\n\t\t\t    if (index_in_string === -1) { \r\n\t\t\t      if (fuzziness) {\r\n\t\t\t        fuzzies += 1-fuzziness;\r\n\t\t\t        continue;\r\n\t\t\t      } else {\r\n\t\t\t        return 0;\r\n\t\t\t      }\r\n\t\t\t    } else {\r\n\t\t\t      character_score = 0.1;\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Set base score for matching 'c'.\r\n\t\t\t    \r\n\t\t\t    // Same case bonus.\r\n\t\t\t    if (string[index_in_string] === c) { \r\n\t\t\t      character_score += 0.1; \r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Consecutive letter & start-of-string Bonus\r\n\t\t\t    if (index_in_string === 0) {\r\n\t\t\t      // Increase the score when matching first character of the remainder of the string\r\n\t\t\t      character_score += 0.6;\r\n\t\t\t      if (i === 0) {\r\n\t\t\t        // If match is the first character of the string\r\n\t\t\t        // & the first character of abbreviation, add a\r\n\t\t\t        // start-of-string match bonus.\r\n\t\t\t        start_of_string_bonus = 1; //true;\r\n\t\t\t      }\r\n\t\t\t    }\r\n\t\t\t    else {\r\n\t\t\t  // Acronym Bonus\r\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\r\n\t\t\t  // preceded it with two perfect character matches.\r\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\r\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\r\n\t\t\t  }\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Left trim the already matched part of the string\r\n\t\t\t    // (forces sequential matching).\r\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\r\n\t\t\t    \r\n\t\t\t    total_character_score += character_score;\r\n\t\t\t  } // end of for loop\r\n\t\t\t  \r\n\t\t\t  // Uncomment to weigh smaller words higher.\r\n\t\t\t  // return total_character_score / string_length;\r\n\t\t\t  \r\n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\r\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\r\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\r\n\t\t\t  \r\n\t\t\t  // Reduce penalty for longer strings.\r\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\r\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\r\n\t\t\t  \r\n\t\t\t  final_score = final_score / fuzzies;\r\n\t\t\t  \r\n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\r\n\t\t\t    final_score += 0.15;\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  return final_score;\r\n\t\t}\r\n\t};\r\n});\r\n},{}]},{},[\"./lib/emmet.js\",\"./bundles/snippets.js\"])(\"./lib/emmet.js\")\r\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9), __webpack_require__(319).Buffer, __webpack_require__(7)))\n\n/***/ }),\n\n/***/ 318:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n/***/ }),\n\n/***/ 319:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(318)\nvar ieee754 = __webpack_require__(624)\nvar isArray = __webpack_require__(625)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n\n/***/ }),\n\n/***/ 624:\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n\n/***/ 625:\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/24.a6c7df8eec4fa04a41d9.js","!function(e){var val=e(); if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=val;if(\"function\"==typeof define&&define.amd)define(\"emmet\",[],val);{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.emmet=val}}(function(){var define,module,exports;return (function outer (modules, cache, entry) {\r\n    // Save the require from previous bundle to this closure if any\r\n    var previousRequire = typeof require == \"function\" && require;\r\n\r\n    function newRequire(name, jumped){\r\n        if(!cache[name]) {\r\n            if(!modules[name]) {\r\n                // if we cannot find the the module within our internal map or\r\n                // cache jump to the current global require ie. the last bundle\r\n                // that was added to the page.\r\n                var currentRequire = typeof require == \"function\" && require;\r\n                if (!jumped && currentRequire) return currentRequire(name, true);\r\n\r\n                // If there are other bundles on this page the require from the\r\n                // previous one is saved to 'previousRequire'. Repeat this as\r\n                // many times as there are bundles until the module is found or\r\n                // we exhaust the require chain.\r\n                if (previousRequire) return previousRequire(name, true);\r\n                var err = new Error('Cannot find module \\'' + name + '\\'');\r\n                err.code = 'MODULE_NOT_FOUND';\r\n                throw err;\r\n            }\r\n            var m = cache[name] = {exports:{}};\r\n            modules[name][0].call(m.exports, function(x){\r\n                var id = modules[name][1][x];\r\n                return newRequire(id ? id : x);\r\n            },m,m.exports,outer,modules,cache,entry);\r\n        }\r\n        return cache[name].exports;\r\n    }\r\n    for(var i=0;i<entry.length;i++) newRequire(entry[i]);\r\n\r\n    // Override the current require with this new one\r\n    return newRequire;\r\n})\r\n({\"./bundles/snippets.js\":[function(require,module,exports){\r\n/**\r\n * Bundler, used in builder script to statically\r\n * include snippets.json into bundle\r\n */\r\nvar res = require('../lib/assets/resources');\r\nvar snippets = require('../lib/snippets.json');\r\nres.setVocabulary(snippets, 'system');\r\n\r\n},{\"../lib/assets/resources\":\"assets\\\\resources.js\",\"../lib/snippets.json\":\"snippets.json\"}],\"./lib/emmet.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar global = typeof self != 'undefined' ? self : this;\r\n\r\n\tvar utils = require('./utils/common');\r\n\tvar actions = require('./action/main');\r\n\tvar parser = require('./parser/abbreviation');\r\n\tvar file = require('./plugin/file');\r\n\r\n\tvar preferences = require('./assets/preferences');\r\n\tvar resources = require('./assets/resources');\r\n\tvar profile = require('./assets/profile');\r\n\tvar ciu = require('./assets/caniuse');\r\n\tvar logger = require('./assets/logger');\r\n\r\n\tvar sliceFn = Array.prototype.slice;\r\n\r\n\t/**\r\n\t * Returns file name part from path\r\n\t * @param {String} path Path to file\r\n\t * @return {String}\r\n\t */\r\n\tfunction getFileName(path) {\r\n\t\tvar re = /([\\w\\.\\-]+)$/i;\r\n\t\tvar m = re.exec(path);\r\n\t\treturn m ? m[1] : '';\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes profile definition: converts some\r\n\t * properties to valid data types\r\n\t * @param {Object} profile\r\n\t * @return {Object}\r\n\t */\r\n\tfunction normalizeProfile(profile) {\r\n\t\tif (typeof profile === 'object') {\r\n\t\t\tif ('indent' in profile) {\r\n\t\t\t\tprofile.indent = !!profile.indent;\r\n\t\t\t}\r\n\r\n\t\t\tif ('self_closing_tag' in profile) {\r\n\t\t\t\tif (typeof profile.self_closing_tag === 'number') {\r\n\t\t\t\t\tprofile.self_closing_tag = !!profile.self_closing_tag;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn profile;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * The essential function that expands Emmet abbreviation\r\n\t\t * @param {String} abbr Abbreviation to parse\r\n\t\t * @param {String} syntax Abbreviation's context syntax\r\n\t\t * @param {String} profile Output profile (or its name)\r\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\r\n\t\t * written\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\r\n\t\t\treturn parser.expand(abbr, {\r\n\t\t\t\tsyntax: syntax,\r\n\t\t\t\tprofile: profile,\r\n\t\t\t\tcontextNode: contextNode\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Runs given action\r\n\t\t * @param  {String} name Action name\r\n\t\t * @param  {IEmmetEditor} editor Editor instance\r\n\t\t * @return {Boolean} Returns true if action was performed successfully\r\n\t\t */\r\n\t\trun: function(name) {\r\n\t\t\treturn actions.run.apply(actions, sliceFn.call(arguments, 0));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads Emmet extensions. Extensions are simple .js files that\r\n\t\t * uses Emmet modules and resources to create new actions, modify\r\n\t\t * existing ones etc.\r\n\t\t * @param {Array} fileList List of absolute paths to files in extensions\r\n\t\t * folder. Back-end app should not filter this list (e.g. by extension)\r\n\t\t * but return it \"as-is\" so bootstrap can decide how to load contents\r\n\t\t * of each file.\r\n\t\t * This method requires a <code>file</code> module of <code>IEmmetFile</code>\r\n\t\t * interface to be implemented.\r\n\t\t * @memberOf bootstrap\r\n\t\t */\r\n\t\tloadExtensions: function(fileList) {\r\n\t\t\tvar payload = {};\r\n\t\t\tvar userSnippets = null;\r\n\t\t\tvar that = this;\r\n\r\n\t\t\t// make sure file list contians only valid extension files\r\n\t\t\tfileList = fileList.filter(function(f) {\r\n\t\t\t\tvar ext = file.getExt(f);\r\n\t\t\t\treturn ext === 'json' || ext === 'js';\r\n\t\t\t});\r\n\r\n\t\t\tvar reader = (file.readText || file.read).bind(file);\r\n\t\t\tvar next = function() {\r\n\t\t\t\tif (fileList.length) {\r\n\t\t\t\t\tvar f = fileList.shift();\r\n\t\t\t\t\treader(f, function(err, content) {\r\n\t\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\t\tlogger.log('Unable to read \"' + f + '\" file: '+ err);\r\n\t\t\t\t\t\t\treturn next();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tswitch (file.getExt(f)) {\r\n\t\t\t\t\t\t\tcase 'js':\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\teval(content);\r\n\t\t\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\t\t\tlogger.log('Unable to eval \"' + f + '\" file: '+ e);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 'json':\r\n\t\t\t\t\t\t\t\tvar fileName = getFileName(f).toLowerCase().replace(/\\.json$/, '');\r\n\t\t\t\t\t\t\t\tcontent = utils.parseJSON(content);\r\n\t\t\t\t\t\t\t\tif (/^snippets/.test(fileName)) {\r\n\t\t\t\t\t\t\t\t\tif (fileName === 'snippets') {\r\n\t\t\t\t\t\t\t\t\t\t// data in snippets.json is more important to user\r\n\t\t\t\t\t\t\t\t\t\tuserSnippets = content;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tpayload.snippets = utils.deepMerge(payload.snippets || {}, content);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tpayload[fileName] = content;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnext();\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// complete\r\n\t\t\t\t\tif (userSnippets) {\r\n\t\t\t\t\t\tpayload.snippets = utils.deepMerge(payload.snippets || {}, userSnippets);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthat.loadUserData(payload);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tnext();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads preferences from JSON object (or string representation of JSON)\r\n\t\t * @param {Object} data\r\n\t\t * @returns\r\n\t\t */\r\n\t\tloadPreferences: function(data) {\r\n\t\t\tpreferences.load(utils.parseJSON(data));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Loads user snippets and abbreviations. It doesn’t replace current\r\n\t\t * user resource vocabulary but merges it with passed one. If you need\r\n\t\t * to <i>replaces</i> user snippets you should call\r\n\t\t * <code>resetSnippets()</code> method first\r\n\t\t */\r\n\t\tloadSnippets: function(data) {\r\n\t\t\tdata = utils.parseJSON(data);\r\n\r\n\t\t\tvar userData = resources.getVocabulary('user') || {};\r\n\t\t\tresources.setVocabulary(utils.deepMerge(userData, data), 'user');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Helper function that loads default snippets, defined in project’s\r\n\t\t * <i>snippets.json</i>\r\n\t\t * @param {Object} data\r\n\t\t */\r\n\t\tloadSystemSnippets: function(data) {\r\n\t\t\tresources.setVocabulary(utils.parseJSON(data), 'system');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Helper function that loads Can I Use database\r\n\t\t * @param {Object} data\r\n\t\t */\r\n\t\tloadCIU: function(data) {\r\n\t\t\tciu.load(utils.parseJSON(data));\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Removes all user-defined snippets\r\n\t\t */\r\n\t\tresetSnippets: function() {\r\n\t\t\tresources.setVocabulary({}, 'user');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Helper function that loads all user data (snippets and preferences)\r\n\t\t * defined as a single JSON object. This is useful for loading data\r\n\t\t * stored in a common storage, for example <code>NSUserDefaults</code>\r\n\t\t * @param {Object} data\r\n\t\t */\r\n\t\tloadUserData: function(data) {\r\n\t\t\tdata = utils.parseJSON(data);\r\n\t\t\tif (data.snippets) {\r\n\t\t\t\tthis.loadSnippets(data.snippets);\r\n\t\t\t}\r\n\r\n\t\t\tif (data.preferences) {\r\n\t\t\t\tthis.loadPreferences(data.preferences);\r\n\t\t\t}\r\n\r\n\t\t\tif (data.profiles) {\r\n\t\t\t\tthis.loadProfiles(data.profiles);\r\n\t\t\t}\r\n\r\n\t\t\tif (data.caniuse) {\r\n\t\t\t\tthis.loadCIU(data.caniuse);\r\n\t\t\t}\r\n\r\n\t\t\tvar profiles = data.syntaxProfiles || data.syntaxprofiles;\r\n\t\t\tif (profiles) {\r\n\t\t\t\tthis.loadSyntaxProfiles(profiles);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Resets all user-defined data: preferences, snippets etc.\r\n\t\t * @returns\r\n\t\t */\r\n\t\tresetUserData: function() {\r\n\t\t\tthis.resetSnippets();\r\n\t\t\tpreferences.reset();\r\n\t\t\tprofile.reset();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Load syntax-specific output profiles. These are essentially\r\n\t\t * an extension to syntax snippets\r\n\t\t * @param {Object} profiles Dictionary of profiles\r\n\t\t */\r\n\t\tloadSyntaxProfiles: function(profiles) {\r\n\t\t\tprofiles = utils.parseJSON(profiles);\r\n\t\t\tvar snippets = {};\r\n\t\t\tObject.keys(profiles).forEach(function(syntax) {\r\n\t\t\t\tvar options = profiles[syntax];\r\n\t\t\t\tif (!(syntax in snippets)) {\r\n\t\t\t\t\tsnippets[syntax] = {};\r\n\t\t\t\t}\r\n\t\t\t\tsnippets[syntax].profile = normalizeProfile(options);\r\n\t\t\t});\r\n\r\n\t\t\tthis.loadSnippets(snippets);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Load named profiles\r\n\t\t * @param {Object} profiles\r\n\t\t */\r\n\t\tloadProfiles: function(profiles) {\r\n\t\t\tprofiles = utils.parseJSON(profiles);\r\n\t\t\tObject.keys(profiles).forEach(function(name) {\r\n\t\t\t\tprofile.create(name, normalizeProfile(profiles[name]));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t// expose some useful data for plugin authors\r\n\t\tactions: actions,\r\n\t\tparser: parser,\r\n\t\tfile: file,\r\n\t\tpreferences: preferences,\r\n\t\tresources: resources,\r\n\t\tprofile: profile,\r\n\t\ttabStops: require('./assets/tabStops'),\r\n\t\thtmlMatcher: require('./assets/htmlMatcher'),\r\n\t\tutils: {\r\n\t\t\tcommon: utils,\r\n\t\t\taction: require('./utils/action'),\r\n\t\t\teditor: require('./utils/editor')\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"./action/main\":\"action\\\\main.js\",\"./assets/caniuse\":\"assets\\\\caniuse.js\",\"./assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"./assets/logger\":\"assets\\\\logger.js\",\"./assets/preferences\":\"assets\\\\preferences.js\",\"./assets/profile\":\"assets\\\\profile.js\",\"./assets/resources\":\"assets\\\\resources.js\",\"./assets/tabStops\":\"assets\\\\tabStops.js\",\"./parser/abbreviation\":\"parser\\\\abbreviation.js\",\"./plugin/file\":\"plugin\\\\file.js\",\"./utils/action\":\"utils\\\\action.js\",\"./utils/common\":\"utils\\\\common.js\",\"./utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\balance.js\":[function(require,module,exports){\r\n/**\r\n * HTML pair matching (balancing) actions\r\n * @constructor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar range = require('../assets/range');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar cssSections = require('../utils/cssSections');\r\n\tvar lastMatch = null;\r\n\r\n\tfunction last(arr) {\r\n\t\treturn arr[arr.length - 1];\r\n\t}\r\n\r\n\tfunction balanceHTML(editor, direction) {\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar content = info.content;\r\n\t\tvar sel = range(editor.getSelectionRange());\r\n\t\t\r\n\t\t// validate previous match\r\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\r\n\t\t\tlastMatch = null;\r\n\t\t}\r\n\t\t\r\n\t\tif (lastMatch && sel.length()) {\r\n\t\t\tif (direction == 'in') {\r\n\t\t\t\t// user has previously selected tag and wants to move inward\r\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\r\n\t\t\t\t\t// unary tag was selected, can't move inward\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\r\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar narrowed = utils.narrowToNonSpace(content, lastMatch.innerRange);\r\n\t\t\t\t\t\tlastMatch = htmlMatcher.find(content, narrowed.start + 1);\r\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\r\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (\r\n\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \r\n\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \r\n\t\t\t\t\t&& sel.equal(lastMatch.range)) {\r\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastMatch = htmlMatcher.find(content, sel.start);\r\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\r\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlastMatch = htmlMatcher.find(content, sel.start);\r\n\t\t}\r\n\r\n\t\tif (lastMatch) {\r\n\t\t\tif (lastMatch.innerRange.equal(sel)) {\r\n\t\t\t\tlastMatch.range = lastMatch.outerRange;\r\n\t\t\t}\r\n\r\n\t\t\tif (!lastMatch.range.equal(sel)) {\r\n\t\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlastMatch = null;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction rangesForCSSRule(rule, pos) {\r\n\t\t// find all possible ranges\r\n\t\tvar ranges = [rule.range(true)];\r\n\r\n\t\t// braces content\r\n\t\tranges.push(rule.valueRange(true));\r\n\r\n\t\t// find nested sections\r\n\t\tvar nestedSections = cssSections.nestedSectionsInRule(rule);\r\n\r\n\t\t// real content, e.g. from first property name to\r\n\t\t// last property value\r\n\t\tvar items = rule.list();\r\n\t\tif (items.length || nestedSections.length) {\r\n\t\t\tvar start = Number.POSITIVE_INFINITY, end = -1;\r\n\t\t\tif (items.length) {\r\n\t\t\t\tstart = items[0].namePosition(true);\r\n\t\t\t\tend = last(items).range(true).end;\r\n\t\t\t}\r\n\r\n\t\t\tif (nestedSections.length) {\r\n\t\t\t\tif (nestedSections[0].start < start) {\r\n\t\t\t\t\tstart = nestedSections[0].start;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (last(nestedSections).end > end) {\r\n\t\t\t\t\tend = last(nestedSections).end;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tranges.push(range.create2(start, end));\r\n\t\t}\r\n\r\n\t\tranges = ranges.concat(nestedSections);\r\n\r\n\t\tvar prop = cssEditTree.propertyFromPosition(rule, pos) || items[0];\r\n\t\tif (prop) {\r\n\t\t\tranges.push(prop.range(true));\r\n\t\t\tvar valueRange = prop.valueRange(true);\r\n\t\t\tif (!prop.end()) {\r\n\t\t\t\tvalueRange._unterminated = true;\r\n\t\t\t}\r\n\t\t\tranges.push(valueRange);\r\n\t\t}\r\n\r\n\t\treturn ranges;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all possible selection ranges for given caret position\r\n\t * @param  {String} content CSS content\r\n\t * @param  {Number} pos     Caret position(where to start searching)\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getCSSRanges(content, pos) {\r\n\t\tvar rule;\r\n\t\tif (typeof content === 'string') {\r\n\t\t\tvar ruleRange = cssSections.matchEnclosingRule(content, pos);\r\n\t\t\tif (ruleRange) {\r\n\t\t\t\trule = cssEditTree.parse(ruleRange.substring(content), {\r\n\t\t\t\t\toffset: ruleRange.start\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// passed parsed CSS rule\r\n\t\t\trule = content;\r\n\t\t}\r\n\r\n\t\tif (!rule) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// find all possible ranges\r\n\t\tvar ranges = rangesForCSSRule(rule, pos);\r\n\r\n\t\t// remove empty ranges\r\n\t\tranges = ranges.filter(function(item) {\r\n\t\t\treturn !!item.length;\r\n\t\t});\r\n\r\n\t\treturn utils.unique(ranges, function(item) {\r\n\t\t\treturn item.valueOf();\r\n\t\t});\r\n\t}\r\n\r\n\tfunction balanceCSS(editor, direction) {\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar content = info.content;\r\n\t\tvar sel = range(editor.getSelectionRange());\r\n\r\n\t\tvar ranges = getCSSRanges(info.content, sel.start);\r\n\t\tif (!ranges && sel.length()) {\r\n\t\t\t// possible reason: user has already selected\r\n\t\t\t// CSS rule from last match\r\n\t\t\ttry {\r\n\t\t\t\tvar rule = cssEditTree.parse(sel.substring(info.content), {\r\n\t\t\t\t\toffset: sel.start\r\n\t\t\t\t});\r\n\t\t\t\tranges = getCSSRanges(rule, sel.start);\r\n\t\t\t} catch(e) {}\r\n\t\t}\r\n\r\n\t\tif (!ranges) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tranges = range.sort(ranges, true);\r\n\r\n\t\t// edge case: find match that equals current selection,\r\n\t\t// in case if user moves inward after selecting full CSS rule\r\n\t\tvar bestMatch = utils.find(ranges, function(r) {\r\n\t\t\treturn r.equal(sel);\r\n\t\t});\r\n\r\n\t\tif (!bestMatch) {\r\n\t\t\tbestMatch = utils.find(ranges, function(r) {\r\n\t\t\t\t// Check for edge case: caret right after CSS value\r\n\t\t\t\t// but it doesn‘t contains terminating semicolon.\r\n\t\t\t\t// In this case we have to check full value range\r\n\t\t\t\treturn r._unterminated ? r.include(sel.start) : r.inside(sel.start);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (!bestMatch) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// if best match equals to current selection, move index\r\n\t\t// one position up or down, depending on direction\r\n\t\tvar bestMatchIx = ranges.indexOf(bestMatch);\r\n\t\tif (bestMatch.equal(sel)) {\r\n\t\t\tbestMatchIx += direction == 'out' ? 1 : -1;\r\n\t\t}\r\n\r\n\t\tif (bestMatchIx < 0 || bestMatchIx >= ranges.length) {\r\n\t\t\tif (bestMatchIx >= ranges.length && direction == 'out') {\r\n\t\t\t\tpos = bestMatch.start - 1;\r\n\r\n\t\t\t\tvar outerRanges = getCSSRanges(content, pos);\r\n\t\t\t\tif (outerRanges) {\r\n\t\t\t\t\tbestMatch = last(outerRanges.filter(function(r) {\r\n\t\t\t\t\t\treturn r.inside(pos);\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t} else if (bestMatchIx < 0 && direction == 'in') {\r\n\t\t\t\tbestMatch = null;\r\n\t\t\t} else {\r\n\t\t\t\tbestMatch = null;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tbestMatch = ranges[bestMatchIx];\t\r\n\t\t}\r\n\r\n\t\tif (bestMatch) {\r\n\t\t\teditor.createSelection(bestMatch.start, bestMatch.end);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Find and select HTML tag pair\r\n\t\t * @param {IEmmetEditor} editor Editor instance\r\n\t\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \r\n\t\t * Default is 'out'\r\n\t\t */\r\n\t\tbalance: function(editor, direction) {\r\n\t\t\tdirection = String((direction || 'out').toLowerCase());\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\tif (actionUtils.isSupportedCSS(info.syntax)) {\r\n\t\t\t\treturn balanceCSS(editor, direction);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn balanceHTML(editor, direction);\r\n\t\t},\r\n\r\n\t\tbalanceInwardAction: function(editor) {\r\n\t\t\treturn this.balance(editor, 'in');\r\n\t\t},\r\n\r\n\t\tbalanceOutwardAction: function(editor) {\r\n\t\t\treturn this.balance(editor, 'out');\t\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Moves caret to matching opening or closing tag\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t */\r\n\t\tgoToMatchingPairAction: function(editor) {\r\n\t\t\tvar content = String(editor.getContent());\r\n\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\t\r\n\t\t\tif (content.charAt(caretPos) == '<') \r\n\t\t\t\t// looks like caret is outside of tag pair  \r\n\t\t\t\tcaretPos++;\r\n\t\t\t\t\r\n\t\t\tvar tag = htmlMatcher.tag(content, caretPos);\r\n\t\t\tif (tag && tag.close) { // exclude unary tags\r\n\t\t\t\tif (tag.open.range.inside(caretPos)) {\r\n\t\t\t\t\teditor.setCaretPos(tag.close.range.start);\r\n\t\t\t\t} else {\r\n\t\t\t\t\teditor.setCaretPos(tag.open.range.start);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\base64.js\":[function(require,module,exports){\r\n/**\r\n * Encodes/decodes image under cursor to/from base64\r\n * @param {IEmmetEditor} editor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar file = require('../plugin/file');\r\n\tvar base64 = require('../utils/base64');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar editorUtils = require('../utils/editor');\r\n\r\n\t/**\r\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\r\n\t * position. If <code>pos</code> is omitted, search from beginning of text \r\n\t * @param {String} token Token to test\r\n\t * @param {String} text Where to search\r\n\t * @param {Number} pos Position where to start search\r\n\t * @return {Boolean}\r\n\t * @since 0.65\r\n\t */\r\n\tfunction startsWith(token, text, pos) {\r\n\t\tpos = pos || 0;\r\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\r\n\t}\r\n\r\n\t/**\r\n\t * Encodes image to base64\r\n\t * \r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} imgPath Path to image\r\n\t * @param {Number} pos Caret position where image is located in the editor\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction encodeToBase64(editor, imgPath, pos) {\r\n\t\tvar editorFile = editor.getFilePath();\r\n\t\tvar defaultMimeType = 'application/octet-stream';\r\n\r\n\t\tif (editorFile === null) {\r\n\t\t\tthrow \"You should save your file before using this action\";\r\n\t\t}\r\n\r\n\t\t// locate real image path\r\n\t\tfile.locateFile(editorFile, imgPath, function(realImgPath) {\r\n\t\t\tif (realImgPath === null) {\r\n\t\t\t\tthrow \"Can't find \" + imgPath + ' file';\r\n\t\t\t}\r\n\r\n\t\t\tfile.read(realImgPath, function(err, content) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar b64 = base64.encode(String(content));\r\n\t\t\t\tif (!b64) {\r\n\t\t\t\t\tthrow \"Can't encode file content to base64\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\r\n\t\t\t\t\t';base64,' + b64;\r\n\r\n\t\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Decodes base64 string back to file.\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} filePath to new image\r\n\t * @param {String} data Base64-encoded file content\r\n\t * @param {Number} pos Caret position where image is located in the editor\r\n\t */\r\n\tfunction decodeFromBase64(editor, filePath, data, pos) {\r\n\t\t// ask user to enter path to file\r\n\t\tfilePath = filePath || String(editor.prompt('Enter path to file (absolute or relative)'));\r\n\t\tif (!filePath) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar editorFile = editor.getFilePath();\r\n\t\tfile.createPath(editorFile, filePath, function(err, absPath) {\r\n\t\t\tif (err || !absPath) {\r\n\t\t\t\tthrow \"Can't save file\";\r\n\t\t\t}\r\n\r\n\t\t\tvar content = data.replace(/^data\\:.+?;.+?,/, '');\r\n\t\t\tfile.save(absPath, base64.decode(content), function(err) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tthrow 'Unable to save ' + absPath + ': ' + err;\r\n\t\t\t\t}\r\n\r\n\t\t\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Action to encode or decode file to data:url\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tencodeDecodeDataUrlAction: function(editor, filepath) {\r\n\t\t\tvar data = String(editor.getSelection());\r\n\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\r\n\t\t\tif (!data) {\r\n\t\t\t\t// no selection, try to find image bounds from current caret position\r\n\t\t\t\tvar text = info.content, m;\r\n\t\t\t\twhile (caretPos-- >= 0) {\r\n\t\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\r\n\t\t\t\t\t\tif ((m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/))) {\r\n\t\t\t\t\t\t\tdata = m[3];\r\n\t\t\t\t\t\t\tcaretPos += m[1].length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\r\n\t\t\t\t\t\tif ((m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/))) {\r\n\t\t\t\t\t\t\tdata = m[3];\r\n\t\t\t\t\t\t\tcaretPos += m[1].length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (data) {\r\n\t\t\t\tif (startsWith('data:', data)) {\r\n\t\t\t\t\treturn decodeFromBase64(editor, filepath, data, caretPos);\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn encodeToBase64(editor, data, caretPos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../plugin/file\":\"plugin\\\\file.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/base64\":\"utils\\\\base64.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\editPoints.js\":[function(require,module,exports){\r\n/**\r\n * Move between next/prev edit points. 'Edit points' are places between tags \r\n * and quotes of empty attributes in html\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * Search for new caret insertion point\r\n\t * @param {IEmmetEditor} editor Editor instance\r\n\t * @param {Number} inc Search increment: -1 — search left, 1 — search right\r\n\t * @param {Number} offset Initial offset relative to current caret position\r\n\t * @return {Number} Returns -1 if insertion point wasn't found\r\n\t */\r\n\tfunction findNewEditPoint(editor, inc, offset) {\r\n\t\tinc = inc || 1;\r\n\t\toffset = offset || 0;\r\n\t\t\r\n\t\tvar curPoint = editor.getCaretPos() + offset;\r\n\t\tvar content = String(editor.getContent());\r\n\t\tvar maxLen = content.length;\r\n\t\tvar nextPoint = -1;\r\n\t\tvar reEmptyLine = /^\\s+$/;\r\n\t\t\r\n\t\tfunction getLine(ix) {\r\n\t\t\tvar start = ix;\r\n\t\t\twhile (start >= 0) {\r\n\t\t\t\tvar c = content.charAt(start);\r\n\t\t\t\tif (c == '\\n' || c == '\\r')\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tstart--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn content.substring(start, ix);\r\n\t\t}\r\n\t\t\t\r\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\r\n\t\t\tcurPoint += inc;\r\n\t\t\tvar curChar = content.charAt(curPoint);\r\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\r\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\r\n\t\t\t\t\r\n\t\t\tswitch (curChar) {\r\n\t\t\t\tcase '\"':\r\n\t\t\t\tcase '\\'':\r\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\r\n\t\t\t\t\t\t// empty attribute\r\n\t\t\t\t\t\tnextPoint = curPoint + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '>':\r\n\t\t\t\t\tif (nextChar == '<') {\r\n\t\t\t\t\t\t// between tags\r\n\t\t\t\t\t\tnextPoint = curPoint + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n\t\t\t\t\t// empty line\r\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\r\n\t\t\t\t\t\tnextPoint = curPoint;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (nextPoint != -1)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\treturn nextPoint;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Move to previous edit point\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tpreviousEditPointAction: function(editor, syntax, profile) {\r\n\t\t\tvar curPos = editor.getCaretPos();\r\n\t\t\tvar newPoint = findNewEditPoint(editor, -1);\r\n\t\t\t\t\r\n\t\t\tif (newPoint == curPos)\r\n\t\t\t\t// we're still in the same point, try searching from the other place\r\n\t\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\r\n\t\t\t\r\n\t\t\tif (newPoint != -1) {\r\n\t\t\t\teditor.setCaretPos(newPoint);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Move to next edit point\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tnextEditPointAction: function(editor, syntax, profile) {\r\n\t\t\tvar newPoint = findNewEditPoint(editor, 1);\r\n\t\t\tif (newPoint != -1) {\r\n\t\t\t\teditor.setCaretPos(newPoint);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"action\\\\evaluateMath.js\":[function(require,module,exports){\r\n/**\r\n * Evaluates simple math expression under caret\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar utils = require('../utils/common');\r\n\tvar math = require('../utils/math');\r\n\tvar range = require('../assets/range');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Evaluates math expression under the caret\r\n\t\t * @param  {IEmmetEditor} editor\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tevaluateMathAction: function(editor) {\r\n\t\t\tvar content = editor.getContent();\r\n\t\t\tvar chars = '.+-*/\\\\';\r\n\t\t\t\r\n\t\t\t/** @type Range */\r\n\t\t\tvar sel = range(editor.getSelectionRange());\r\n\t\t\tif (!sel.length()) {\r\n\t\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\r\n\t\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (sel && sel.length()) {\r\n\t\t\t\tvar expr = sel.substring(content);\r\n\t\t\t\t\r\n\t\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \r\n\t\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'round($1/$2)');\r\n\t\t\t\t\r\n\t\t\t\ttry {\r\n\t\t\t\t\tvar result = utils.prettifyNumber(math.evaluate(expr));\r\n\t\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\r\n\t\t\t\t\teditor.setCaretPos(sel.start + result.length);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} catch (e) {}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/math\":\"utils\\\\math.js\"}],\"action\\\\expandAbbreviation.js\":[function(require,module,exports){\r\n/**\r\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \r\n * position and replaces it with formatted output. \r\n * <br><br>\r\n * This behavior can be overridden with custom handlers which can perform \r\n * different actions when 'Expand Abbreviation' action is called.\r\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\r\n * definitions registers its own expand abbreviation handler.  \r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar handlerList = require('../assets/handlerList');\r\n\tvar range = require('../assets/range');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar cssGradient = require('../resolver/cssGradient');\r\n\tvar parser = require('../parser/abbreviation');\r\n\r\n\t/**\r\n\t * Search for abbreviation in editor from current caret position\r\n\t * @param {IEmmetEditor} editor Editor instance\r\n\t * @return {String}\r\n\t */\r\n\tfunction findAbbreviation(editor) {\r\n\t\tvar r = range(editor.getSelectionRange());\r\n\t\tvar content = String(editor.getContent());\r\n\t\tif (r.length()) {\r\n\t\t\t// abbreviation is selected by user\r\n\t\t\treturn r.substring(content);\r\n\t\t}\r\n\t\t\r\n\t\t// search for new abbreviation from current caret position\r\n\t\tvar curLine = editor.getCurrentLineRange();\r\n\t\treturn actionUtils.extractAbbreviation(content.substring(curLine.start, r.start));\r\n\t}\r\n\r\n\t/**\r\n\t * @type HandlerList List of registered handlers\r\n\t */\r\n\tvar handlers = handlerList.create();\r\n\r\n\t// XXX setup default expand handlers\r\n\t\r\n\t/**\r\n\t * Extracts abbreviation from current caret \r\n\t * position and replaces it with formatted output \r\n\t * @param {IEmmetEditor} editor Editor instance\r\n\t * @param {String} syntax Syntax type (html, css, etc.)\r\n\t * @param {String} profile Output profile name (html, xml, xhtml)\r\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \r\n\t * successfully\r\n\t */\r\n\thandlers.add(function(editor, syntax, profile) {\r\n\t\tvar caretPos = editor.getSelectionRange().end;\r\n\t\tvar abbr = findAbbreviation(editor);\r\n\t\t\t\r\n\t\tif (abbr) {\r\n\t\t\tvar content = parser.expand(abbr, {\r\n\t\t\t\tsyntax: syntax, \r\n\t\t\t\tprofile: profile, \r\n\t\t\t\tcontextNode: actionUtils.captureContext(editor)\r\n\t\t\t});\r\n\r\n\t\t\tif (content) {\r\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\r\n\t\t\t\tvar replaceTo = caretPos;\r\n\r\n\t\t\t\t// a special case for CSS: if editor already contains\r\n\t\t\t\t// semicolon right after current caret position — replace it too\r\n\t\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\r\n\t\t\t\tif (cssSyntaxes && ~cssSyntaxes.indexOf(syntax)) {\r\n\t\t\t\t\tvar curContent = editor.getContent();\r\n\t\t\t\t\tif (curContent.charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\r\n\t\t\t\t\t\treplaceTo++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}, {order: -1});\r\n\thandlers.add(cssGradient.expandAbbreviationHandler.bind(cssGradient));\r\n\t\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * The actual “Expand Abbreviation“ action routine\r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\texpandAbbreviationAction: function(editor, syntax, profile) {\r\n\t\t\tvar args = utils.toArray(arguments);\r\n\t\t\t\r\n\t\t\t// normalize incoming arguments\r\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\r\n\t\t\targs[1] = info.syntax;\r\n\t\t\targs[2] = info.profile;\r\n\t\t\t\r\n\t\t\treturn handlers.exec(false, args);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A special case of “Expand Abbreviation“ action, invoked by Tab key.\r\n\t\t * In this case if abbreviation wasn’t expanded successfully or there’s a selecetion, \r\n\t\t * the current line/selection will be indented. \r\n\t\t * @param  {IEmmetEditor} editor  Editor instance\r\n\t\t * @param  {String} syntax  Current document syntax\r\n\t\t * @param  {String} profile Output profile name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\texpandAbbreviationWithTabAction: function(editor, syntax, profile) {\r\n\t\t\tvar sel = editor.getSelection();\r\n\t\t\tvar indent = '\\t';\r\n\r\n\t\t\t// if something is selected in editor,\r\n\t\t\t// we should indent the selected content\r\n\t\t\tif (sel) {\r\n\t\t\t\tvar selRange = range(editor.getSelectionRange());\r\n\t\t\t\tvar content = utils.padString(sel, indent);\r\n\t\t\t\t\r\n\t\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\r\n\t\t\t\tvar replaceRange = range(editor.getCaretPos(), selRange.length());\r\n\t\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\r\n\t\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\r\n\t\t\t// nothing selected, try to expand\r\n\t\t\tif (!this.expandAbbreviationAction(editor, syntax, profile)) {\r\n\t\t\t\teditor.replaceContent(indent, editor.getCaretPos());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t\r\n\t\t_defaultHandler: function(editor, syntax, profile) {\r\n\t\t\tvar caretPos = editor.getSelectionRange().end;\r\n\t\t\tvar abbr = this.findAbbreviation(editor);\r\n\t\t\t\t\r\n\t\t\tif (abbr) {\r\n\t\t\t\tvar ctx = actionUtils.captureContext(editor);\r\n\t\t\t\tvar content = parser.expand(abbr, syntax, profile, ctx);\r\n\t\t\t\tif (content) {\r\n\t\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds custom expand abbreviation handler. The passed function should \r\n\t\t * return <code>true</code> if it was performed successfully, \r\n\t\t * <code>false</code> otherwise.\r\n\t\t * \r\n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\r\n\t\t * in order they were added\r\n\t\t * @memberOf expandAbbreviation\r\n\t\t * @param {Function} fn\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\taddHandler: function(fn, options) {\r\n\t\t\thandlers.add(fn, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered handler\r\n\t\t * @returns\r\n\t\t */\r\n\t\tremoveHandler: function(fn) {\r\n\t\t\thandlers.remove(fn);\r\n\t\t},\r\n\t\t\r\n\t\tfindAbbreviation: findAbbreviation\r\n\t};\r\n});\r\n},{\"../assets/handlerList\":\"assets\\\\handlerList.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../resolver/cssGradient\":\"resolver\\\\cssGradient.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\incrementDecrement.js\":[function(require,module,exports){\r\n/**\r\n * Increment/decrement number under cursor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar actionUtils = require('../utils/action');\r\n\r\n\t/**\r\n\t * Returns length of integer part of number\r\n\t * @param {String} num\r\n\t */\r\n\tfunction intLength(num) {\r\n\t\tnum = num.replace(/^\\-/, '');\r\n\t\tif (~num.indexOf('.')) {\r\n\t\t\treturn num.split('.')[0].length;\r\n\t\t}\r\n\t\t\r\n\t\treturn num.length;\r\n\t}\r\n\r\n\treturn {\r\n\t\tincrement01Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, .1);\r\n\t\t},\r\n\r\n\t\tincrement1Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, 1);\r\n\t\t},\r\n\r\n\t\tincrement10Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, 10);\r\n\t\t},\r\n\r\n\t\tdecrement01Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, -.1);\r\n\t\t},\r\n\r\n\t\tdecrement1Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, -1);\r\n\t\t},\r\n\r\n\t\tdecrement10Action: function(editor) {\r\n\t\t\treturn this.incrementNumber(editor, -10);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Default method to increment/decrement number under\r\n\t\t * caret with given step\r\n\t\t * @param  {IEmmetEditor} editor\r\n\t\t * @param  {Number} step\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tincrementNumber: function(editor, step) {\r\n\t\t\tvar hasSign = false;\r\n\t\t\tvar hasDecimal = false;\r\n\t\t\t\t\r\n\t\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\r\n\t\t\t\tif (utils.isNumeric(ch))\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tif (ch == '.') {\r\n\t\t\t\t\t// make sure that next character is numeric too\r\n\t\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (ch == '-')\r\n\t\t\t\t\treturn hasSign ? false : hasSign = true;\r\n\t\t\t\t\t\r\n\t\t\t\treturn false;\r\n\t\t\t});\r\n\t\t\t\t\r\n\t\t\tif (r && r.length()) {\r\n\t\t\t\tvar strNum = r.substring(String(editor.getContent()));\r\n\t\t\t\tvar num = parseFloat(strNum);\r\n\t\t\t\tif (!isNaN(num)) {\r\n\t\t\t\t\tnum = utils.prettifyNumber(num + step);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// do we have zero-padded number?\r\n\t\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\r\n\t\t\t\t\t\tvar minus = '';\r\n\t\t\t\t\t\tif (RegExp.$1) {\r\n\t\t\t\t\t\t\tminus = '-';\r\n\t\t\t\t\t\t\tnum = num.substring(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar parts = num.split('.');\r\n\t\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\r\n\t\t\t\t\t\tnum = minus + parts.join('.');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\teditor.replaceContent(num, r.start, r.end);\r\n\t\t\t\t\teditor.createSelection(r.start, r.start + num.length);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"action\\\\lineBreaks.js\":[function(require,module,exports){\r\n/**\r\n * Actions to insert line breaks. Some simple editors (like browser's \r\n * &lt;textarea&gt;, for example) do not provide such simple things\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar utils = require('../utils/common');\r\n\tvar resources = require('../assets/resources');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar editorUtils = require('../utils/editor');\r\n\r\n\tvar xmlSyntaxes = ['html', 'xml', 'xsl'];\r\n\r\n\t// setup default preferences\r\n\tprefs.define('css.closeBraceIndentation', '\\n',\r\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \r\n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\r\n\t\t\t+ 'This preference’s value will be automatically inserted before '\r\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\r\n\t\t\t+ '(e.g. when “Insert formatted linebreak” action will be performed ' \r\n\t\t\t+ 'in CSS file). If you’re such user, you may want to write put a value ' \r\n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Inserts newline character with proper indentation. This action is used in\r\n\t\t * editors that doesn't have indentation control (like textarea element) to \r\n\t\t * provide proper indentation for inserted newlines\r\n\t\t * @param {IEmmetEditor} editor Editor instance\r\n\t\t */\r\n\t\tinsertLineBreakAction: function(editor) {\r\n\t\t\tif (!this.insertLineBreakOnlyAction(editor)) {\r\n\t\t\t\tvar curPadding = editorUtils.getCurrentLinePadding(editor);\r\n\t\t\t\tvar content = String(editor.getContent());\r\n\t\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\t\tvar len = content.length;\r\n\t\t\t\tvar nl = '\\n';\r\n\t\t\t\t\t\r\n\t\t\t\t// check out next line padding\r\n\t\t\t\tvar lineRange = editor.getCurrentLineRange();\r\n\t\t\t\tvar nextPadding = '';\r\n\t\t\t\t\t\r\n\t\t\t\tfor (var i = lineRange.end, ch; i < len; i++) {\r\n\t\t\t\t\tch = content.charAt(i);\r\n\t\t\t\t\tif (ch == ' ' || ch == '\\t')\r\n\t\t\t\t\t\tnextPadding += ch;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (nextPadding.length > curPadding.length) {\r\n\t\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\teditor.replaceContent(nl, caretPos);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Inserts newline character with proper indentation in specific positions only.\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @return {Boolean} Returns <code>true</code> if line break was inserted \r\n\t\t */\r\n\t\tinsertLineBreakOnlyAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\tvar nl = '\\n';\r\n\t\t\tvar pad = '\\t';\r\n\t\t\t\r\n\t\t\tif (~xmlSyntaxes.indexOf(info.syntax)) {\r\n\t\t\t\t// let's see if we're breaking newly created tag\r\n\t\t\t\tvar tag = htmlMatcher.tag(info.content, caretPos);\r\n\t\t\t\tif (tag && !tag.innerRange.length()) {\r\n\t\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else if (info.syntax == 'css') {\r\n\t\t\t\t/** @type String */\r\n\t\t\t\tvar content = info.content;\r\n\t\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\r\n\t\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\r\n\t\t\t\t\tif (!hasCloseBrace) {\r\n\t\t\t\t\t\t// do we really need special formatting here?\r\n\t\t\t\t\t\t// check if this is really a newly created rule,\r\n\t\t\t\t\t\t// look ahead for a closing brace\r\n\t\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\r\n\t\t\t\t\t\t\tch = content.charAt(i);\r\n\t\t\t\t\t\t\tif (ch == '{') {\r\n\t\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tif (ch == '}') {\r\n\t\t\t\t\t\t\t\t// not a new rule, just add indentation\r\n\t\t\t\t\t\t\t\tappend = '';\r\n\t\t\t\t\t\t\t\thasCloseBrace = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!hasCloseBrace) {\r\n\t\t\t\t\t\tappend += '}';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// defining rule set\r\n\t\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\r\n\t\t\t\t\teditor.replaceContent(insValue, caretPos);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\main.js\":[function(require,module,exports){\r\n/**\r\n * Module describes and performs Emmet actions. The actions themselves are\r\n * defined in <i>actions</i> folder\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\r\n\t// all registered actions\r\n\tvar actions = {};\r\n\r\n\t// load all default actions\r\n\tvar actionModules = {\r\n\t\tbase64: require('./base64'),\r\n\t\teditPoints: require('./editPoints'),\r\n\t\tevaluateMath: require('./evaluateMath'),\r\n\t\texpandAbbreviation: require('./expandAbbreviation'),\r\n\t\tincrementDecrement: require('./incrementDecrement'),\r\n\t\tlineBreaks: require('./lineBreaks'),\r\n\t\tbalance: require('./balance'),\r\n\t\tmergeLines: require('./mergeLines'),\r\n\t\treflectCSSValue: require('./reflectCSSValue'),\r\n\t\tremoveTag: require('./removeTag'),\r\n\t\tselectItem: require('./selectItem'),\r\n\t\tselectLine: require('./selectLine'),\r\n\t\tsplitJoinTag: require('./splitJoinTag'),\r\n\t\ttoggleComment: require('./toggleComment'),\r\n\t\tupdateImageSize: require('./updateImageSize'),\r\n\t\twrapWithAbbreviation: require('./wrapWithAbbreviation'),\r\n\t\tupdateTag: require('./updateTag')\r\n\t};\r\n\r\n\tfunction addAction(name, fn, options) {\r\n\t\tname = name.toLowerCase();\r\n\t\toptions = options || {};\r\n\t\t\r\n\t\tif (typeof options === 'string') {\r\n\t\t\toptions = {label: options};\r\n\t\t}\r\n\r\n\t\tif (!options.label) {\r\n\t\t\toptions.label = humanizeActionName(name);\r\n\t\t}\r\n\t\t\r\n\t\tactions[name] = {\r\n\t\t\tname: name,\r\n\t\t\tfn: fn,\r\n\t\t\toptions: options\r\n\t\t};\r\n\t}\r\n\t\r\n\t/**\r\n\t * “Humanizes” action name, makes it more readable for people\r\n\t * @param {String} name Action name (like 'expand_abbreviation')\r\n\t * @return Humanized name (like 'Expand Abbreviation')\r\n\t */\r\n\tfunction humanizeActionName(name) {\r\n\t\treturn utils.trim(name.charAt(0).toUpperCase() \r\n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\r\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\r\n\t\t\t}));\r\n\t}\r\n\r\n\tvar bind = function(name, method) {\r\n\t\tvar m = actionModules[name];\r\n\t\treturn m[method].bind(m);\r\n\t};\r\n\r\n\t// XXX register default actions\r\n\taddAction('encode_decode_data_url', bind('base64', 'encodeDecodeDataUrlAction'), 'Encode\\\\Decode data:URL image');\r\n\taddAction('prev_edit_point', bind('editPoints', 'previousEditPointAction'), 'Previous Edit Point');\r\n\taddAction('next_edit_point', bind('editPoints', 'nextEditPointAction'), 'Next Edit Point');\r\n\taddAction('evaluate_math_expression', bind('evaluateMath', 'evaluateMathAction'), 'Numbers/Evaluate Math Expression');\r\n\taddAction('expand_abbreviation_with_tab', bind('expandAbbreviation', 'expandAbbreviationWithTabAction'), {hidden: true});\r\n\taddAction('expand_abbreviation', bind('expandAbbreviation', 'expandAbbreviationAction'), 'Expand Abbreviation');\r\n\taddAction('insert_formatted_line_break_only', bind('lineBreaks', 'insertLineBreakOnlyAction'), {hidden: true});\r\n\taddAction('insert_formatted_line_break', bind('lineBreaks', 'insertLineBreakAction'), {hidden: true});\r\n\taddAction('balance_inward', bind('balance', 'balanceInwardAction'), 'Balance (inward)');\r\n\taddAction('balance_outward', bind('balance', 'balanceOutwardAction'), 'Balance (outward)');\r\n\taddAction('matching_pair', bind('balance', 'goToMatchingPairAction'), 'HTML/Go To Matching Tag Pair');\r\n\taddAction('merge_lines', bind('mergeLines', 'mergeLinesAction'), 'Merge Lines');\r\n\taddAction('reflect_css_value', bind('reflectCSSValue', 'reflectCSSValueAction'), 'CSS/Reflect Value');\r\n\taddAction('remove_tag', bind('removeTag', 'removeTagAction'), 'HTML/Remove Tag');\r\n\taddAction('select_next_item', bind('selectItem', 'selectNextItemAction'), 'Select Next Item');\r\n\taddAction('select_previous_item', bind('selectItem', 'selectPreviousItemAction'), 'Select Previous Item');\r\n\taddAction('split_join_tag', bind('splitJoinTag', 'splitJoinTagAction'), 'HTML/Split\\\\Join Tag Declaration');\r\n\taddAction('toggle_comment', bind('toggleComment', 'toggleCommentAction'), 'Toggle Comment');\r\n\taddAction('update_image_size', bind('updateImageSize', 'updateImageSizeAction'), 'Update Image Size');\r\n\taddAction('wrap_with_abbreviation', bind('wrapWithAbbreviation', 'wrapWithAbbreviationAction'), 'Wrap With Abbreviation');\r\n\taddAction('update_tag', bind('updateTag', 'updateTagAction'), 'HTML/Update Tag');\r\n\r\n\t[1, -1, 10, -10, 0.1, -0.1].forEach(function(num) {\r\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\r\n\t\tvar suffix = String(Math.abs(num)).replace('.', '').substring(0, 2);\r\n\t\tvar actionId = prefix + '_number_by_' + suffix;\r\n\t\tvar actionMethod = prefix + suffix + 'Action';\r\n\t\tvar actionLabel = 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num);\r\n\t\taddAction(actionId, bind('incrementDecrement', actionMethod), actionLabel);\r\n\t});\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Registers new action\r\n\t\t * @param {String} name Action name\r\n\t\t * @param {Function} fn Action function\r\n\t\t * @param {Object} options Custom action options:<br>\r\n\t\t * <b>label</b> : (<code>String</code>) – Human-readable action name. \r\n\t\t * May contain '/' symbols as submenu separators<br>\r\n\t\t * <b>hidden</b> : (<code>Boolean</code>) – Indicates whether action\r\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\r\n\t\t */\r\n\t\tadd: addAction,\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns action object\r\n\t\t * @param {String} name Action name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\treturn actions[name.toLowerCase()];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Runs Emmet action. For list of available actions and their\r\n\t\t * arguments see <i>actions</i> folder.\r\n\t\t * @param {String} name Action name \r\n\t\t * @param {Array} args Additional arguments. It may be array of arguments\r\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\r\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\r\n\t\t * means action was performed successfully.\r\n\t\t * @example\r\n\t\t * require('action/main').run('expand_abbreviation', editor);  \r\n\t\t * require('action/main').run('wrap_with_abbreviation', [editor, 'div']);  \r\n\t\t */\r\n\t\trun: function(name, args) {\r\n\t\t\tif (!Array.isArray(args)) {\r\n\t\t\t\targs = utils.toArray(arguments, 1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar action = this.get(name);\r\n\t\t\tif (!action) {\r\n\t\t\t\tthrow new Error('Action \"' + name + '\" is not defined');\r\n\t\t\t}\r\n\r\n\t\t\treturn action.fn.apply(action, args);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all registered actions as object\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetAll: function() {\r\n\t\t\treturn actions;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all registered actions as array\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetList: function() {\r\n\t\t\tvar all = this.getAll();\r\n\t\t\treturn Object.keys(all).map(function(key) {\r\n\t\t\t\treturn all[key];\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\r\n\t\t * it will be splitted by '/' symbol into submenus (for example: \r\n\t\t * CSS/Reflect Value) and grouped with other items\r\n\t\t * @param {Array} skipActions List of action identifiers that should be \r\n\t\t * skipped from menu\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetMenu: function(skipActions) {\r\n\t\t\tvar result = [];\r\n\t\t\tskipActions = skipActions || [];\r\n\t\t\tthis.getList().forEach(function(action) {\r\n\t\t\t\tif (action.options.hidden || ~skipActions.indexOf(action.name))\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t\tvar actionName = humanizeActionName(action.name);\r\n\t\t\t\tvar ctx = result;\r\n\t\t\t\tif (action.options.label) {\r\n\t\t\t\t\tvar parts = action.options.label.split('/');\r\n\t\t\t\t\tactionName = parts.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// create submenus, if needed\r\n\t\t\t\t\tvar menuName, submenu;\r\n\t\t\t\t\twhile ((menuName = parts.shift())) {\r\n\t\t\t\t\t\tsubmenu = utils.find(ctx, function(item) {\r\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!submenu) {\r\n\t\t\t\t\t\t\tsubmenu = {\r\n\t\t\t\t\t\t\t\tname: menuName,\r\n\t\t\t\t\t\t\t\ttype: 'submenu',\r\n\t\t\t\t\t\t\t\titems: []\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tctx.push(submenu);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tctx = submenu.items;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tctx.push({\r\n\t\t\t\t\ttype: 'action',\r\n\t\t\t\t\tname: action.name,\r\n\t\t\t\t\tlabel: actionName\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns action name associated with menu item title\r\n\t\t * @param {String} title\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetActionNameForMenuTitle: function(title, menu) {\r\n\t\t\treturn utils.find(menu || this.getMenu(), function(val) {\r\n\t\t\t\tif (val.type == 'action') {\r\n\t\t\t\t\tif (val.label == title || val.name == title) {\r\n\t\t\t\t\t\treturn val.name;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn this.getActionNameForMenuTitle(title, val.items);\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./balance\":\"action\\\\balance.js\",\"./base64\":\"action\\\\base64.js\",\"./editPoints\":\"action\\\\editPoints.js\",\"./evaluateMath\":\"action\\\\evaluateMath.js\",\"./expandAbbreviation\":\"action\\\\expandAbbreviation.js\",\"./incrementDecrement\":\"action\\\\incrementDecrement.js\",\"./lineBreaks\":\"action\\\\lineBreaks.js\",\"./mergeLines\":\"action\\\\mergeLines.js\",\"./reflectCSSValue\":\"action\\\\reflectCSSValue.js\",\"./removeTag\":\"action\\\\removeTag.js\",\"./selectItem\":\"action\\\\selectItem.js\",\"./selectLine\":\"action\\\\selectLine.js\",\"./splitJoinTag\":\"action\\\\splitJoinTag.js\",\"./toggleComment\":\"action\\\\toggleComment.js\",\"./updateImageSize\":\"action\\\\updateImageSize.js\",\"./updateTag\":\"action\\\\updateTag.js\",\"./wrapWithAbbreviation\":\"action\\\\wrapWithAbbreviation.js\"}],\"action\\\\mergeLines.js\":[function(require,module,exports){\r\n/**\r\n * Merges selected lines or lines between XHTML tag pairs\r\n * @param {Function} require\r\n * @param {Underscore} _\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar range = require('../assets/range');\r\n\r\n\treturn {\r\n\t\tmergeLinesAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\r\n\t\t\tvar selection = range(editor.getSelectionRange());\r\n\t\t\tif (!selection.length()) {\r\n\t\t\t\t// find matching tag\r\n\t\t\t\tvar pair = htmlMatcher.find(info.content, editor.getCaretPos());\r\n\t\t\t\tif (pair) {\r\n\t\t\t\t\tselection = pair.outerRange;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (selection.length()) {\r\n\t\t\t\t// got range, merge lines\r\n\t\t\t\tvar text =  selection.substring(info.content);\r\n\t\t\t\tvar lines = utils.splitByLines(text);\r\n\t\t\t\t\r\n\t\t\t\tfor (var i = 1; i < lines.length; i++) {\r\n\t\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\r\n\t\t\t\tvar textLen = text.length;\r\n\t\t\t\ttext = utils.escapeText(text);\r\n\t\t\t\teditor.replaceContent(text, selection.start, selection.end);\r\n\t\t\t\teditor.createSelection(selection.start, selection.start + textLen);\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\reflectCSSValue.js\":[function(require,module,exports){\r\n/**\r\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \r\n * rules with vendor prefixes\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar handlerList = require('../assets/handlerList');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar cssResolver = require('../resolver/css');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar utils = require('../utils/common');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar cssGradient = require('../resolver/cssGradient');\r\n\r\n\tprefs.define('css.reflect.oldIEOpacity', false, 'Support IE6/7/8 opacity notation, e.g. <code>filter:alpha(opacity=...)</code>.\\\r\n\t\tNote that CSS3 and SVG also provides <code>filter</code> property so this option is disabled by default.')\r\n\r\n\t/**\r\n\t * @type HandlerList List of registered handlers\r\n\t */\r\n\tvar handlers = handlerList.create();\r\n\t\r\n\tfunction doCSSReflection(editor) {\r\n\t\tvar outputInfo = editorUtils.outputInfo(editor);\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\r\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\r\n\t\tif (!cssRule) return;\r\n\t\t\r\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\r\n\t\t// no property under cursor, nothing to reflect\r\n\t\tif (!property) return;\r\n\t\t\r\n\t\tvar oldRule = cssRule.source;\r\n\t\tvar offset = cssRule.options.offset;\r\n\t\tvar caretDelta = caretPos - offset - property.range().start;\r\n\t\t\r\n\t\thandlers.exec(false, [property]);\r\n\t\t\r\n\t\tif (oldRule !== cssRule.source) {\r\n\t\t\treturn {\r\n\t\t\t\tdata:  cssRule.source,\r\n\t\t\t\tstart: offset,\r\n\t\t\t\tend:   offset + oldRule.length,\r\n\t\t\t\tcaret: offset + property.range().start + caretDelta\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns regexp that should match reflected CSS property names\r\n\t * @param {String} name Current CSS property name\r\n\t * @return {RegExp}\r\n\t */\r\n\tfunction getReflectedCSSName(name) {\r\n\t\tname = cssEditTree.baseName(name);\r\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\r\n\t\t\r\n\t\tif ((name == 'opacity' || name == 'filter') && prefs.get('css.reflect.oldIEOpacity')) {\r\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\r\n\t\t} else if ((m = name.match(/^border-radius-(top|bottom)(left|right)/))) {\r\n\t\t\t// Mozilla-style border radius\r\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\r\n\t\t} else if ((m = name.match(/^border-(top|bottom)-(left|right)-radius/))) { \r\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\r\n\t\t}\r\n\t\t\r\n\t\treturn new RegExp(vendorPrefix + name + '$');\r\n\t}\r\n\r\n\t/**\r\n\t * Reflects inner CSS properites in given value\r\n\t * agains name‘s vendor prefix. In other words, it tries\r\n\t * to modify `transform 0.2s linear` value for `-webkit-transition`\r\n\t * property\r\n\t * @param  {String} name  Reciever CSS property name\r\n\t * @param  {String} value New property value\r\n\t * @return {String}\r\n\t */\r\n\tfunction reflectValueParts(name, value) {\r\n\t\t// detects and updates vendor-specific properties in value,\r\n\t\t// e.g. -webkit-transition: -webkit-transform\r\n\t\t\r\n\t\tvar reVendor = /^\\-(\\w+)\\-/;\r\n\t\tvar propPrefix = reVendor.test(name) ? RegExp.$1.toLowerCase() : '';\r\n\t\tvar parts = cssEditTree.findParts(value);\r\n\r\n\t\tparts.reverse();\r\n\t\tparts.forEach(function(part) {\r\n\t\t\tvar partValue = part.substring(value).replace(reVendor, '');\r\n\t\t\tvar prefixes = cssResolver.vendorPrefixes(partValue);\r\n\t\t\tif (prefixes) {\r\n\t\t\t\t// if prefixes are not null then given value can\r\n\t\t\t\t// be resolved against Can I Use database and may or\r\n\t\t\t\t// may not contain prefixed variant\r\n\t\t\t\tif (propPrefix && ~prefixes.indexOf(propPrefix)) {\r\n\t\t\t\t\tpartValue = '-' + propPrefix + '-' + partValue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalue = utils.replaceSubstring(value, partValue, part);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn value;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\r\n\t * @param {CSSProperty} donor Donor CSS property from which value should\r\n\t * be reflected\r\n\t * @param {CSSProperty} receiver Property that should receive reflected \r\n\t * value from donor\r\n\t */\r\n\tfunction reflectValue(donor, receiver) {\r\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \r\n\t\t\t\treceiver.name(), receiver.value());\r\n\t\t\r\n\t\tvalue = reflectValueParts(receiver.name(), value);\r\n\t\treceiver.value(value);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns value that should be reflected for <code>refName</code> CSS property\r\n\t * from <code>curName</code> property. This function is used for special cases,\r\n\t * when the same result must be achieved with different properties for different\r\n\t * browsers. For example: opаcity:0.5; → filter:alpha(opacity=50);<br><br>\r\n\t * \r\n\t * This function does value conversion between different CSS properties\r\n\t * \r\n\t * @param {String} curName Current CSS property name\r\n\t * @param {String} curValue Current CSS property value\r\n\t * @param {String} refName Receiver CSS property's name \r\n\t * @param {String} refValue Receiver CSS property's value\r\n\t * @return {String} New value for receiver property\r\n\t */\r\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\r\n\t\tcurName = cssEditTree.baseName(curName);\r\n\t\trefName = cssEditTree.baseName(refName);\r\n\t\t\r\n\t\tif (curName == 'opacity' && refName == 'filter') {\r\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\r\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\r\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\r\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1], 10) / 100) : refValue;\r\n\t\t}\r\n\t\t\r\n\t\treturn curValue;\r\n\t}\r\n\t\r\n\tmodule = module || {};\r\n\tmodule.exports = {\r\n\t\treflectCSSValueAction: function(editor) {\r\n\t\t\tif (editor.getSyntax() != 'css') {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn actionUtils.compoundUpdate(editor, doCSSReflection(editor));\r\n\t\t},\r\n\r\n\t\t_defaultHandler: function(property) {\r\n\t\t\tvar reName = getReflectedCSSName(property.name());\r\n\t\t\tproperty.parent.list().forEach(function(p) {\r\n\t\t\t\tif (reName.test(p.name())) {\r\n\t\t\t\t\treflectValue(property, p);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Adds custom reflect handler. The passed function will receive matched\r\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\r\n\t\t * return <code>true</code> if it was performed successfully (handled \r\n\t\t * reflection), <code>false</code> otherwise.\r\n\t\t * @param {Function} fn\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\taddHandler: function(fn, options) {\r\n\t\t\thandlers.add(fn, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered handler\r\n\t\t * @returns\r\n\t\t */\r\n\t\tremoveHandler: function(fn) {\r\n\t\t\thandlers.remove(fn);\r\n\t\t}\r\n\t};\r\n\r\n\t// XXX add default handlers\r\n\thandlers.add(module.exports._defaultHandler.bind(module.exports), {order: -1});\r\n\thandlers.add(cssGradient.reflectValueHandler.bind(cssGradient));\r\n\r\n\treturn module.exports;\r\n});\r\n},{\"../assets/handlerList\":\"assets\\\\handlerList.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../resolver/css\":\"resolver\\\\css.js\",\"../resolver/cssGradient\":\"resolver\\\\cssGradient.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\removeTag.js\":[function(require,module,exports){\r\n/**\r\n * Gracefully removes tag under cursor\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\r\n\treturn {\r\n\t\tremoveTagAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\t\r\n\t\t\t// search for tag\r\n\t\t\tvar tag = htmlMatcher.tag(info.content, editor.getCaretPos());\r\n\t\t\tif (tag) {\r\n\t\t\t\tif (!tag.close) {\r\n\t\t\t\t\t// simply remove unary tag\r\n\t\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// remove tag and its newlines\r\n\t\t\t\t\t/** @type Range */\r\n\t\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\r\n\t\t\t\t\t/** @type Range */\r\n\t\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\r\n\t\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\r\n\t\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\r\n\t\t\t\t\t\r\n\t\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\r\n\t\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\selectItem.js\":[function(require,module,exports){\r\n/**\r\n * Actions that use stream parsers and tokenizers for traversing:\r\n * -- Search for next/previous items in HTML\r\n * -- Search for next/previous items in CSS\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar xmlParser = require('../parser/xml');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar cssSections = require('../utils/cssSections');\r\n\r\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\r\n\r\n\t/**\r\n\t * Generic function for searching for items to select\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\r\n\t * @param {Function} extractFn Function that extracts item content\r\n\t * @param {Function} rangeFn Function that search for next token range\r\n\t */\r\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\r\n\t\tvar content = editorUtils.outputInfo(editor).content;\r\n\t\t\r\n\t\tvar contentLength = content.length;\r\n\t\tvar itemRange, rng;\r\n\t\t/** @type Range */\r\n\t\tvar prevRange = range(-1, 0);\r\n\t\t/** @type Range */\r\n\t\tvar sel = range(editor.getSelectionRange());\r\n\t\t\r\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\r\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\r\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\r\n\t\t\t\tif (prevRange.equal(itemRange)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tprevRange = itemRange.clone();\r\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\r\n\t\t\t\t\r\n\t\t\t\tif (rng) {\r\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsearchPos += isBackward ? -1 : 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// XXX HTML section\r\n\t\r\n\t/**\r\n\t * Find next HTML item\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction findNextHTMLItem(editor) {\r\n\t\tvar isFirst = true;\r\n\t\treturn findItem(editor, false, function(content, searchPos){\r\n\t\t\tif (isFirst) {\r\n\t\t\t\tisFirst = false;\r\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\r\n\t\t\t} else {\r\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\r\n\t\t\t}\r\n\t\t}, function(tag, offset, selRange) {\r\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Find previous HTML item\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction findPrevHTMLItem(editor) {\r\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\r\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates possible selection ranges for HTML tag\r\n\t * @param {String} source Original HTML source for tokens\r\n\t * @param {Array} tokens List of HTML tokens\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\r\n\t\toffset = offset || 0;\r\n\t\tvar result = [];\r\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\r\n\t\ttokens.forEach(function(tok) {\r\n\t\t\tswitch (tok.type) {\r\n\t\t\t\tcase 'tag':\r\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\r\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\r\n\t\t\t\t\t\t// add tag name\r\n\t\t\t\t\t\tresult.push(range({\r\n\t\t\t\t\t\t\tstart: tok.start + 1, \r\n\t\t\t\t\t\t\tend: tok.end\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'attribute':\r\n\t\t\t\t\tattrStart = tok.start;\r\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\t// attribute value\r\n\t\t\t\t\t// push full attribute first\r\n\t\t\t\t\tresult.push(range(attrStart, tok.end - attrStart));\r\n\t\t\t\t\t\r\n\t\t\t\t\tattrValueRange = range(tok);\r\n\t\t\t\t\tattrValue = attrValueRange.substring(source);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// is this a quoted attribute?\r\n\t\t\t\t\tif (isQuote(attrValue.charAt(0)))\r\n\t\t\t\t\t\tattrValueRange.start++;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (isQuote(attrValue.charAt(attrValue.length - 1)))\r\n\t\t\t\t\t\tattrValueRange.end--;\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult.push(attrValueRange);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (attrName == 'class') {\r\n\t\t\t\t\t\tresult = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// offset ranges\r\n\t\tresult = result.filter(function(item) {\r\n\t\t\tif (item.length()) {\r\n\t\t\t\titem.shift(offset);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// remove duplicates\r\n\t\treturn utils.unique(result, function(item) {\r\n\t\t\treturn item.toString();\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns ranges of class names in \"class\" attribute value\r\n\t * @param {String} className\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction classNameRanges(className, offset) {\r\n\t\toffset = offset || 0;\r\n\t\tvar result = [];\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(className);\r\n\t\t\r\n\t\t// skip whitespace\r\n\t\tstream.eatSpace();\r\n\t\tstream.start = stream.pos;\r\n\t\t\r\n\t\tvar ch;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\r\n\t\t\t\tresult.push(range(stream.start + offset, stream.pos - stream.start - 1));\r\n\t\t\t\tstream.eatSpace();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tresult.push(range(stream.start + offset, stream.pos - stream.start));\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns best HTML tag range match for current selection\r\n\t * @param {String} tag Tag declaration\r\n\t * @param {Number} offset Tag's position index inside content\r\n\t * @param {Range} selRange Selection range\r\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\r\n\t */\r\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\r\n\t\tvar ranges = makePossibleRangesHTML(tag, xmlParser.parse(tag), offset);\r\n\t\t\r\n\t\tif (isBackward)\r\n\t\t\tranges.reverse();\r\n\t\t\r\n\t\t// try to find selected range\r\n\t\tvar curRange = utils.find(ranges, function(r) {\r\n\t\t\treturn r.equal(selRange);\r\n\t\t});\r\n\t\t\r\n\t\tif (curRange) {\r\n\t\t\tvar ix = ranges.indexOf(curRange);\r\n\t\t\tif (ix < ranges.length - 1)\r\n\t\t\t\treturn ranges[ix + 1];\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\t// no selected range, find nearest one\r\n\t\tif (isBackward)\r\n\t\t\t// search backward\r\n\t\t\treturn utils.find(ranges, function(r) {\r\n\t\t\t\treturn r.start < selRange.start;\r\n\t\t\t});\r\n\t\t\r\n\t\t// search forward\r\n\t\t// to deal with overlapping ranges (like full attribute definition\r\n\t\t// and attribute value) let's find range under caret first\r\n\t\tif (!curRange) {\r\n\t\t\tvar matchedRanges = ranges.filter(function(r) {\r\n\t\t\t\treturn r.inside(selRange.end);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (matchedRanges.length > 1)\r\n\t\t\t\treturn matchedRanges[1];\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn utils.find(ranges, function(r) {\r\n\t\t\treturn r.end > selRange.end;\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Search for opening tag in content, starting at specified position\r\n\t * @param {String} html Where to search tag\r\n\t * @param {Number} pos Character index where to start searching\r\n\t * @return {Range} Returns range if valid opening tag was found,\r\n\t * <code>null</code> otherwise\r\n\t */\r\n\tfunction findOpeningTagFromPosition(html, pos) {\r\n\t\tvar tag;\r\n\t\twhile (pos >= 0) {\r\n\t\t\tif ((tag = getOpeningTagFromPosition(html, pos)))\r\n\t\t\t\treturn tag;\r\n\t\t\tpos--;\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param {String} html Where to search tag\r\n\t * @param {Number} pos Character index where to start searching\r\n\t * @return {Range} Returns range if valid opening tag was found,\r\n\t * <code>null</code> otherwise\r\n\t */\r\n\tfunction getOpeningTagFromPosition(html, pos) {\r\n\t\tvar m;\r\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\r\n\t\t\treturn range(pos, m[0]);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction isQuote(ch) {\r\n\t\treturn ch == '\"' || ch == \"'\";\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all ranges inside given rule, available for selection\r\n\t * @param  {CSSEditContainer} rule\r\n\t * @return {Array}\r\n\t */\r\n\tfunction findInnerRanges(rule) {\r\n\t\t// rule selector\r\n\t\tvar ranges = [rule.nameRange(true)];\r\n\r\n\t\t// find nested sections, keep selectors only\r\n\t\tvar nestedSections = cssSections.nestedSectionsInRule(rule);\r\n\t\tnestedSections.forEach(function(section) {\r\n\t\t\tranges.push(range.create2(section.start, section._selectorEnd));\r\n\t\t});\r\n\r\n\t\t// add full property ranges and values\r\n\t\trule.list().forEach(function(property) {\r\n\t\t\tranges = ranges.concat(makePossibleRangesCSS(property));\r\n\t\t});\r\n\r\n\t\tranges = range.sort(ranges);\r\n\r\n\t\t// optimize result: remove empty ranges and duplicates\r\n\t\tranges = ranges.filter(function(item) {\r\n\t\t\treturn !!item.length();\r\n\t\t});\r\n\t\treturn utils.unique(ranges, function(item) {\r\n\t\t\treturn item.toString();\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Makes all possible selection ranges for specified CSS property\r\n\t * @param {CSSProperty} property\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction makePossibleRangesCSS(property) {\r\n\t\t// find all possible ranges, sorted by position and size\r\n\t\tvar valueRange = property.valueRange(true);\r\n\t\tvar result = [property.range(true), valueRange];\r\n\t\t\r\n\t\t// locate parts of complex values.\r\n\t\t// some examples:\r\n\t\t// – 1px solid red: 3 parts\r\n\t\t// – arial, sans-serif: enumeration, 2 parts\r\n\t\t// – url(image.png): function value part\r\n\t\tvar value = property.value();\r\n\t\tproperty.valueParts().forEach(function(r) {\r\n\t\t\t// add absolute range\r\n\t\t\tvar clone = r.clone();\r\n\t\t\tresult.push(clone.shift(valueRange.start));\r\n\t\t\t\r\n\t\t\t/** @type StringStream */\r\n\t\t\tvar stream = stringStream.create(r.substring(value));\r\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\r\n\t\t\t\t// we have a function, find values in it.\r\n\t\t\t\t// but first add function contents\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tstream.skipToPair('(', ')');\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tvar fnBody = stream.current();\r\n\t\t\t\tresult.push(range(clone.start + stream.start, fnBody));\r\n\t\t\t\t\r\n\t\t\t\t// find parts\r\n\t\t\t\tcssEditTree.findParts(fnBody).forEach(function(part) {\r\n\t\t\t\t\tresult.push(range(clone.start + stream.start + part.start, part.substring(fnBody)));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Tries to find matched CSS property and nearest range for selection\r\n\t * @param {CSSRule} rule\r\n\t * @param {Range} selRange\r\n\t * @param {Boolean} isBackward\r\n\t * @returns {Range}\r\n\t */\r\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\r\n\t\tvar ranges = findInnerRanges(rule);\r\n\t\tif (isBackward) {\r\n\t\t\tranges.reverse();\r\n\t\t}\r\n\t\t\r\n\t\t// return next to selected range, if possible\r\n\t\tvar r = utils.find(ranges, function(item) {\r\n\t\t\treturn item.equal(selRange);\r\n\t\t});\r\n\r\n\t\tif (r) {\r\n\t\t\treturn ranges[ranges.indexOf(r) + 1];\r\n\t\t}\r\n\r\n\t\t// find matched and (possibly) overlapping ranges\r\n\t\tvar nested = ranges.filter(function(item) {\r\n\t\t\treturn item.inside(selRange.end);\r\n\t\t});\r\n\r\n\t\tif (nested.length) {\r\n\t\t\treturn nested.sort(function(a, b) {\r\n\t\t\t\treturn a.length() - b.length();\r\n\t\t\t})[0];\r\n\t\t}\r\n\r\n\t\t// return range next to caret\r\n\t\tvar test = \r\n\t\tr = utils.find(ranges, isBackward \r\n\t\t\t? function(item) {return item.end < selRange.start;}\r\n\t\t\t: function(item) {return item.end > selRange.start;}\r\n\t\t);\r\n\r\n\t\tif (!r) {\r\n\t\t\t// can’t find anything, just pick first one\r\n\t\t\tr = ranges[0];\r\n\t\t}\r\n\r\n\t\treturn r;\r\n\t}\r\n\t\r\n\tfunction findNextCSSItem(editor) {\r\n\t\treturn findItem(editor, false, cssSections.locateRule.bind(cssSections), getRangeForNextItemInCSS);\r\n\t}\r\n\t\r\n\tfunction findPrevCSSItem(editor) {\r\n\t\treturn findItem(editor, true, cssSections.locateRule.bind(cssSections), getRangeForPrevItemInCSS);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns range for item to be selected in CSS after current caret \r\n\t * (selection) position\r\n\t * @param {String} rule CSS rule declaration\r\n\t * @param {Number} offset Rule's position index inside content\r\n\t * @param {Range} selRange Selection range\r\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\r\n\t */\r\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\r\n\t\tvar tree = cssEditTree.parse(rule, {\r\n\t\t\toffset: offset\r\n\t\t});\r\n\r\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns range for item to be selected in CSS before current caret \r\n\t * (selection) position\r\n\t * @param {String} rule CSS rule declaration\r\n\t * @param {Number} offset Rule's position index inside content\r\n\t * @param {Range} selRange Selection range\r\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\r\n\t */\r\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\r\n\t\tvar tree = cssEditTree.parse(rule, {\r\n\t\t\toffset: offset\r\n\t\t});\r\n\r\n\t\treturn matchedRangeForCSSProperty(tree, selRange, true);\r\n\t}\r\n\r\n\treturn {\r\n\t\tselectNextItemAction: function(editor) {\r\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\r\n\t\t\t\treturn findNextCSSItem(editor);\r\n\t\t\t} else {\r\n\t\t\t\treturn findNextHTMLItem(editor);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tselectPreviousItemAction: function(editor) {\r\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\r\n\t\t\t\treturn findPrevCSSItem(editor);\r\n\t\t\t} else {\r\n\t\t\t\treturn findPrevHTMLItem(editor);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../parser/xml\":\"parser\\\\xml.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\selectLine.js\":[function(require,module,exports){\r\n/**\r\n * Select current line (for simple editors like browser's &lt;textarea&gt;)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\treturn {\r\n\t\tselectLineAction: function(editor) {\r\n\t\t\tvar range = editor.getCurrentLineRange();\r\n\t\t\teditor.createSelection(range.start, range.end);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"action\\\\splitJoinTag.js\":[function(require,module,exports){\r\n/**\r\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\r\n * &lt;div&gt;&lt;/div&gt; → &lt;div /&gt; : join<br>\r\n * &lt;div /&gt; → &lt;div&gt;&lt;/div&gt; : split\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar resources = require('../assets/resources');\r\n\tvar matcher = require('../assets/htmlMatcher');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar profile = require('../assets/profile');\r\n\r\n\t/**\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {Object} profile\r\n\t * @param {Object} tag\r\n\t */\r\n\tfunction joinTag(editor, profile, tag) {\r\n\t\t// empty closing slash is a nonsense for this action\r\n\t\tvar slash = profile.selfClosing() || ' /';\r\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\r\n\t\t\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\r\n\t\t// update caret position\r\n\t\tif (content.length + tag.outerRange.start < caretPos) {\r\n\t\t\tcaretPos = content.length + tag.outerRange.start;\r\n\t\t}\r\n\t\t\r\n\t\tcontent = utils.escapeText(content);\r\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\r\n\t\teditor.setCaretPos(caretPos);\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction splitTag(editor, profile, tag) {\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\r\n\t\t// define tag content depending on profile\r\n\t\tvar tagContent = (profile.tag_nl === true) ? '\\n\\t\\n' : '';\r\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\r\n\t\tcaretPos = tag.outerRange.start + content.length;\r\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\r\n\t\t\r\n\t\tcontent = utils.escapeText(content);\r\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\r\n\t\teditor.setCaretPos(caretPos);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn {\r\n\t\tsplitJoinTagAction: function(editor, profileName) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor, null, profileName);\r\n\t\t\tvar curProfile = profile.get(info.profile);\r\n\t\t\t\r\n\t\t\t// find tag at current position\r\n\t\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\r\n\t\t\tif (tag) {\r\n\t\t\t\treturn tag.close \r\n\t\t\t\t\t? joinTag(editor, curProfile, tag) \r\n\t\t\t\t\t: splitTag(editor, curProfile, tag);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\toggleComment.js\":[function(require,module,exports){\r\n/**\r\n * Toggles HTML and CSS comments depending on current caret context. Unlike\r\n * the same action in most editors, this action toggles comment on currently\r\n * matched item—HTML tag or CSS selector—when nothing is selected.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\r\n\t/**\r\n\t * Toggle HTML comment on current selection or tag\r\n\t * @param {IEmmetEditor} editor\r\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\r\n\t */\r\n\tfunction toggleHTMLComment(editor) {\r\n\t\t/** @type Range */\r\n\t\tvar r = range(editor.getSelectionRange());\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\t\r\n\t\tif (!r.length()) {\r\n\t\t\t// no selection, find matching tag\r\n\t\t\tvar tag = htmlMatcher.tag(info.content, editor.getCaretPos());\r\n\t\t\tif (tag) { // found pair\r\n\t\t\t\tr = tag.outerRange;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn genericCommentToggle(editor, '<!--', '-->', r);\r\n\t}\r\n\r\n\t/**\r\n\t * Simple CSS commenting\r\n\t * @param {IEmmetEditor} editor\r\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\r\n\t */\r\n\tfunction toggleCSSComment(editor) {\r\n\t\t/** @type Range */\r\n\t\tvar rng = range(editor.getSelectionRange());\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\t\r\n\t\tif (!rng.length()) {\r\n\t\t\t// no selection, try to get current rule\r\n\t\t\t/** @type CSSRule */\r\n\t\t\tvar rule = cssEditTree.parseFromPosition(info.content, editor.getCaretPos());\r\n\t\t\tif (rule) {\r\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\r\n\t\t\t\trng = property \r\n\t\t\t\t\t? property.range(true) \r\n\t\t\t\t\t: range(rule.nameRange(true).start, rule.source);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (!rng.length()) {\r\n\t\t\t// still no selection, get current line\r\n\t\t\trng = range(editor.getCurrentLineRange());\r\n\t\t\tutils.narrowToNonSpace(info.content, rng);\r\n\t\t}\r\n\t\t\r\n\t\treturn genericCommentToggle(editor, '/*', '*/', rng);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns CSS property from <code>rule</code> that matches passed position\r\n\t * @param {EditContainer} rule\r\n\t * @param {Number} absPos\r\n\t * @returns {EditElement}\r\n\t */\r\n\tfunction cssItemFromPosition(rule, absPos) {\r\n\t\t// do not use default EditContainer.itemFromPosition() here, because\r\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\r\n\t\tvar relPos = absPos - (rule.options.offset || 0);\r\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\r\n\t\treturn utils.find(rule.list(), function(item) {\r\n\t\t\tif (item.range().end === relPos) {\r\n\t\t\t\t// at the end of property, but outside of it\r\n\t\t\t\t// if there’s a space character at current position,\r\n\t\t\t\t// use current property\r\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn item.range().inside(relPos);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\r\n\t * @param {String} text Where to search\r\n\t * @param {Number} from Search start index\r\n\t * @param {String} start_token Comment start string\r\n\t * @param {String} end_token Comment end string\r\n\t * @return {Range} Returns null if comment wasn't found\r\n\t */\r\n\tfunction searchComment(text, from, startToken, endToken) {\r\n\t\tvar commentStart = -1;\r\n\t\tvar commentEnd = -1;\r\n\t\t\r\n\t\tvar hasMatch = function(str, start) {\r\n\t\t\treturn text.substr(start, str.length) == str;\r\n\t\t};\r\n\t\t\t\r\n\t\t// search for comment start\r\n\t\twhile (from--) {\r\n\t\t\tif (hasMatch(startToken, from)) {\r\n\t\t\t\tcommentStart = from;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (commentStart != -1) {\r\n\t\t\t// search for comment end\r\n\t\t\tfrom = commentStart;\r\n\t\t\tvar contentLen = text.length;\r\n\t\t\twhile (contentLen >= from++) {\r\n\t\t\t\tif (hasMatch(endToken, from)) {\r\n\t\t\t\t\tcommentEnd = from + endToken.length;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn (commentStart != -1 && commentEnd != -1) \r\n\t\t\t? range(commentStart, commentEnd - commentStart) \r\n\t\t\t: null;\r\n\t}\r\n\r\n\t/**\r\n\t * Generic comment toggling routine\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} commentStart Comment start token\r\n\t * @param {String} commentEnd Comment end token\r\n\t * @param {Range} range Selection range\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\r\n\t\tvar content = editorUtils.outputInfo(editor).content;\r\n\t\tvar caretPos = editor.getCaretPos();\r\n\t\tvar newContent = null;\r\n\t\t\t\r\n\t\t/**\r\n\t\t * Remove comment markers from string\r\n\t\t * @param {Sting} str\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tfunction removeComment(str) {\r\n\t\t\treturn str\r\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\r\n\t\t\t\t\tcaretPos -= str.length;\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\r\n\t\t}\r\n\t\t\r\n\t\t// first, we need to make sure that this substring is not inside \r\n\t\t// comment\r\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\r\n\t\tif (commentRange && commentRange.overlap(range)) {\r\n\t\t\t// we're inside comment, remove it\r\n\t\t\trange = commentRange;\r\n\t\t\tnewContent = removeComment(range.substring(content));\r\n\t\t} else {\r\n\t\t\t// should add comment\r\n\t\t\t// make sure that there's no comment inside selection\r\n\t\t\tnewContent = commentStart + ' ' +\r\n\t\t\t\trange.substring(content)\r\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\r\n\t\t\t\t' ' + commentEnd;\r\n\t\t\t\t\r\n\t\t\t// adjust caret position\r\n\t\t\tcaretPos += commentStart.length + 1;\r\n\t\t}\r\n\r\n\t\t// replace editor content\r\n\t\tif (newContent !== null) {\r\n\t\t\tnewContent = utils.escapeText(newContent);\r\n\t\t\teditor.setCaretPos(range.start);\r\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\r\n\t\t\teditor.setCaretPos(caretPos);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Toggle comment on current editor's selection or HTML tag/CSS rule\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t */\r\n\t\ttoggleCommentAction: function(editor) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\t\tif (actionUtils.isSupportedCSS(info.syntax)) {\r\n\t\t\t\t// in case our editor is good enough and can recognize syntax from \r\n\t\t\t\t// current token, we have to make sure that cursor is not inside\r\n\t\t\t\t// 'style' attribute of html element\r\n\t\t\t\tvar caretPos = editor.getCaretPos();\r\n\t\t\t\tvar tag = htmlMatcher.tag(info.content, caretPos);\r\n\t\t\t\tif (tag && tag.open.range.inside(caretPos)) {\r\n\t\t\t\t\tinfo.syntax = 'html';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\r\n\t\t\tif (~cssSyntaxes.indexOf(info.syntax)) {\r\n\t\t\t\treturn toggleCSSComment(editor);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn toggleHTMLComment(editor);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\updateImageSize.js\":[function(require,module,exports){\r\n/**\r\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\r\n * CSS rule\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar base64 = require('../utils/base64');\r\n\tvar file = require('../plugin/file');\r\n\r\n\t/**\r\n\t * Updates image size of &lt;img src=\"\"&gt; tag\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction updateImageSizeHTML(editor) {\r\n\t\tvar offset = editor.getCaretPos();\r\n\r\n\t\t// find tag from current caret position\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar xmlElem = xmlEditTree.parseFromPosition(info.content, offset, true);\r\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\r\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\r\n\t\t\t\tif (size) {\r\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\r\n\t\t\t\t\txmlElem.value('width', size.width);\r\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\r\n\r\n\t\t\t\t\tactionUtils.compoundUpdate(editor, utils.extend(compoundData, {\r\n\t\t\t\t\t\tdata: xmlElem.toString(),\r\n\t\t\t\t\t\tcaret: offset\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates image size of CSS property\r\n\t * @param {IEmmetEditor} editor\r\n\t */\r\n\tfunction updateImageSizeCSS(editor) {\r\n\t\tvar offset = editor.getCaretPos();\r\n\r\n\t\t// find tag from current caret position\r\n\t\tvar info = editorUtils.outputInfo(editor);\r\n\t\tvar cssRule = cssEditTree.parseFromPosition(info.content, offset, true);\r\n\t\tif (cssRule) {\r\n\t\t\t// check if there is property with image under caret\r\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\r\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\r\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\r\n\t\t\t\t\tif (size) {\r\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\r\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\r\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\r\n\r\n\t\t\t\t\t\tactionUtils.compoundUpdate(editor, utils.extend(compoundData, {\r\n\t\t\t\t\t\t\tdata: cssRule.toString(),\r\n\t\t\t\t\t\t\tcaret: offset\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns image dimensions for source\r\n\t * @param {IEmmetEditor} editor\r\n\t * @param {String} src Image source (path or data:url)\r\n\t */\r\n\tfunction getImageSizeForSource(editor, src, callback) {\r\n\t\tvar fileContent;\r\n\t\tif (src) {\r\n\t\t\t// check if it is data:url\r\n\t\t\tif (/^data:/.test(src)) {\r\n\t\t\t\tfileContent = base64.decode( src.replace(/^data\\:.+?;.+?,/, '') );\r\n\t\t\t\treturn callback(actionUtils.getImageSize(fileContent));\r\n\t\t\t}\r\n\r\n\t\t\tvar filePath = editor.getFilePath();\r\n\t\t\tfile.locateFile(filePath, src, function(absPath) {\r\n\t\t\t\tif (absPath === null) {\r\n\t\t\t\t\tthrow \"Can't find \" + src + ' file';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfile.read(absPath, function(err, content) {\r\n\t\t\t\t\tif (err) {\r\n\t\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontent = String(content);\r\n\t\t\t\t\tcallback(actionUtils.getImageSize(content));\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tupdateImageSizeAction: function(editor) {\r\n\t\t\t// this action will definitely won’t work in SASS dialect,\r\n\t\t\t// but may work in SCSS or LESS\r\n\t\t\tif (actionUtils.isSupportedCSS(editor.getSyntax())) {\r\n\t\t\t\tupdateImageSizeCSS(editor);\r\n\t\t\t} else {\r\n\t\t\t\tupdateImageSizeHTML(editor);\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../editTree/css\":\"editTree\\\\css.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../plugin/file\":\"plugin\\\\file.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/base64\":\"utils\\\\base64.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\updateTag.js\":[function(require,module,exports){\r\n/**\r\n * Update Tag action: allows users to update existing HTML tags and add/remove\r\n * attributes or even tag name\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar utils = require('../utils/common');\r\n\tvar parser = require('../parser/abbreviation');\r\n\r\n\tfunction updateAttributes(tag, abbrNode, ix) {\r\n\t\tvar classNames = (abbrNode.attribute('class') || '').split(/\\s+/g);\r\n\t\tif (ix) {\r\n\t\t\tclassNames.push('+' + abbrNode.name());\r\n\t\t}\r\n\r\n\t\tvar r = function(str) {\r\n\t\t\treturn utils.replaceCounter(str, abbrNode.counter);\r\n\t\t};\r\n\r\n\t\t// update class\r\n\t\tclassNames.forEach(function(className) {\r\n\t\t\tif (!className) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tclassName = r(className);\r\n\t\t\tvar ch = className.charAt(0);\r\n\t\t\tif (ch == '+') {\r\n\t\t\t\ttag.addClass(className.substr(1));\r\n\t\t\t} else if (ch == '-') {\r\n\t\t\t\ttag.removeClass(className.substr(1));\r\n\t\t\t} else {\r\n\t\t\t\ttag.value('class', className);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// update attributes\r\n\t\tabbrNode.attributeList().forEach(function(attr) {\r\n\t\t\tif (attr.name.toLowerCase() == 'class') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar ch = attr.name.charAt(0);\r\n\t\t\tif (ch == '+') {\r\n\t\t\t\tvar attrName = attr.name.substr(1);\r\n\t\t\t\tvar tagAttr = tag.get(attrName);\r\n\t\t\t\tif (tagAttr) {\r\n\t\t\t\t\ttagAttr.value(tagAttr.value() + r(attr.value));\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttag.value(attrName, r(attr.value));\r\n\t\t\t\t}\r\n\t\t\t} else if (ch == '-') {\r\n\t\t\t\ttag.remove(attr.name.substr(1));\r\n\t\t\t} else {\r\n\t\t\t\ttag.value(attr.name, r(attr.value));\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Matches HTML tag under caret and updates its definition\r\n\t\t * according to given abbreviation\r\n\t\t * @param {IEmmetEditor} Editor instance\r\n\t\t * @param {String} abbr Abbreviation to update with\r\n\t\t */\r\n\t\tupdateTagAction: function(editor, abbr) {\r\n\t\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\r\n\r\n\t\t\tif (!abbr) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar content = editor.getContent();\r\n\t\t\tvar ctx = actionUtils.captureContext(editor);\r\n\t\t\tvar tag = this.getUpdatedTag(abbr, ctx, content);\r\n\r\n\t\t\tif (!tag) {\r\n\t\t\t\t// nothing to update\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// check if tag name was updated\r\n\t\t\tif (tag.name() != ctx.name && ctx.match.close) {\r\n\t\t\t\teditor.replaceContent('</' + tag.name() + '>', ctx.match.close.range.start, ctx.match.close.range.end, true);\r\n\t\t\t}\r\n\r\n\t\t\teditor.replaceContent(tag.source, ctx.match.open.range.start, ctx.match.open.range.end, true);\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns XMLEditContainer node with updated tag structure\r\n\t\t * of existing tag context.\r\n\t\t * This data can be used to modify existing tag\r\n\t\t * @param  {String} abbr    Abbreviation\r\n\t\t * @param  {Object} ctx     Tag to be updated (captured with `htmlMatcher`)\r\n\t\t * @param  {String} content Original editor content\r\n\t\t * @return {XMLEditContainer}\r\n\t\t */\r\n\t\tgetUpdatedTag: function(abbr, ctx, content, options) {\r\n\t\t\tif (!ctx) {\r\n\t\t\t\t// nothing to update\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar tree = parser.parse(abbr, options || {});\r\n\r\n\t\t\t// for this action some characters in abbreviation has special\r\n\t\t\t// meaning. For example, `.-c2` means “remove `c2` class from\r\n\t\t\t// element” and `.+c3` means “append class `c3` to exising one.\r\n\t\t\t// \r\n\t\t\t// But `.+c3` abbreviation will actually produce two elements:\r\n\t\t\t// <div class=\"\"> and <c3>. Thus, we have to walk on each element\r\n\t\t\t// of parsed tree and use their definitions to update current element\r\n\t\t\tvar tag = xmlEditTree.parse(ctx.match.open.range.substring(content), {\r\n\t\t\t\toffset: ctx.match.outerRange.start\r\n\t\t\t});\r\n\r\n\t\t\ttree.children.forEach(function(node, i) {\r\n\t\t\t\tupdateAttributes(tag, node, i);\r\n\t\t\t});\r\n\r\n\t\t\t// if tag name was resolved by implicit tag name resolver,\r\n\t\t\t// then user omitted it in abbreviation and wants to keep\r\n\t\t\t// original tag name\r\n\t\t\tvar el = tree.children[0];\r\n\t\t\tif (!el.data('nameResolved')) {\r\n\t\t\t\ttag.name(el.name());\r\n\t\t\t}\r\n\r\n\t\t\treturn tag;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"action\\\\wrapWithAbbreviation.js\":[function(require,module,exports){\r\n/**\r\n * Action that wraps content with abbreviation. For convenience, action is \r\n * defined as reusable module\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar utils = require('../utils/common');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar actionUtils = require('../utils/action');\r\n\tvar parser = require('../parser/abbreviation');\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Wraps content with abbreviation\r\n\t\t * @param {IEmmetEditor} Editor instance\r\n\t\t * @param {String} abbr Abbreviation to wrap with\r\n\t\t * @param {String} syntax Syntax type (html, css, etc.)\r\n\t\t * @param {String} profile Output profile name (html, xml, xhtml)\r\n\t\t */\r\n\t\twrapWithAbbreviationAction: function(editor, abbr, syntax, profile) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\r\n\t\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\r\n\t\t\t\r\n\t\t\tif (!abbr) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tabbr = String(abbr);\r\n\t\t\t\r\n\t\t\tvar r = range(editor.getSelectionRange());\r\n\t\t\t\r\n\t\t\tif (!r.length()) {\r\n\t\t\t\t// no selection, find tag pair\r\n\t\t\t\tvar match = htmlMatcher.tag(info.content, r.start);\r\n\t\t\t\tif (!match) {  // nothing to wrap\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tr = utils.narrowToNonSpace(info.content, match.range);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar newContent = utils.escapeText(r.substring(info.content));\r\n\t\t\tvar result = parser.expand(abbr, {\r\n\t\t\t\tpastedContent: editorUtils.unindent(editor, newContent),\r\n\t\t\t\tsyntax: info.syntax,\r\n\t\t\t\tprofile: info.profile,\r\n\t\t\t\tcontextNode: actionUtils.captureContext(editor)\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (result) {\r\n\t\t\t\teditor.replaceContent(result, r.start, r.end);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"../utils/action\":\"utils\\\\action.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\"}],\"assets\\\\caniuse.js\":[function(require,module,exports){\r\n/**\r\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\r\n * Contains convenient method to get access for snippets with respect of\r\n * inheritance. Also provides ability to store data in different vocabularies\r\n * ('system' and 'user') for fast and safe resource update\r\n * @author Sergey Chikuyonok (serge.che@gmail.com)\r\n * @link http://chikuyonok.ru\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('./preferences');\r\n\tvar utils = require('../utils/common');\r\n\r\n\tprefs.define('caniuse.enabled', true, 'Enable support of Can I Use database. When enabled,\\\r\n\t\tCSS abbreviation resolver will look at Can I Use database first before detecting\\\r\n\t\tCSS properties that should be resolved');\r\n\r\n\tprefs.define('caniuse.vendors', 'all', 'A comma-separated list vendor identifiers\\\r\n\t\t(as described in Can I Use database) that should be supported\\\r\n\t\twhen resolving vendor-prefixed properties. Set value to <code>all</code>\\\r\n\t\tto support all available properties');\r\n\r\n\tprefs.define('caniuse.era', 'e-2', 'Browser era, as defined in Can I Use database.\\\r\n\t\tExamples: <code>e0</code> (current version), <code>e1</code> (near future)\\\r\n\t\t<code>e-2</code> (2 versions back) and so on.');\r\n\r\n\tvar cssSections = {\r\n\t\t'border-image': ['border-image'],\r\n\t\t'css-boxshadow': ['box-shadow'],\r\n\t\t'css3-boxsizing': ['box-sizing'],\r\n\t\t'multicolumn': ['column-width', 'column-count', 'columns', 'column-gap', 'column-rule-color', 'column-rule-style', 'column-rule-width', 'column-rule', 'column-span', 'column-fill'],\r\n\t\t'border-radius': ['border-radius', 'border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius'],\r\n\t\t'transforms2d': ['transform'],\r\n\t\t'css-hyphens': ['hyphens'],\r\n\t\t'css-transitions': ['transition', 'transition-property', 'transition-duration', 'transition-timing-function', 'transition-delay'],\r\n\t\t'font-feature': ['font-feature-settings'],\r\n\t\t'css-animation': ['animation', 'animation-name', 'animation-duration', 'animation-timing-function', 'animation-iteration-count', 'animation-direction', 'animation-play-state', 'animation-delay', 'animation-fill-mode', '@keyframes'],\r\n\t\t'css-gradients': ['linear-gradient'],\r\n\t\t'css-masks': ['mask-image', 'mask-source-type', 'mask-repeat', 'mask-position', 'mask-clip', 'mask-origin', 'mask-size', 'mask', 'mask-type', 'mask-box-image-source', 'mask-box-image-slice', 'mask-box-image-width', 'mask-box-image-outset', 'mask-box-image-repeat', 'mask-box-image', 'clip-path', 'clip-rule'],\r\n\t\t'css-featurequeries': ['@supports'],\r\n\t\t'flexbox': ['flex', 'inline-flex', 'flex-direction', 'flex-wrap', 'flex-flow', 'order', 'flex'],\r\n\t\t'calc': ['calc'],\r\n\t\t'object-fit': ['object-fit', 'object-position'],\r\n\t\t'css-grid': ['grid', 'inline-grid', 'grid-template-rows', 'grid-template-columns', 'grid-template-areas', 'grid-template', 'grid-auto-rows', 'grid-auto-columns', ' grid-auto-flow', 'grid-auto-position', 'grid', ' grid-row-start', 'grid-column-start', 'grid-row-end', 'grid-column-end', 'grid-column', 'grid-row', 'grid-area', 'justify-self', 'justify-items', 'align-self', 'align-items'],\r\n\t\t'css-repeating-gradients': ['repeating-linear-gradient'],\r\n\t\t'css-filters': ['filter'],\r\n\t\t'user-select-none': ['user-select'],\r\n\t\t'intrinsic-width': ['min-content', 'max-content', 'fit-content', 'fill-available'],\r\n\t\t'css3-tabsize': ['tab-size']\r\n\t};\r\n\r\n\t/** @type {Object} The Can I Use database for CSS */\r\n\tvar cssDB = null;\r\n\t/** @type {Object} A list of available vendors (browsers) and their prefixes */\r\n\tvar vendorsDB = null;\r\n\tvar erasDB = null;\r\n\r\n\tfunction intersection(arr1, arr2) {\r\n\t\tvar result = [];\r\n\t\tvar smaller = arr1, larger = arr2;\r\n\t\tif (smaller.length > larger.length) {\r\n\t\t\tsmaller = arr2;\r\n\t\t\tlarger = arr1;\r\n\t\t}\r\n\t\tlarger.forEach(function(item) {\r\n\t\t\tif (~smaller.indexOf(item)) {\r\n\t\t\t\tresult.push(item);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses raw Can I Use database for better lookups\r\n\t * @param  {String} data Raw database\r\n\t * @param  {Boolean} optimized Pass `true` if given `data` is already optimized\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseDB(data, optimized) {\r\n\t\tif (typeof data == 'string') {\r\n\t\t\tdata = JSON.parse(data);\r\n\t\t}\r\n\r\n\t\tif (!optimized) {\r\n\t\t\tdata = optimize(data);\r\n\t\t}\r\n\r\n\t\tvendorsDB = data.vendors;\r\n\t\tcssDB = data.css;\r\n\t\terasDB = data.era;\r\n\t}\r\n\r\n\t/**\r\n\t * Extract required data only from CIU database\r\n\t * @param  {Object} data Raw Can I Use database\r\n\t * @return {Object}      Optimized database\r\n\t */\r\n\tfunction optimize(data) {\r\n\t\tif (typeof data == 'string') {\r\n\t\t\tdata = JSON.parse(data);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tvendors: parseVendors(data),\r\n\t\t\tcss: parseCSS(data),\r\n\t\t\tera: parseEra(data)\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Parses vendor data\r\n\t * @param  {Object} data\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseVendors(data) {\r\n\t\tvar out = {};\r\n\t\tObject.keys(data.agents).forEach(function(name) {\r\n\t\t\tvar agent = data.agents[name];\r\n\t\t\tout[name] = {\r\n\t\t\t\tprefix: agent.prefix,\r\n\t\t\t\tversions: agent.versions\r\n\t\t\t};\r\n\t\t});\r\n\t\treturn out;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses CSS data from Can I Use raw database\r\n\t * @param  {Object} data\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseCSS(data) {\r\n\t\tvar out = {};\r\n\t\tvar cssCategories = data.cats.CSS;\r\n\t\tObject.keys(data.data).forEach(function(name) {\r\n\t\t\tvar section = data.data[name];\r\n\t\t\tif (name in cssSections) {\r\n\t\t\t\tcssSections[name].forEach(function(kw) {\r\n\t\t\t\t\tout[kw] = section.stats;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses era data from Can I Use raw database\r\n\t * @param  {Object} data\r\n\t * @return {Array}\r\n\t */\r\n\tfunction parseEra(data) {\r\n\t\t// some runtimes (like Mozilla Rhino) does not preserves\r\n\t\t// key order so we have to sort values manually\r\n\t\treturn Object.keys(data.eras).sort(function(a, b) {\r\n\t\t\treturn parseInt(a.substr(1)) - parseInt(b.substr(1));\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returs list of supported vendors, depending on user preferences\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getVendorsList() {\r\n\t\tvar allVendors = Object.keys(vendorsDB);\r\n\t\tvar vendors = prefs.getArray('caniuse.vendors');\r\n\t\tif (!vendors || vendors[0] == 'all') {\r\n\t\t\treturn allVendors;\r\n\t\t}\r\n\r\n\t\treturn intersection(allVendors, vendors);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns size of version slice as defined by era identifier\r\n\t * @return {Number}\r\n\t */\r\n\tfunction getVersionSlice() {\r\n\t\tvar era = prefs.get('caniuse.era');\r\n\t\tvar ix = erasDB.indexOf(era);\r\n\t\tif (!~ix) {\r\n\t\t\tix = erasDB.indexOf('e-2');\r\n\t\t}\r\n\r\n\t\treturn ix;\r\n\t}\r\n\r\n\t// try to load caniuse database\r\n\t// hide it from Require.JS parser\r\n\tvar db = null;\r\n\t(function(r) {\r\n\t\tif (typeof define === 'undefined' || !define.amd) {\r\n\t\t\ttry {\r\n\t\t\t\tdb = r('caniuse-db/data.json');\r\n\t\t\t} catch(e) {}\r\n\t\t}\r\n\t})(require);\r\n\r\n\tif (db) {\r\n\t\tparseDB(db);\r\n\t}\r\n\r\n\treturn {\r\n\t\tload: parseDB,\r\n\t\toptimize: optimize,\r\n\r\n\t\t/**\r\n\t\t * Resolves prefixes for given property\r\n\t\t * @param {String} property A property to resolve. It can start with `@` symbol\r\n\t\t * (CSS section, like `@keyframes`) or `:` (CSS value, like `flex`)\r\n\t\t * @return {Array} Array of resolved prefixes or <code>null</code>\r\n\t\t * if prefixes can't be resolved. Empty array means property has no vendor\r\n\t\t * prefixes\r\n\t\t */\r\n\t\tresolvePrefixes: function(property) {\r\n\t\t\tif (!prefs.get('caniuse.enabled') || !cssDB || !(property in cssDB)) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar prefixes = [];\r\n\t\t\tvar propStats = cssDB[property];\r\n\t\t\tvar versions = getVersionSlice();\r\n\r\n\t\t\tgetVendorsList().forEach(function(vendor) {\r\n\t\t\t\tvar vendorVesions = vendorsDB[vendor].versions.slice(versions);\r\n\t\t\t\tfor (var i = 0, v; i < vendorVesions.length; i++) {\r\n\t\t\t\t\tv = vendorVesions[i];\r\n\t\t\t\t\tif (!v) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (~propStats[vendor][v].indexOf('x')) {\r\n\t\t\t\t\t\tprefixes.push(vendorsDB[vendor].prefix);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn utils.unique(prefixes).sort(function(a, b) {\r\n\t\t\t\treturn b.length - a.length;\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./preferences\":\"assets\\\\preferences.js\"}],\"assets\\\\elements.js\":[function(require,module,exports){\r\n/**\r\n * Module that contains factories for element types used by Emmet\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar factories = {};\r\n\tvar reAttrs = /([@\\!]?)([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\3/g;\r\n\r\n\t// register resource references\r\n\tfunction commonFactory(value) {\r\n\t\treturn {data: value};\r\n\t}\r\n\r\n\tmodule = module || {};\r\n\tmodule.exports = {\r\n\t\t/**\r\n\t\t * Create new element factory\r\n\t\t * @param {String} name Element identifier\r\n\t\t * @param {Function} factory Function that produces element of specified \r\n\t\t * type. The object generated by this factory is automatically \r\n\t\t * augmented with <code>type</code> property pointing to element\r\n\t\t * <code>name</code>\r\n\t\t * @memberOf elements\r\n\t\t */\r\n\t\tadd: function(name, factory) {\r\n\t\t\tvar that = this;\r\n\t\t\tfactories[name] = function() {\r\n\t\t\t\tvar elem = factory.apply(that, arguments);\r\n\t\t\t\tif (elem)\r\n\t\t\t\t\telem.type = name;\r\n\t\t\t\t\r\n\t\t\t\treturn elem;\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns factory for specified name\r\n\t\t * @param {String} name\r\n\t\t * @returns {Function}\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\treturn factories[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates new element with specified type\r\n\t\t * @param {String} name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tcreate: function(name) {\r\n\t\t\tvar args = [].slice.call(arguments, 1);\r\n\t\t\tvar factory = this.get(name);\r\n\t\t\treturn factory ? factory.apply(this, args) : null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element is of specified type\r\n\t\t * @param {Object} elem\r\n\t\t * @param {String} type\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tis: function(elem, type) {\r\n\t\t\treturn this.type(elem) === type;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns type of element\r\n\t\t * @param  {Object} elem\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\ttype: function(elem) {\r\n\t\t\treturn elem && elem.type;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Element factory\r\n\t * @param {String} elementName Name of output element\r\n\t * @param {String} attrs Attributes definition. You may also pass\r\n\t * <code>Array</code> where each contains object with <code>name</code> \r\n\t * and <code>value</code> properties, or <code>Object</code>\r\n\t * @param {Boolean} isEmpty Is expanded element should be empty\r\n\t */\r\n\tmodule.exports.add('element', function(elementName, attrs, isEmpty) {\r\n\t\tvar ret = {\r\n\t\t\tname: elementName,\r\n\t\t\tis_empty: !!isEmpty\r\n\t\t};\r\n\r\n\t\tif (attrs) {\r\n\t\t\tret.attributes = [];\r\n\t\t\tif (Array.isArray(attrs)) {\r\n\t\t\t\tret.attributes = attrs;\r\n\t\t\t} else if (typeof attrs === 'string') {\r\n\t\t\t\tvar m;\r\n\t\t\t\twhile ((m = reAttrs.exec(attrs))) {\r\n\t\t\t\t\tret.attributes.push({\r\n\t\t\t\t\t\tname: m[2],\r\n\t\t\t\t\t\tvalue: m[4],\r\n\t\t\t\t\t\tisDefault: m[1] == '@',\r\n\t\t\t\t\t\tisImplied: m[1] == '!'\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tret.attributes = Object.keys(attrs).map(function(name) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tname: name, \r\n\t\t\t\t\t\tvalue: attrs[name]\r\n\t\t\t\t\t};\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t});\r\n\t\r\n\tmodule.exports.add('snippet', commonFactory);\r\n\tmodule.exports.add('reference', commonFactory);\r\n\tmodule.exports.add('empty', function() {\r\n\t\treturn {};\r\n\t});\r\n\t\r\n\treturn module.exports;\r\n});\r\n},{}],\"assets\\\\handlerList.js\":[function(require,module,exports){\r\n/**\r\n * Utility module that provides ordered storage of function handlers. \r\n * Many Emmet modules' functionality can be extended/overridden by custom\r\n * function. This modules provides unified storage of handler functions, their \r\n * management and execution\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\t\r\n\t/**\r\n\t * @type HandlerList\r\n\t * @constructor\r\n\t */\r\n\tfunction HandlerList() {\r\n\t\tthis._list = [];\r\n\t}\r\n\t\r\n\tHandlerList.prototype = {\r\n\t\t/**\r\n\t\t * Adds function handler\r\n\t\t * @param {Function} fn Handler\r\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\r\n\t\t * <b>order</b> : (<code>Number</code>) – order in handler list. Handlers\r\n\t\t * with higher order value will be executed earlier.\r\n\t\t */\r\n\t\tadd: function(fn, options) {\r\n\t\t\t// TODO hack for stable sort, remove after fixing `list()`\r\n\t\t\tvar order = this._list.length;\r\n\t\t\tif (options && 'order' in options) {\r\n\t\t\t\torder = options.order * 10000;\r\n\t\t\t}\r\n\t\t\tthis._list.push(utils.extend({}, options, {order: order, fn: fn}));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes handler from list\r\n\t\t * @param {Function} fn\r\n\t\t */\r\n\t\tremove: function(fn) {\r\n\t\t\tvar item = utils.find(this._list, function(item) {\r\n\t\t\t\treturn item.fn === fn;\r\n\t\t\t});\r\n\t\t\tif (item) {\r\n\t\t\t\tthis._list.splice(this._list.indexOf(item), 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns ordered list of handlers. By default, handlers \r\n\t\t * with the same <code>order</code> option returned in reverse order, \r\n\t\t * i.e. the latter function was added into the handlers list, the higher \r\n\t\t * it will be in the returned array \r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlist: function() {\r\n\t\t\t// TODO make stable sort\r\n\t\t\treturn this._list.sort(function(a, b) {\r\n\t\t\t\treturn b.order - a.order;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns ordered list of handler functions\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlistFn: function() {\r\n\t\t\treturn this.list().map(function(item) {\r\n\t\t\t\treturn item.fn;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Executes handler functions in their designated order. If function\r\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \r\n\t\t * handle passed <code>args</code>, the next function will be executed\r\n\t\t * and so on.\r\n\t\t * @param {Object} skipValue If function returns this value, execute \r\n\t\t * next handler.\r\n\t\t * @param {Array} args Arguments to pass to handler function\r\n\t\t * @returns {Boolean} Whether any of registered handlers performed\r\n\t\t * successfully  \r\n\t\t */\r\n\t\texec: function(skipValue, args) {\r\n\t\t\targs = args || [];\r\n\t\t\tvar result = null;\r\n\t\t\tutils.find(this.list(), function(h) {\r\n\t\t\t\tresult = h.fn.apply(h, args);\r\n\t\t\t\tif (result !== skipValue) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Factory method that produces <code>HandlerList</code> instance\r\n\t\t * @returns {HandlerList}\r\n\t\t * @memberOf handlerList\r\n\t\t */\r\n\t\tcreate: function() {\r\n\t\t\treturn new HandlerList();\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"assets\\\\htmlMatcher.js\":[function(require,module,exports){\r\n/**\r\n * HTML matcher: takes string and searches for HTML tag pairs for given position \r\n * \r\n * Unlike “classic” matchers, it parses content from the specified \r\n * position, not from the start, so it may work even outside HTML documents\r\n * (for example, inside strings of programming languages like JavaScript, Python \r\n * etc.)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('./range');\r\n\r\n\t// Regular Expressions for parsing tags and attributes\r\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\r\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\r\n\r\n\tfunction openTag(i, match) {\r\n\t\treturn {\r\n\t\t\tname: match[1],\r\n\t\t\tselfClose: !!match[3],\r\n\t\t\t/** @type Range */\r\n\t\t\trange: range(i, match[0]),\r\n\t\t\ttype: 'open'\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction closeTag(i, match) {\r\n\t\treturn {\r\n\t\t\tname: match[1],\r\n\t\t\t/** @type Range */\r\n\t\t\trange: range(i, match[0]),\r\n\t\t\ttype: 'close'\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction comment(i, match) {\r\n\t\treturn {\r\n\t\t\t/** @type Range */\r\n\t\t\trange: range(i, typeof match == 'number' ? match - i : match[0]),\r\n\t\t\ttype: 'comment'\r\n\t\t};\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates new tag matcher session\r\n\t * @param {String} text\r\n\t */\r\n\tfunction createMatcher(text) {\r\n\t\tvar memo = {}, m;\r\n\t\treturn {\r\n\t\t\t/**\r\n\t\t\t * Test if given position matches opening tag\r\n\t\t\t * @param {Number} i\r\n\t\t\t * @returns {Object} Matched tag object\r\n\t\t\t */\r\n\t\t\topen: function(i) {\r\n\t\t\t\tvar m = this.matches(i);\r\n\t\t\t\treturn m && m.type == 'open' ? m : null;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Test if given position matches closing tag\r\n\t\t\t * @param {Number} i\r\n\t\t\t * @returns {Object} Matched tag object\r\n\t\t\t */\r\n\t\t\tclose: function(i) {\r\n\t\t\t\tvar m = this.matches(i);\r\n\t\t\t\treturn m && m.type == 'close' ? m : null;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Matches either opening or closing tag for given position\r\n\t\t\t * @param i\r\n\t\t\t * @returns\r\n\t\t\t */\r\n\t\t\tmatches: function(i) {\r\n\t\t\t\tvar key = 'p' + i;\r\n\t\t\t\t\r\n\t\t\t\tif (!(key in memo)) {\r\n\t\t\t\t\tmemo[key] = false;\r\n\t\t\t\t\tif (text.charAt(i) == '<') {\r\n\t\t\t\t\t\tvar substr = text.slice(i);\r\n\t\t\t\t\t\tif ((m = substr.match(reOpenTag))) {\r\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\r\n\t\t\t\t\t\t} else if ((m = substr.match(reCloseTag))) {\r\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn memo[key];\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * Returns original text\r\n\t\t\t * @returns {String}\r\n\t\t\t */\r\n\t\t\ttext: function() {\r\n\t\t\t\treturn text;\r\n\t\t\t},\r\n\r\n\t\t\tclean: function() {\r\n\t\t\t\tmemo = text = m = null;\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction matches(text, pos, pattern) {\r\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Search for closing pair of opening tag\r\n\t * @param {Object} open Open tag instance\r\n\t * @param {Object} matcher Matcher instance\r\n\t */\r\n\tfunction findClosingPair(open, matcher) {\r\n\t\tvar stack = [], tag = null;\r\n\t\tvar text = matcher.text();\r\n\t\t\r\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\r\n\t\t\tif (matches(text, pos, '<!--')) {\r\n\t\t\t\t// skip to end of comment\r\n\t\t\t\tfor (var j = pos; j < len; j++) {\r\n\t\t\t\t\tif (matches(text, j, '-->')) {\r\n\t\t\t\t\t\tpos = j + 3;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ((tag = matcher.matches(pos))) {\r\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\r\n\t\t\t\t\tstack.push(tag.name);\r\n\t\t\t\t} else if (tag.type == 'close') {\r\n\t\t\t\t\tif (!stack.length) { // found valid pair?\r\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check if current closing tag matches previously opened one\r\n\t\t\t\t\tif (stack[stack.length - 1] == tag.name) {\r\n\t\t\t\t\t\tstack.pop();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar found = false;\r\n\t\t\t\t\t\twhile (stack.length && !found) {\r\n\t\t\t\t\t\t\tvar last = stack.pop();\r\n\t\t\t\t\t\t\tif (last == tag.name) {\r\n\t\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (!stack.length && !found) {\r\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpos = tag.range.end - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Main function: search for tag pair in <code>text</code> for given \r\n\t\t * position\r\n\t\t * @memberOf htmlMatcher\r\n\t\t * @param {String} text \r\n\t\t * @param {Number} pos\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tfind: function(text, pos) {\r\n\t\t\tvar matcher = createMatcher(text); \r\n\t\t\tvar open = null, close = null;\r\n\t\t\tvar j, jl;\r\n\t\t\t\r\n\t\t\tfor (var i = pos; i >= 0; i--) {\r\n\t\t\t\tif ((open = matcher.open(i))) {\r\n\t\t\t\t\t// found opening tag\r\n\t\t\t\t\tif (open.selfClose) {\r\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\r\n\t\t\t\t\t\t\t// inside self-closing tag, found match\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// outside self-closing tag, continue\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tclose = findClosingPair(open, matcher);\r\n\t\t\t\t\tif (close) {\r\n\t\t\t\t\t\t// found closing tag.\r\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\r\n\t\t\t\t\t\tif (r.contains(pos)) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (open.range.contains(pos)) {\r\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\topen = null;\r\n\t\t\t\t} else if (matches(text, i, '-->')) {\r\n\t\t\t\t\t// skip back to comment start\r\n\t\t\t\t\tfor (j = i - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\r\n\t\t\t\t\t\t\t// found another comment end, do nothing\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\r\n\t\t\t\t\t\t\ti = j;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (matches(text, i, '<!--')) {\r\n\t\t\t\t\t// we're inside comment, match it\r\n\t\t\t\t\tfor (j = i + 4, jl = text.length; j < jl; j++) {\r\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\r\n\t\t\t\t\t\t\tj += 3;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\topen = comment(i, j);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmatcher.clean();\r\n\r\n\t\t\tif (open) {\r\n\t\t\t\tvar outerRange = null;\r\n\t\t\t\tvar innerRange = null;\r\n\t\t\t\t\r\n\t\t\t\tif (close) {\r\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\r\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\r\n\t\t\t\t} else {\r\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (open.type == 'comment') {\r\n\t\t\t\t\t// adjust positions of inner range for comment\r\n\t\t\t\t\tvar _c = outerRange.substring(text);\r\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\r\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\topen: open,\r\n\t\t\t\t\tclose: close,\r\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\r\n\t\t\t\t\tinnerRange: innerRange,\r\n\t\t\t\t\tinnerContent: function() {\r\n\t\t\t\t\t\treturn this.innerRange.substring(text);\r\n\t\t\t\t\t},\r\n\t\t\t\t\touterRange: outerRange,\r\n\t\t\t\t\touterContent: function() {\r\n\t\t\t\t\t\treturn this.outerRange.substring(text);\r\n\t\t\t\t\t},\r\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\r\n\t\t\t\t\tcontent: function() {\r\n\t\t\t\t\t\treturn this.range.substring(text);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tsource: text\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * The same as <code>find()</code> method, but restricts matched result \r\n\t\t * to <code>tag</code> type\r\n\t\t * @param {String} text \r\n\t\t * @param {Number} pos\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\ttag: function(text, pos) {\r\n\t\t\tvar result = this.find(text, pos);\r\n\t\t\tif (result && result.type == 'tag') {\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"./range\":\"assets\\\\range.js\"}],\"assets\\\\logger.js\":[function(require,module,exports){\r\n/**\r\n * Simple logger for Emmet\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\treturn {\r\n\t\tlog: function() {\r\n\t\t\tif (typeof console != 'undefined' && console.log) {\r\n\t\t\t\tconsole.log.apply(console, arguments);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n})\r\n},{}],\"assets\\\\preferences.js\":[function(require,module,exports){\r\n/**\r\n * Common module's preferences storage. This module \r\n * provides general storage for all module preferences, their description and\r\n * default values.<br><br>\r\n * \r\n * This module can also be used to list all available properties to create \r\n * UI for updating properties\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\r\n\tvar preferences = {};\r\n\tvar defaults = {};\r\n\tvar _dbgDefaults = null;\r\n\tvar _dbgPreferences = null;\r\n\r\n\tfunction toBoolean(val) {\r\n\t\tif (typeof val === 'string') {\r\n\t\t\tval = val.toLowerCase();\r\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\r\n\t\t}\r\n\r\n\t\treturn !!val;\r\n\t}\r\n\t\r\n\tfunction isValueObj(obj) {\r\n\t\treturn typeof obj === 'object'\r\n\t\t\t&& !Array.isArray(obj) \r\n\t\t\t&& 'value' in obj \r\n\t\t\t&& Object.keys(obj).length < 3;\r\n\t}\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Creates new preference item with default value\r\n\t\t * @param {String} name Preference name. You can also pass object\r\n\t\t * with many options\r\n\t\t * @param {Object} value Preference default value\r\n\t\t * @param {String} description Item textual description\r\n\t\t * @memberOf preferences\r\n\t\t */\r\n\t\tdefine: function(name, value, description) {\r\n\t\t\tvar prefs = name;\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\tprefs = {};\r\n\t\t\t\tprefs[name] = {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tdescription: description\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tObject.keys(prefs).forEach(function(k) {\r\n\t\t\t\tvar v = prefs[k];\r\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Updates preference item value. Preference value should be defined\r\n\t\t * first with <code>define</code> method.\r\n\t\t * @param {String} name Preference name. You can also pass object\r\n\t\t * with many options\r\n\t\t * @param {Object} value Preference default value\r\n\t\t * @memberOf preferences\r\n\t\t */\r\n\t\tset: function(name, value) {\r\n\t\t\tvar prefs = name;\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\tprefs = {};\r\n\t\t\t\tprefs[name] = value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tObject.keys(prefs).forEach(function(k) {\r\n\t\t\t\tvar v = prefs[k];\r\n\t\t\t\tif (!(k in defaults)) {\r\n\t\t\t\t\tthrow new Error('Property \"' + k + '\" is not defined. You should define it first with `define` method of current module');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// do not set value if it equals to default value\r\n\t\t\t\tif (v !== defaults[k].value) {\r\n\t\t\t\t\t// make sure we have value of correct type\r\n\t\t\t\t\tswitch (typeof defaults[k].value) {\r\n\t\t\t\t\t\tcase 'boolean':\r\n\t\t\t\t\t\t\tv = toBoolean(v);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'number':\r\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: // convert to string\r\n\t\t\t\t\t\t\tif (v !== null) {\r\n\t\t\t\t\t\t\t\tv += '';\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpreferences[k] = v;\r\n\t\t\t\t} else if (k in preferences) {\r\n\t\t\t\t\tdelete preferences[k];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns preference value\r\n\t\t * @param {String} name\r\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \r\n\t\t * not defined\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\tif (name in preferences) {\r\n\t\t\t\treturn preferences[name];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (name in defaults) {\r\n\t\t\t\treturn defaults[name].value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn void 0;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns comma-separated preference value as array of values\r\n\t\t * @param {String} name\r\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \r\n\t\t * not defined, <code>null</code> if string cannot be converted to array\r\n\t\t */\r\n\t\tgetArray: function(name) {\r\n\t\t\tvar val = this.get(name);\r\n\t\t\tif (typeof val === 'undefined' || val === null || val === '')  {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tval = val.split(',').map(utils.trim);\r\n\t\t\tif (!val.length) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn val;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns comma and colon-separated preference value as dictionary\r\n\t\t * @param {String} name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetDict: function(name) {\r\n\t\t\tvar result = {};\r\n\t\t\tthis.getArray(name).forEach(function(val) {\r\n\t\t\t\tvar parts = val.split(':');\r\n\t\t\t\tresult[parts[0]] = parts[1];\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns description of preference item\r\n\t\t * @param {String} name Preference name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tdescription: function(name) {\r\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Completely removes specified preference(s)\r\n\t\t * @param {String} name Preference name (or array of names)\r\n\t\t */\r\n\t\tremove: function(name) {\r\n\t\t\tif (!Array.isArray(name)) {\r\n\t\t\t\tname = [name];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tname.forEach(function(key) {\r\n\t\t\t\tif (key in preferences) {\r\n\t\t\t\t\tdelete preferences[key];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (key in defaults) {\r\n\t\t\t\t\tdelete defaults[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns sorted list of all available properties\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlist: function() {\r\n\t\t\treturn Object.keys(defaults).sort().map(function(key) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: key,\r\n\t\t\t\t\tvalue: this.get(key),\r\n\t\t\t\t\ttype: typeof defaults[key].value,\r\n\t\t\t\t\tdescription: defaults[key].description\r\n\t\t\t\t};\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Loads user-defined preferences from JSON\r\n\t\t * @param {Object} json\r\n\t\t * @returns\r\n\t\t */\r\n\t\tload: function(json) {\r\n\t\t\tObject.keys(json).forEach(function(key) {\r\n\t\t\t\tthis.set(key, json[key]);\r\n\t\t\t}, this);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns hash of user-modified preferences\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\texportModified: function() {\r\n\t\t\treturn utils.extend({}, preferences);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Reset to defaults\r\n\t\t * @returns\r\n\t\t */\r\n\t\treset: function() {\r\n\t\t\tpreferences = {};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * For unit testing: use empty storage\r\n\t\t */\r\n\t\t_startTest: function() {\r\n\t\t\t_dbgDefaults = defaults;\r\n\t\t\t_dbgPreferences = preferences;\r\n\t\t\tdefaults = {};\r\n\t\t\tpreferences = {};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * For unit testing: restore original storage\r\n\t\t */\r\n\t\t_stopTest: function() {\r\n\t\t\tdefaults = _dbgDefaults;\r\n\t\t\tpreferences = _dbgPreferences;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"assets\\\\profile.js\":[function(require,module,exports){\r\n/**\r\n * Output profile module.\r\n * Profile defines how XHTML output data should look like\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar resources = require('./resources');\r\n\tvar prefs = require('./preferences');\r\n\r\n\tprefs.define('profile.allowCompactBoolean', true, \r\n\t\t'This option can be used to globally disable compact form of boolean ' + \r\n\t\t'attribues (attributes where name and value are equal). With compact' +\r\n\t\t'form enabled, HTML tags can be outputted as <code>&lt;div contenteditable&gt;</code> ' +\r\n\t\t'instead of <code>&lt;div contenteditable=\"contenteditable\"&gt;</code>');\r\n\r\n\tprefs.define('profile.booleanAttributes', '^contenteditable|seamless|async|autofocus|autoplay|checked|controls|defer|disabled|formnovalidate|hidden|ismap|loop|multiple|muted|novalidate|readonly|required|reversed|selected|typemustmatch$', \r\n\t\t'A regular expression for attributes that should be boolean by default.' + \r\n\t\t'If attribute name matches this expression, you don’t have to write dot ' +\r\n\t\t'after attribute name in Emmet abbreviation to mark it as boolean.');\r\n\r\n\tvar profiles = {};\r\n\t\r\n\tvar defaultProfile = {\r\n\t\ttag_case: 'asis',\r\n\t\tattr_case: 'asis',\r\n\t\tattr_quotes: 'double',\r\n\t\t\r\n\t\t// Each tag on new line\r\n\t\ttag_nl: 'decide',\r\n\t\t\r\n\t\t// With tag_nl === true, defines if leaf node (e.g. node with no children)\r\n\t\t// should have formatted line breaks\r\n\t\ttag_nl_leaf: false,\r\n\t\t\r\n\t\tplace_cursor: true,\r\n\t\t\r\n\t\t// Indent tags\r\n\t\tindent: true,\r\n\t\t\r\n\t\t// How many inline elements should be to force line break \r\n\t\t// (set to 0 to disable)\r\n\t\tinline_break: 3,\r\n\r\n\t\t// Produce compact notation of boolean attribues:\r\n\t\t// attributes where name and value are equal.\r\n\t\t// With this option enabled, HTML filter will\r\n\t\t// produce <div contenteditable> instead of <div contenteditable=\"contenteditable\">\r\n\t\tcompact_bool: false,\r\n\t\t\r\n\t\t// Use self-closing style for writing empty elements, e.g. <br /> or <br>\r\n\t\tself_closing_tag: 'xhtml',\r\n\t\t\r\n\t\t// Profile-level output filters, re-defines syntax filters \r\n\t\tfilters: '',\r\n\t\t\r\n\t\t// Additional filters applied to abbreviation.\r\n\t\t// Unlike \"filters\", this preference doesn't override default filters\r\n\t\t// but add the instead every time given profile is chosen\r\n\t\textraFilters: ''\r\n\t};\r\n\t\r\n\t/**\r\n\t * @constructor\r\n\t * @type OutputProfile\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction OutputProfile(options) {\r\n\t\tutils.extend(this, defaultProfile, options);\r\n\t}\r\n\t\r\n\tOutputProfile.prototype = {\r\n\t\t/**\r\n\t\t * Transforms tag name case depending on current profile settings\r\n\t\t * @param {String} name String to transform\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\ttagName: function(name) {\r\n\t\t\treturn stringCase(name, this.tag_case);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Transforms attribute name case depending on current profile settings \r\n\t\t * @param {String} name String to transform\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tattributeName: function(name) {\r\n\t\t\treturn stringCase(name, this.attr_case);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns quote character for current profile\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tattributeQuote: function() {\r\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns self-closing tag symbol for current profile\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tselfClosing: function() {\r\n\t\t\tif (this.self_closing_tag == 'xhtml')\r\n\t\t\t\treturn ' /';\r\n\t\t\t\r\n\t\t\tif (this.self_closing_tag === true)\r\n\t\t\t\treturn '/';\r\n\t\t\t\r\n\t\t\treturn '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns cursor token based on current profile settings\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tcursor: function() {\r\n\t\t\treturn this.place_cursor ? utils.getCaretPlaceholder() : '';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if attribute with given name is boolean,\r\n\t\t * e.g. written as `contenteditable` instead of \r\n\t\t * `contenteditable=\"contenteditable\"`\r\n\t\t * @param  {String}  name Attribute name\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisBoolean: function(name, value) {\r\n\t\t\tif (name == value) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tvar boolAttrs = prefs.get('profile.booleanAttributes');\r\n\t\t\tif (!value && boolAttrs) {\r\n\t\t\t\tboolAttrs = new RegExp(boolAttrs, 'i');\r\n\t\t\t\treturn boolAttrs.test(name);\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if compact boolean attribute record is \r\n\t\t * allowed for current profile\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tallowCompactBoolean: function() {\r\n\t\t\treturn this.compact_bool && prefs.get('profile.allowCompactBoolean');\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Helper function that converts string case depending on \r\n\t * <code>caseValue</code> \r\n\t * @param {String} str String to transform\r\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \r\n\t * <i>upper</i> and <i>leave</i>\r\n\t * @returns {String}\r\n\t */\r\n\tfunction stringCase(str, caseValue) {\r\n\t\tswitch (String(caseValue || '').toLowerCase()) {\r\n\t\t\tcase 'lower':\r\n\t\t\t\treturn str.toLowerCase();\r\n\t\t\tcase 'upper':\r\n\t\t\t\treturn str.toUpperCase();\r\n\t\t}\r\n\t\t\r\n\t\treturn str;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates new output profile\r\n\t * @param {String} name Profile name\r\n\t * @param {Object} options Profile options\r\n\t */\r\n\tfunction createProfile(name, options) {\r\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\r\n\t}\r\n\t\r\n\tfunction createDefaultProfiles() {\r\n\t\tcreateProfile('xhtml');\r\n\t\tcreateProfile('html', {self_closing_tag: false, compact_bool: true});\r\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\r\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\r\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\r\n\t\tcreateProfile('css', {tag_nl: true});\r\n\t\tcreateProfile('css_line', {tag_nl: false});\r\n\t}\r\n\t\r\n\tcreateDefaultProfiles();\r\n\t\r\n\treturn  {\r\n\t\t/**\r\n\t\t * Creates new output profile and adds it into internal dictionary\r\n\t\t * @param {String} name Profile name\r\n\t\t * @param {Object} options Profile options\r\n\t\t * @memberOf emmet.profile\r\n\t\t * @returns {Object} New profile\r\n\t\t */\r\n\t\tcreate: function(name, options) {\r\n\t\t\tif (arguments.length == 2)\r\n\t\t\t\treturn createProfile(name, options);\r\n\t\t\telse\r\n\t\t\t\t// create profile object only\r\n\t\t\t\treturn new OutputProfile(utils.defaults(name || {}, defaultProfile));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns profile by its name. If profile wasn't found, returns\r\n\t\t * 'plain' profile\r\n\t\t * @param {String} name Profile name. Might be profile itself\r\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\r\n\t\t * profile is searched in resources first, then in predefined profiles\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tget: function(name, syntax) {\r\n\t\t\tif (!name && syntax) {\r\n\t\t\t\t// search in user resources first\r\n\t\t\t\tvar profile = resources.findItem(syntax, 'profile');\r\n\t\t\t\tif (profile) {\r\n\t\t\t\t\tname = profile;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!name) {\r\n\t\t\t\treturn profiles.plain;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (name instanceof OutputProfile) {\r\n\t\t\t\treturn name;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof name === 'string' && name.toLowerCase() in profiles) {\r\n\t\t\t\treturn profiles[name.toLowerCase()];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this.create(name);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Deletes profile with specified name\r\n\t\t * @param {String} name Profile name\r\n\t\t */\r\n\t\tremove: function(name) {\r\n\t\t\tname = (name || '').toLowerCase();\r\n\t\t\tif (name in profiles)\r\n\t\t\t\tdelete profiles[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Resets all user-defined profiles\r\n\t\t */\r\n\t\treset: function() {\r\n\t\t\tprofiles = {};\r\n\t\t\tcreateDefaultProfiles();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Helper function that converts string case depending on \r\n\t\t * <code>caseValue</code> \r\n\t\t * @param {String} str String to transform\r\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \r\n\t\t * <i>upper</i> and <i>leave</i>\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tstringCase: stringCase\r\n\t};\r\n});\r\n\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./preferences\":\"assets\\\\preferences.js\",\"./resources\":\"assets\\\\resources.js\"}],\"assets\\\\range.js\":[function(require,module,exports){\r\n/**\r\n * Helper module to work with ranges\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tfunction cmp(a, b, op) {\r\n\t\tswitch (op) {\r\n\t\t\tcase 'eq':\r\n\t\t\tcase '==':\r\n\t\t\t\treturn a === b;\r\n\t\t\tcase 'lt':\r\n\t\t\tcase '<':\r\n\t\t\t\treturn a < b;\r\n\t\t\tcase 'lte':\r\n\t\t\tcase '<=':\r\n\t\t\t\treturn a <= b;\r\n\t\t\tcase 'gt':\r\n\t\t\tcase '>':\r\n\t\t\t\treturn a > b;\r\n\t\t\tcase 'gte':\r\n\t\t\tcase '>=':\r\n\t\t\t\treturn a >= b;\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * @type Range\r\n\t * @constructor\r\n\t * @param {Object} start\r\n\t * @param {Number} len\r\n\t */\r\n\tfunction Range(start, len) {\r\n\t\tif (typeof start === 'object' && 'start' in start) {\r\n\t\t\t// create range from object stub\r\n\t\t\tthis.start = Math.min(start.start, start.end);\r\n\t\t\tthis.end = Math.max(start.start, start.end);\r\n\t\t} else if (Array.isArray(start)) {\r\n\t\t\tthis.start = start[0];\r\n\t\t\tthis.end = start[1];\r\n\t\t} else {\r\n\t\t\tlen = typeof len === 'string' ? len.length : +len;\r\n\t\t\tthis.start = start;\r\n\t\t\tthis.end = start + len;\r\n\t\t}\r\n\t}\r\n\t\r\n\tRange.prototype = {\r\n\t\tlength: function() {\r\n\t\t\treturn Math.abs(this.end - this.start);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns <code>true</code> if passed range is equals to current one\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tequal: function(range) {\r\n\t\t\treturn this.cmp(range, 'eq', 'eq');\r\n//\t\t\treturn this.start === range.start && this.end === range.end;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Shifts indexes position with passed <code>delta</code>\r\n\t\t * @param {Number} delta\r\n\t\t * @returns {Range} range itself\r\n\t\t */\r\n\t\tshift: function(delta) {\r\n\t\t\tthis.start += delta;\r\n\t\t\tthis.end += delta;\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if two ranges are overlapped\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\toverlap: function(range) {\r\n\t\t\treturn range.start <= this.end && range.end >= this.start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds intersection of two ranges\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\r\n\t\t */\r\n\t\tintersection: function(range) {\r\n\t\t\tif (this.overlap(range)) {\r\n\t\t\t\tvar start = Math.max(range.start, this.start);\r\n\t\t\t\tvar end = Math.min(range.end, this.end);\r\n\t\t\t\treturn new Range(start, end - start);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the union of the thow ranges.\r\n\t\t * @param {Range} range\r\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\r\n\t\t */\r\n\t\tunion: function(range) {\r\n\t\t\tif (this.overlap(range)) {\r\n\t\t\t\tvar start = Math.min(range.start, this.start);\r\n\t\t\t\tvar end = Math.max(range.end, this.end);\r\n\t\t\t\treturn new Range(start, end - start);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns a Boolean value that indicates whether a specified position \r\n\t\t * is in a given range.\r\n\t\t * @param {Number} loc\r\n\t\t */\r\n\t\tinside: function(loc) {\r\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\r\n//\t\t\treturn this.start <= loc && this.end > loc;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns a Boolean value that indicates whether a specified position \r\n\t\t * is in a given range, but not equals bounds.\r\n\t\t * @param {Number} loc\r\n\t\t */\r\n\t\tcontains: function(loc) {\r\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current range completely includes specified one\r\n\t\t * @param {Range} r\r\n\t\t * @returns {Boolean} \r\n\t\t */\r\n\t\tinclude: function(r) {\r\n\t\t\treturn this.cmp(r, 'lte', 'gte');\r\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Low-level comparision method\r\n\t\t * @param {Number} loc\r\n\t\t * @param {String} left Left comparison operator\r\n\t\t * @param {String} right Right comaprison operator\r\n\t\t */\r\n\t\tcmp: function(loc, left, right) {\r\n\t\t\tvar a, b;\r\n\t\t\tif (loc instanceof Range) {\r\n\t\t\t\ta = loc.start;\r\n\t\t\t\tb = loc.end;\r\n\t\t\t} else {\r\n\t\t\t\ta = b = loc;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns substring of specified <code>str</code> for current range\r\n\t\t * @param {String} str\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tsubstring: function(str) {\r\n\t\t\treturn this.length() > 0 \r\n\t\t\t\t? str.substring(this.start, this.end) \r\n\t\t\t\t: '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates copy of current range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tclone: function() {\r\n\t\t\treturn new Range(this.start, this.length());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\ttoArray: function() {\r\n\t\t\treturn [this.start, this.end];\r\n\t\t},\r\n\t\t\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\r\n\t\tvalueOf: function() {\r\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * Creates new range object instance\r\n\t * @param {Object} start Range start or array with 'start' and 'end'\r\n\t * as two first indexes or object with 'start' and 'end' properties\r\n\t * @param {Number} len Range length or string to produce range from\r\n\t * @returns {Range}\r\n\t */\r\n\tmodule.exports = function(start, len) {\r\n\t\tif (typeof start == 'undefined' || start === null)\r\n\t\t\treturn null;\r\n\t\t\t\r\n\t\tif (start instanceof Range)\r\n\t\t\treturn start;\r\n\t\t\r\n\t\tif (typeof start == 'object' && 'start' in start && 'end' in start) {\r\n\t\t\tlen = start.end - start.start;\r\n\t\t\tstart = start.start;\r\n\t\t}\r\n\t\t\t\r\n\t\treturn new Range(start, len);\r\n\t};\r\n\r\n\tmodule.exports.create = module.exports;\r\n\r\n\tmodule.exports.isRange = function(val) {\r\n\t\treturn val instanceof Range;\r\n\t};\r\n\r\n\t/**\r\n\t * <code>Range</code> object factory, the same as <code>this.create()</code>\r\n\t * but last argument represents end of range, not length\r\n\t * @returns {Range}\r\n\t */\r\n\tmodule.exports.create2 = function(start, end) {\r\n\t\tif (typeof start === 'number' && typeof end === 'number') {\r\n\t\t\tend -= start;\r\n\t\t}\r\n\t\t\r\n\t\treturn this.create(start, end);\r\n\t};\r\n\r\n\t/**\r\n\t * Helper function that sorts ranges in order as they\r\n\t * appear in text\r\n\t * @param  {Array} ranges\r\n\t * @return {Array}\r\n\t */\r\n\tmodule.exports.sort = function(ranges, reverse) {\r\n\t\tranges = ranges.sort(function(a, b) {\r\n\t\t\tif (a.start === b.start) {\r\n\t\t\t\treturn b.end - a.end;\r\n\t\t\t}\r\n\r\n\t\t\treturn a.start - b.start;\r\n\t\t});\r\n\r\n\t\treverse && ranges.reverse();\r\n\t\treturn ranges;\r\n\t};\r\n\r\n\treturn module.exports;\r\n});\r\n},{}],\"assets\\\\resources.js\":[function(require,module,exports){\r\n/**\r\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\r\n * Contains convenient method to get access for snippets with respect of\r\n * inheritance. Also provides ability to store data in different vocabularies\r\n * ('system' and 'user') for fast and safe resource update\r\n * @author Sergey Chikuyonok (serge.che@gmail.com)\r\n * @link http://chikuyonok.ru\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar handlerList = require('./handlerList');\r\n\tvar utils = require('../utils/common');\r\n\tvar elements = require('./elements');\r\n\tvar logger = require('../assets/logger');\r\n\tvar stringScore = require('../vendor/stringScore');\r\n\tvar cssResolver = require('../resolver/css');\r\n\r\n\tvar VOC_SYSTEM = 'system';\r\n\tvar VOC_USER = 'user';\r\n\r\n\tvar cache = {};\r\n\r\n\t/** Regular expression for XML tag matching */\r\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[@\\!]?[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\r\n\r\n\tvar systemSettings = {};\r\n\tvar userSettings = {};\r\n\r\n\t/** @type HandlerList List of registered abbreviation resolvers */\r\n\tvar resolvers = handlerList.create();\r\n\r\n\tfunction each(obj, fn) {\r\n\t\tif (!obj) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tObject.keys(obj).forEach(function(key) {\r\n\t\t\tfn(obj[key], key);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes caret plceholder in passed text: replaces | character with\r\n\t * default caret placeholder\r\n\t * @param {String} text\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeCaretPlaceholder(text) {\r\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\r\n\t}\r\n\r\n\tfunction parseItem(name, value, type) {\r\n\t\tvalue = normalizeCaretPlaceholder(value);\r\n\r\n\t\tif (type == 'snippets') {\r\n\t\t\treturn elements.create('snippet', value);\r\n\t\t}\r\n\r\n\t\tif (type == 'abbreviations') {\r\n\t\t\treturn parseAbbreviation(name, value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Parses single abbreviation\r\n\t * @param {String} key Abbreviation name\r\n\t * @param {String} value Abbreviation value\r\n\t * @return {Object}\r\n\t */\r\n\tfunction parseAbbreviation(key, value) {\r\n\t\tkey = utils.trim(key);\r\n\t\tvar m;\r\n\t\tif ((m = reTag.exec(value))) {\r\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\r\n\t\t} else {\r\n\t\t\t// assume it's reference to another abbreviation\r\n\t\t\treturn elements.create('reference', value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Normalizes snippet key name for better fuzzy search\r\n\t * @param {String} str\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeName(str) {\r\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\r\n\t}\r\n\r\n\tfunction expandSnippetsDefinition(snippets) {\r\n\t\tvar out = {};\r\n\t\teach(snippets, function(val, key) {\r\n\t\t\tvar items = key.split('|');\r\n\t\t\t// do not use iterators for better performance\r\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\r\n\t\t\t\tout[items[i]] = val;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tutils.extend(exports, {\r\n\t\t/**\r\n\t\t * Sets new unparsed data for specified settings vocabulary\r\n\t\t * @param {Object} data\r\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\r\n\t\t * @memberOf resources\r\n\t\t */\r\n\t\tsetVocabulary: function(data, type) {\r\n\t\t\tcache = {};\r\n\r\n\t\t\t// sections like \"snippets\" and \"abbreviations\" could have\r\n\t\t\t// definitions like `\"f|fs\": \"fieldset\"` which is the same as distinct\r\n\t\t\t// \"f\" and \"fs\" keys both equals to \"fieldset\".\r\n\t\t\t// We should parse these definitions first\r\n\t\t\tvar voc = {};\r\n\t\t\teach(data, function(section, syntax) {\r\n\t\t\t\tvar _section = {};\r\n\t\t\t\teach(section, function(subsection, name) {\r\n\t\t\t\t\tif (name == 'abbreviations' || name == 'snippets') {\r\n\t\t\t\t\t\tsubsection = expandSnippetsDefinition(subsection);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_section[name] = subsection;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tvoc[syntax] = _section;\r\n\t\t\t});\r\n\r\n\r\n\t\t\tif (type == VOC_SYSTEM) {\r\n\t\t\t\tsystemSettings = voc;\r\n\t\t\t} else {\r\n\t\t\t\tuserSettings = voc;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns resource vocabulary by its name\r\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\r\n\t\t * @return {Object}\r\n\t\t */\r\n\t\tgetVocabulary: function(name) {\r\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed\r\n\t\t * abbreviation\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @param {String} syntax\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetMatchedResource: function(node, syntax) {\r\n\t\t\treturn resolvers.exec(null, utils.toArray(arguments))\r\n\t\t\t\t|| this.findSnippet(syntax, node.name());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns variable value\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetVariable: function(name) {\r\n\t\t\treturn (this.getSection('variables') || {})[name];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Store runtime variable in user storage\r\n\t\t * @param {String} name Variable name\r\n\t\t * @param {String} value Variable value\r\n\t\t */\r\n\t\tsetVariable: function(name, value){\r\n\t\t\tvar voc = this.getVocabulary('user') || {};\r\n\t\t\tif (!('variables' in voc))\r\n\t\t\t\tvoc.variables = {};\r\n\r\n\t\t\tvoc.variables[name] = value;\r\n\t\t\tthis.setVocabulary(voc, 'user');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if there are resources for specified syntax\r\n\t\t * @param {String} syntax\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\thasSyntax: function(syntax) {\r\n\t\t\treturn syntax in this.getVocabulary(VOC_USER)\r\n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Registers new abbreviation resolver.\r\n\t\t * @param {Function} fn Abbreviation resolver which will receive\r\n\t\t * abbreviation as first argument and should return parsed abbreviation\r\n\t\t * object if abbreviation has handled successfully, <code>null</code>\r\n\t\t * otherwise\r\n\t\t * @param {Object} options Options list as described in\r\n\t\t * {@link HandlerList#add()} method\r\n\t\t */\r\n\t\taddResolver: function(fn, options) {\r\n\t\t\tresolvers.add(fn, options);\r\n\t\t},\r\n\r\n\t\tremoveResolver: function(fn) {\r\n\t\t\tresolvers.remove(fn);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns actual section data, merged from both\r\n\t\t * system and user data\r\n\t\t * @param {String} name Section name (syntax)\r\n\t\t * @param {String} ...args Subsections\r\n\t\t * @returns\r\n\t\t */\r\n\t\tgetSection: function(name) {\r\n\t\t\tif (!name)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tif (!(name in cache)) {\r\n\t\t\t\tcache[name] = utils.deepMerge({}, systemSettings[name], userSettings[name]);\r\n\t\t\t}\r\n\r\n\t\t\tvar data = cache[name], subsections = utils.toArray(arguments, 1), key;\r\n\t\t\twhile (data && (key = subsections.shift())) {\r\n\t\t\t\tif (key in data) {\r\n\t\t\t\t\tdata = data[key];\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\r\n\t\t * with respect of `extends` attribute\r\n\t\t * @param {String} topSection Top section name (syntax)\r\n\t\t * @param {String} subsection Inner section name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tfindItem: function(topSection, subsection) {\r\n\t\t\tvar data = this.getSection(topSection);\r\n\t\t\twhile (data) {\r\n\t\t\t\tif (subsection in data)\r\n\t\t\t\t\treturn data[subsection];\r\n\r\n\t\t\t\tdata = this.getSection(data['extends']);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Recursively searches for a snippet definition inside syntax section.\r\n\t\t * Definition is searched inside `snippets` and `abbreviations`\r\n\t\t * subsections\r\n\t\t * @param {String} syntax Top-level section name (syntax)\r\n\t\t * @param {String} name Snippet name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tfindSnippet: function(syntax, name, memo) {\r\n\t\t\tif (!syntax || !name)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\tmemo = memo || [];\r\n\r\n\t\t\tvar names = [name];\r\n\t\t\t// create automatic aliases to properties with colons,\r\n\t\t\t// e.g. pos-a == pos:a\r\n\t\t\tif (~name.indexOf('-')) {\r\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\r\n\t\t\t}\r\n\r\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\r\n\t\t\t['snippets', 'abbreviations'].some(function(sectionName) {\r\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\r\n\t\t\t\tif (data) {\r\n\t\t\t\t\treturn names.some(function(n) {\r\n\t\t\t\t\t\tif (data[n]) {\r\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\r\n\t\t\tmemo.push(syntax);\r\n\t\t\tif (!matchedItem && data['extends'] && !~memo.indexOf(data['extends'])) {\r\n\t\t\t\t// try to find item in parent syntax section\r\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\r\n\t\t\t}\r\n\r\n\t\t\treturn matchedItem;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Performs fuzzy search of snippet definition\r\n\t\t * @param {String} syntax Top-level section name (syntax)\r\n\t\t * @param {String} name Snippet name\r\n\t\t * @returns\r\n\t\t */\r\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\r\n\t\t\tvar result = this.fuzzyFindMatches(syntax, name, minScore)[0];\r\n\t\t\tif (result) {\r\n\t\t\t\treturn result.value.parsedValue;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfuzzyFindMatches: function(syntax, name, minScore) {\r\n\t\t\tminScore = minScore || 0.3;\r\n\t\t\tname = normalizeName(name);\r\n\t\t\tvar snippets = this.getAllSnippets(syntax);\r\n\r\n\t\t\treturn Object.keys(snippets)\r\n\t\t\t\t.map(function(key) {\r\n\t\t\t\t\tvar value = snippets[key];\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tkey: key,\r\n\t\t\t\t\t\tscore: stringScore.score(value.nk, name, 0.1),\r\n\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t};\r\n\t\t\t\t})\r\n\t\t\t\t.filter(function(item) {\r\n\t\t\t\t\treturn item.score >= minScore;\r\n\t\t\t\t})\r\n\t\t\t\t.sort(function(a, b) {\r\n\t\t\t\t\treturn a.score - b.score;\r\n\t\t\t\t})\r\n\t\t\t\t.reverse();\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns plain dictionary of all available abbreviations and snippets\r\n\t\t * for specified syntax with respect of inheritance\r\n\t\t * @param {String} syntax\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetAllSnippets: function(syntax) {\r\n\t\t\tvar cacheKey = 'all-' + syntax;\r\n\t\t\tif (!cache[cacheKey]) {\r\n\t\t\t\tvar stack = [], sectionKey = syntax;\r\n\t\t\t\tvar memo = [];\r\n\r\n\t\t\t\tdo {\r\n\t\t\t\t\tvar section = this.getSection(sectionKey);\r\n\t\t\t\t\tif (!section)\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t['snippets', 'abbreviations'].forEach(function(sectionName) {\r\n\t\t\t\t\t\tvar stackItem = {};\r\n\t\t\t\t\t\teach(section[sectionName] || null, function(v, k) {\r\n\t\t\t\t\t\t\tstackItem[k] = {\r\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\r\n\t\t\t\t\t\t\t\tvalue: v,\r\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\r\n\t\t\t\t\t\t\t\ttype: sectionName\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tstack.push(stackItem);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tmemo.push(sectionKey);\r\n\t\t\t\t\tsectionKey = section['extends'];\r\n\t\t\t\t} while (sectionKey && !~memo.indexOf(sectionKey));\r\n\r\n\r\n\t\t\t\tcache[cacheKey] = utils.extend.apply(utils, stack.reverse());\r\n\t\t\t}\r\n\r\n\t\t\treturn cache[cacheKey];\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns newline character\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetNewline: function() {\r\n\t\t\tvar nl = this.getVariable('newline');\r\n\t\t\treturn typeof nl === 'string' ? nl : '\\n';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets new newline character that will be used in output\r\n\t\t * @param {String} str\r\n\t\t */\r\n\t\tsetNewline: function(str) {\r\n\t\t\tthis.setVariable('newline', str);\r\n\t\t\tthis.setVariable('nl', str);\r\n\t\t}\r\n\t});\r\n\r\n\t// XXX add default resolvers\r\n\texports.addResolver(cssResolver.resolve.bind(cssResolver));\r\n\r\n\t// try to load snippets\r\n\t// hide it from Require.JS parser\r\n\t(function(r) {\r\n\t\tif (typeof define === 'undefined' || !define.amd) {\r\n\t\t\ttry {\r\n\t\t\t\texports.setVocabulary(r('../snippets.json'), VOC_SYSTEM);\r\n\t\t\t} catch (e) {}\r\n\t\t}\r\n\t})(require);\r\n\r\n\r\n\treturn exports;\r\n});\r\n\r\n},{\"../assets/logger\":\"assets\\\\logger.js\",\"../resolver/css\":\"resolver\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../vendor/stringScore\":\"vendor\\\\stringScore.js\",\"./elements\":\"assets\\\\elements.js\",\"./handlerList\":\"assets\\\\handlerList.js\"}],\"assets\\\\stringStream.js\":[function(require,module,exports){\r\n/**\r\n * A trimmed version of CodeMirror's StringStream module for string parsing\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * @type StringStream\r\n\t * @constructor\r\n\t * @param {String} string Assuming that bound string should be\r\n\t * immutable\r\n\t */\r\n\tfunction StringStream(string) {\r\n\t\tthis.pos = this.start = 0;\r\n\t\tthis.string = string;\r\n\t\tthis._length = string.length;\r\n\t}\r\n\t\r\n\tStringStream.prototype = {\r\n\t\t/**\r\n\t\t * Returns true only if the stream is at the end of the line.\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\teol: function() {\r\n\t\t\treturn this.pos >= this._length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns true only if the stream is at the start of the line\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tsol: function() {\r\n\t\t\treturn this.pos === 0;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the next character in the stream without advancing it. \r\n\t\t * Will return <code>undefined</code> at the end of the line.\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tpeek: function() {\r\n\t\t\treturn this.string.charAt(this.pos);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns the next character in the stream and advances it.\r\n\t\t * Also returns <code>undefined</code> when no more characters are available.\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tnext: function() {\r\n\t\t\tif (this.pos < this._length)\r\n\t\t\t\treturn this.string.charAt(this.pos++);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * match can be a character, a regular expression, or a function that\r\n\t\t * takes a character and returns a boolean. If the next character in the\r\n\t\t * stream 'matches' the given argument, it is consumed and returned.\r\n\t\t * Otherwise, undefined is returned.\r\n\t\t * @param {Object} match\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\teat: function(match) {\r\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\r\n\t\t\tif (typeof match == \"string\")\r\n\t\t\t\tok = ch == match;\r\n\t\t\telse\r\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\r\n\t\t\t\r\n\t\t\tif (ok) {\r\n\t\t\t\t++this.pos;\r\n\t\t\t\treturn ch;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\r\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\r\n\t\t * @param {Object} match\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\teatWhile: function(match) {\r\n\t\t\tvar start = this.pos;\r\n\t\t\twhile (this.eat(match)) {}\r\n\t\t\treturn this.pos > start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\teatSpace: function() {\r\n\t\t\tvar start = this.pos;\r\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\r\n\t\t\t\t++this.pos;\r\n\t\t\treturn this.pos > start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Moves the position to the end of the line.\r\n\t\t */\r\n\t\tskipToEnd: function() {\r\n\t\t\tthis.pos = this._length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Skips to the next occurrence of the given character, if found on the\r\n\t\t * current line (doesn't advance the stream if the character does not\r\n\t\t * occur on the line). Returns true if the character was found.\r\n\t\t * @param {String} ch\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tskipTo: function(ch) {\r\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\r\n\t\t\tif (found > -1) {\r\n\t\t\t\tthis.pos = found;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\r\n\t\t * character, considering possible pair nesting. This function is used\r\n\t\t * to consume pair of characters, like opening and closing braces\r\n\t\t * @param {String} open\r\n\t\t * @param {String} close\r\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\r\n\t\t * consumed\r\n\t\t */\r\n\t\tskipToPair: function(open, close, skipString) {\r\n\t\t\tvar braceCount = 0, ch;\r\n\t\t\tvar pos = this.pos, len = this._length;\r\n\t\t\twhile (pos < len) {\r\n\t\t\t\tch = this.string.charAt(pos++);\r\n\t\t\t\tif (ch == open) {\r\n\t\t\t\t\tbraceCount++;\r\n\t\t\t\t} else if (ch == close) {\r\n\t\t\t\t\tbraceCount--;\r\n\t\t\t\t\tif (braceCount < 1) {\r\n\t\t\t\t\t\tthis.pos = pos;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (skipString && (ch == '\"' || ch == \"'\")) {\r\n\t\t\t\t\tthis.skipString(ch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A helper function which, in case of either single or\r\n\t\t * double quote was found in current position, skips entire\r\n\t\t * string (quoted value)\r\n\t\t * @return {Boolean} Wether quoted string was skipped\r\n\t\t */\r\n\t\tskipQuoted: function(noBackup) {\r\n\t\t\tvar ch = this.string.charAt(noBackup ? this.pos : this.pos - 1);\r\n\t\t\tif (ch === '\"' || ch === \"'\") {\r\n\t\t\t\tif (noBackup) {\r\n\t\t\t\t\tthis.pos++;\r\n\t\t\t\t}\r\n\t\t\t\treturn this.skipString(ch);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A custom function to skip string literal, e.g. a \"double-quoted\"\r\n\t\t * or 'single-quoted' value\r\n\t\t * @param  {String} quote An opening quote\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tskipString: function(quote) {\r\n\t\t\tvar pos = this.pos, len = this._length, ch;\r\n\t\t\twhile (pos < len) {\r\n\t\t\t\tch = this.string.charAt(pos++);\r\n\t\t\t\tif (ch == '\\\\') {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (ch == quote) {\r\n\t\t\t\t\tthis.pos = pos;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Backs up the stream n characters. Backing it up further than the\r\n\t\t * start of the current token will cause things to break, so be careful.\r\n\t\t * @param {Number} n\r\n\t\t */\r\n\t\tbackUp : function(n) {\r\n\t\t\tthis.pos -= n;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Act like a multi-character <code>eat</code>—if <code>consume</code> is true or\r\n\t\t * not given—or a look-ahead that doesn't update the stream position—if\r\n\t\t * it is false. <code>pattern</code> can be either a string or a\r\n\t\t * regular expression starting with ^. When it is a string,\r\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\r\n\t\t * case-insensitive. When successfully matching a regular expression,\r\n\t\t * the returned value will be the array returned by <code>match</code>,\r\n\t\t * in case you need to extract matched groups.\r\n\t\t * \r\n\t\t * @param {RegExp} pattern\r\n\t\t * @param {Boolean} consume\r\n\t\t * @param {Boolean} caseInsensitive\r\n\t\t * @returns\r\n\t\t */\r\n\t\tmatch: function(pattern, consume, caseInsensitive) {\r\n\t\t\tif (typeof pattern == \"string\") {\r\n\t\t\t\tvar cased = caseInsensitive\r\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\r\n\t\t\t\t\t: function(str) {return str;};\r\n\t\t\t\t\r\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\r\n\t\t\t\t\tif (consume !== false)\r\n\t\t\t\t\t\tthis.pos += pattern.length;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\r\n\t\t\t\tif (match && consume !== false)\r\n\t\t\t\t\tthis.pos += match[0].length;\r\n\t\t\t\treturn match;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Get the string between the start of the current token and the \r\n\t\t * current stream position.\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tcurrent: function(backUp) {\r\n\t\t\treturn this.string.slice(this.start, this.pos - (backUp ? 1 : 0));\r\n\t\t}\r\n\t};\r\n\r\n\tmodule.exports = function(string) {\r\n\t\treturn new StringStream(string);\r\n\t};\r\n\r\n\t/** @deprecated */\r\n\tmodule.exports.create = module.exports;\r\n\treturn module.exports;\r\n});\r\n},{}],\"assets\\\\tabStops.js\":[function(require,module,exports){\r\n/**\r\n * Utility module for handling tabstops tokens generated by Emmet's \r\n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\r\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \r\n * occurrences, replace them with tokens suitable for your editor of choice and \r\n * return object with processed text and list of found tabstops and their ranges.\r\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \r\n * sorted array with plain objects.\r\n * \r\n * Placeholders with the same are meant to be <i>linked</i> in your editor.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar stringStream = require('./stringStream');\r\n\tvar resources = require('./resources');\r\n\r\n\t/**\r\n\t * Global placeholder value, automatically incremented by \r\n\t * <code>variablesResolver()</code> function\r\n\t */\r\n\tvar startPlaceholderNum = 100;\r\n\tvar tabstopIndex = 0;\r\n\t\r\n\tvar defaultOptions = {\r\n\t\treplaceCarets: false,\r\n\t\tescape: function(ch) {\r\n\t\t\treturn '\\\\' + ch;\r\n\t\t},\r\n\t\ttabstop: function(data) {\r\n\t\t\treturn data.token;\r\n\t\t},\r\n\t\tvariable: function(data) {\r\n\t\t\treturn data.token;\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\r\n\t\t * and returns a processed version of <code>text</code> with expanded \r\n\t\t * placeholders and list of tabstops found.\r\n\t\t * @param {String} text Text to process\r\n\t\t * @param {Object} options List of processor options:<br>\r\n\t\t * \r\n\t\t * <b>replaceCarets</b> : <code>Boolean</code> — replace all default\r\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\r\n\t\t * \r\n\t\t * <b>escape</b> : <code>Function</code> — function that handle escaped\r\n\t\t * characters (mostly '$'). By default, it returns the character itself \r\n\t\t * to be displayed as is in output, but sometimes you will use \r\n\t\t * <code>extract</code> method as intermediate solution for further \r\n\t\t * processing and want to keep character escaped. Thus, you should override\r\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\r\n\t\t * \r\n\t\t * <b>tabstop</b> : <code>Function</code> – a tabstop handler. Receives \r\n\t\t * a single argument – an object describing token: its position, number \r\n\t\t * group, placeholder and token itself. Should return a replacement \r\n\t\t * string that will appear in final output\r\n\t\t * \r\n\t\t * <b>variable</b> : <code>Function</code> – variable handler. Receives \r\n\t\t * a single argument – an object describing token: its position, name \r\n\t\t * and original token itself. Should return a replacement \r\n\t\t * string that will appear in final output\r\n\t\t * \r\n\t\t * @returns {Object} Object with processed <code>text</code> property\r\n\t\t * and array of <code>tabstops</code> found\r\n\t\t * @memberOf tabStops\r\n\t\t */\r\n\t\textract: function(text, options) {\r\n\t\t\t// prepare defaults\r\n\t\t\tvar placeholders = {carets: ''};\r\n\t\t\tvar marks = [];\r\n\t\t\t\r\n\t\t\toptions = utils.extend({}, defaultOptions, options, {\r\n\t\t\t\ttabstop: function(data) {\r\n\t\t\t\t\tvar token = data.token;\r\n\t\t\t\t\tvar ret = '';\r\n\t\t\t\t\tif (data.placeholder == 'cursor') {\r\n\t\t\t\t\t\tmarks.push({\r\n\t\t\t\t\t\t\tstart: data.start,\r\n\t\t\t\t\t\t\tend: data.start + token.length,\r\n\t\t\t\t\t\t\tgroup: 'carets',\r\n\t\t\t\t\t\t\tvalue: ''\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// unify placeholder value for single group\r\n\t\t\t\t\t\tif ('placeholder' in data)\r\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (data.group in placeholders)\r\n\t\t\t\t\t\t\tret = placeholders[data.group];\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tmarks.push({\r\n\t\t\t\t\t\t\tstart: data.start,\r\n\t\t\t\t\t\t\tend: data.start + token.length,\r\n\t\t\t\t\t\t\tgroup: data.group,\r\n\t\t\t\t\t\t\tvalue: ret\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (options.replaceCarets) {\r\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// locate tabstops and unify group's placeholders\r\n\t\t\ttext = this.processText(text, options);\r\n\t\t\t\r\n\t\t\t// now, replace all tabstops with placeholders\r\n\t\t\tvar buf = '', lastIx = 0;\r\n\t\t\tvar tabStops = marks.map(function(mark) {\r\n\t\t\t\tbuf += text.substring(lastIx, mark.start);\r\n\t\t\t\t\r\n\t\t\t\tvar pos = buf.length;\r\n\t\t\t\tvar ph = placeholders[mark.group] || '';\r\n\t\t\t\t\r\n\t\t\t\tbuf += ph;\r\n\t\t\t\tlastIx = mark.end;\r\n\t\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\tgroup: mark.group,\r\n\t\t\t\t\tstart: pos,\r\n\t\t\t\t\tend:  pos + ph.length\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tbuf += text.substring(lastIx);\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\ttext: buf,\r\n\t\t\t\ttabstops: tabStops.sort(function(a, b) {\r\n\t\t\t\t\treturn a.start - b.start;\r\n\t\t\t\t})\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Text processing routine. Locates escaped characters and tabstops and\r\n\t\t * replaces them with values returned by handlers defined in \r\n\t\t * <code>options</code>\r\n\t\t * @param {String} text\r\n\t\t * @param {Object} options See <code>extract</code> method options \r\n\t\t * description\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tprocessText: function(text, options) {\r\n\t\t\toptions = utils.extend({}, defaultOptions, options);\r\n\t\t\t\r\n\t\t\tvar buf = '';\r\n\t\t\t/** @type StringStream */\r\n\t\t\tvar stream = stringStream.create(text);\r\n\t\t\tvar ch, m, a;\r\n\t\t\t\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\r\n\t\t\t\t\t// handle escaped character\r\n\t\t\t\t\tbuf += options.escape(stream.next());\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ta = ch;\r\n\t\t\t\t\r\n\t\t\t\tif (ch == '$') {\r\n\t\t\t\t\t// looks like a tabstop\r\n\t\t\t\t\tstream.start = stream.pos - 1;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif ((m = stream.match(/^[0-9]+/))) {\r\n\t\t\t\t\t\t// it's $N\r\n\t\t\t\t\t\ta = options.tabstop({\r\n\t\t\t\t\t\t\tstart: buf.length, \r\n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\r\n\t\t\t\t\t\t\ttoken: stream.current()\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if ((m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/))) {\r\n\t\t\t\t\t\t// ${variable}\r\n\t\t\t\t\t\ta = options.variable({\r\n\t\t\t\t\t\t\tstart: buf.length, \r\n\t\t\t\t\t\t\tname: m[1],\r\n\t\t\t\t\t\t\ttoken: stream.current()\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else if ((m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false))) {\r\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\r\n\t\t\t\t\t\t// parse placeholder, including nested ones\r\n\t\t\t\t\t\tstream.skipToPair('{', '}');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar obj = {\r\n\t\t\t\t\t\t\tstart: buf.length, \r\n\t\t\t\t\t\t\tgroup: m[1],\r\n\t\t\t\t\t\t\ttoken: stream.current()\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (placeholder) {\r\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\ta = options.tabstop(obj);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tbuf += a;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn buf;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @param {Number} offset Tab index offset\r\n\t\t * @returns {Number} Maximum tabstop index in element\r\n\t\t */\r\n\t\tupgrade: function(node, offset) {\r\n\t\t\tvar maxNum = 0;\r\n\t\t\tvar options = {\r\n\t\t\t\ttabstop: function(data) {\r\n\t\t\t\t\tvar group = parseInt(data.group, 10);\r\n\t\t\t\t\tif (group > maxNum) maxNum = group;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (data.placeholder)\r\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t['start', 'end', 'content'].forEach(function(p) {\r\n\t\t\t\tnode[p] = this.processText(node[p], options);\r\n\t\t\t}, this);\r\n\t\t\t\r\n\t\t\treturn maxNum;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Helper function that produces a callback function for \r\n\t\t * <code>replaceVariables()</code> method from {@link utils}\r\n\t\t * module. This callback will replace variable definitions (like \r\n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\r\n\t\t * or outputs tabstop with variable name otherwise.\r\n\t\t * @param {AbbreviationNode} node Context node\r\n\t\t * @returns {Function}\r\n\t\t */\r\n\t\tvariablesResolver: function(node) {\r\n\t\t\tvar placeholderMemo = {};\r\n\t\t\treturn function(str, varName) {\r\n\t\t\t\t// do not mark `child` variable as placeholder – it‘s a reserved\r\n\t\t\t\t// variable name\r\n\t\t\t\tif (varName == 'child') {\r\n\t\t\t\t\treturn str;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (varName == 'cursor') {\r\n\t\t\t\t\treturn utils.getCaretPlaceholder();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar attr = node.attribute(varName);\r\n\t\t\t\tif (typeof attr !== 'undefined' && attr !== str) {\r\n\t\t\t\t\treturn attr;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar varValue = resources.getVariable(varName);\r\n\t\t\t\tif (varValue) {\r\n\t\t\t\t\treturn varValue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// output as placeholder\r\n\t\t\t\tif (!placeholderMemo[varName]) {\r\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Replace variables like ${var} in string\r\n\t\t * @param {String} str\r\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \r\n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceVariables: function(str, vars) {\r\n\t\t\tvars = vars || {};\r\n\t\t\tvar resolver = typeof vars === 'function' ? vars : function(str, p1) {\r\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\treturn this.processText(str, {\r\n\t\t\t\tvariable: function(data) {\r\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\r\n\t\t\t\t\tif (newValue === null) {\r\n\t\t\t\t\t\t// try to find variable in resources\r\n\t\t\t\t\t\tnewValue = resources.getVariable(data.name);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (newValue === null || typeof newValue === 'undefined')\r\n\t\t\t\t\t\t// nothing found, return token itself\r\n\t\t\t\t\t\tnewValue = data.token;\r\n\t\t\t\t\treturn newValue;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Resets global tabstop index. When parsed tree is converted to output\r\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \r\n\t\t * defined in snippets and elements are upgraded in order to prevent\r\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\r\n\t\t * should not be linked with the same placehilder of the child node.\r\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\r\n\t\t * upgrades tabstops of the same index for each node and writes maximum\r\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\r\n\t\t * this variable at reasonable value, it is recommended to call \r\n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \r\n\t\t * @returns\r\n\t\t */\r\n\t\tresetTabstopIndex: function() {\r\n\t\t\ttabstopIndex = 0;\r\n\t\t\tstartPlaceholderNum = 100;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Output processor for abbreviation parser that will upgrade tabstops \r\n\t\t * of parsed node in order to prevent tabstop index conflicts\r\n\t\t */\r\n\t\tabbrOutputProcessor: function(text, node, type) {\r\n\t\t\tvar maxNum = 0;\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\tvar tsOptions = {\r\n\t\t\t\ttabstop: function(data) {\r\n\t\t\t\t\tvar group = parseInt(data.group, 10);\r\n\t\t\t\t\tif (group === 0)\r\n\t\t\t\t\t\treturn '${0}';\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (group > maxNum) maxNum = group;\r\n\t\t\t\t\tif (data.placeholder) {\r\n\t\t\t\t\t\t// respect nested placeholders\r\n\t\t\t\t\t\tvar ix = group + tabstopIndex;\r\n\t\t\t\t\t\tvar placeholder = that.processText(data.placeholder, tsOptions);\r\n\t\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// upgrade tabstops\r\n\t\t\ttext = this.processText(text, tsOptions);\r\n\t\t\t\r\n\t\t\t// resolve variables\r\n\t\t\ttext = this.replaceVariables(text, this.variablesResolver(node));\r\n\t\t\t\r\n\t\t\ttabstopIndex += maxNum + 1;\r\n\t\t\treturn text;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\",\"./resources\":\"assets\\\\resources.js\",\"./stringStream\":\"assets\\\\stringStream.js\"}],\"assets\\\\tokenIterator.js\":[function(require,module,exports){\r\n/**\r\n * Helper class for convenient token iteration\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * @type TokenIterator\r\n\t * @param {Array} tokens\r\n\t * @type TokenIterator\r\n\t * @constructor\r\n\t */\r\n\tfunction TokenIterator(tokens) {\r\n\t\t/** @type Array */\r\n\t\tthis.tokens = tokens;\r\n\t\tthis._position = 0;\r\n\t\tthis.reset();\r\n\t}\r\n\t\r\n\tTokenIterator.prototype = {\r\n\t\tnext: function() {\r\n\t\t\tif (this.hasNext()) {\r\n\t\t\t\tvar token = this.tokens[++this._i];\r\n\t\t\t\tthis._position = token.start;\r\n\t\t\t\treturn token;\r\n\t\t\t} else {\r\n\t\t\t\tthis._i = this._il;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tcurrent: function() {\r\n\t\t\treturn this.tokens[this._i];\r\n\t\t},\r\n\r\n\t\tpeek: function() {\r\n\t\t\treturn this.tokens[this._i + i];\r\n\t\t},\r\n\t\t\r\n\t\tposition: function() {\r\n\t\t\treturn this._position;\r\n\t\t},\r\n\t\t\r\n\t\thasNext: function() {\r\n\t\t\treturn this._i < this._il - 1;\r\n\t\t},\r\n\t\t\r\n\t\treset: function() {\r\n\t\t\tthis._i = 0;\r\n\t\t\tthis._il = this.tokens.length;\r\n\t\t},\r\n\t\t\r\n\t\titem: function() {\r\n\t\t\treturn this.tokens[this._i];\r\n\t\t},\r\n\t\t\r\n\t\titemNext: function() {\r\n\t\t\treturn this.tokens[this._i + 1];\r\n\t\t},\r\n\t\t\r\n\t\titemPrev: function() {\r\n\t\t\treturn this.tokens[this._i - 1];\r\n\t\t},\r\n\t\t\r\n\t\tnextUntil: function(type, callback) {\r\n\t\t\tvar token;\r\n\t\t\tvar test = typeof type == 'string' \r\n\t\t\t\t? function(t){return t.type == type;} \r\n\t\t\t\t: type;\r\n\t\t\t\r\n\t\t\twhile ((token = this.next())) {\r\n\t\t\t\tif (callback)\r\n\t\t\t\t\tcallback.call(this, token);\r\n\t\t\t\tif (test.call(this, token))\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\tcreate: function(tokens) {\r\n\t\t\treturn new TokenIterator(tokens);\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"editTree\\\\base.js\":[function(require,module,exports){\r\n/**\r\n * Abstract implementation of edit tree interface.\r\n * Edit tree is a named container of editable “name-value” child elements, \r\n * parsed from <code>source</code>. This container provides convenient methods\r\n * for editing/adding/removing child elements. All these update actions are\r\n * instantly reflected in the <code>source</code> code with respect of formatting.\r\n * <br><br>\r\n * For example, developer can create an edit tree from CSS rule and add or \r\n * remove properties from it–all changes will be immediately reflected in the \r\n * original source.\r\n * <br><br>\r\n * All classes defined in this module should be extended the same way as in\r\n * Backbone framework: using <code>extend</code> method to create new class and \r\n * <code>initialize</code> method to define custom class constructor.\r\n * \r\n * @example\r\n * <pre><code>\r\n * var MyClass = require('editTree/base').EditElement.extend({\r\n *     initialize: function() {\r\n *     // constructor code here\r\n *   }\r\n * });\r\n * \r\n * var elem = new MyClass(); \r\n * </code></pre>\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\tvar klass = require('../vendor/klass');\r\n\t\r\n\t/**\r\n\t * Named container of edited source\r\n\t * @type EditContainer\r\n\t * @param {String} source\r\n\t * @param {Object} options\r\n\t */\r\n\tfunction EditContainer(source, options) {\r\n\t\tthis.options = utils.extend({offset: 0}, options);\r\n\t\t/**\r\n\t\t * Source code of edited structure. All changes in the structure are \r\n\t\t * immediately reflected into this property\r\n\t\t */\r\n\t\tthis.source = source;\r\n\t\t\r\n\t\t/** \r\n\t\t * List of all editable children\r\n\t\t * @private \r\n\t\t */\r\n\t\tthis._children = [];\r\n\t\t\r\n\t\t/**\r\n\t\t * Hash of all positions of container\r\n\t\t * @private\r\n\t\t */\r\n\t\tthis._positions = {\r\n\t\t\tname: 0\r\n\t\t};\r\n\t\t\r\n\t\tthis.initialize.apply(this, arguments);\r\n\t}\r\n\t\r\n\t/**\r\n\t * The self-propagating extend function for classes.\r\n\t * @type Function\r\n\t */\r\n\tEditContainer.extend = klass.extend;\r\n\t\r\n\tEditContainer.prototype = {\r\n\t\ttype: 'container',\r\n\t\t/**\r\n\t\t * Child class constructor\r\n\t\t */\r\n\t\tinitialize: function() {},\r\n\r\n\t\t/**\r\n\t\t * Make position absolute\r\n\t\t * @private\r\n\t\t * @param {Number} num\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\t_pos: function(num, isAbsolute) {\r\n\t\t\treturn num + (isAbsolute ? this.options.offset : 0);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replace substring of tag's source\r\n\t\t * @param {String} value\r\n\t\t * @param {Number} start\r\n\t\t * @param {Number} end\r\n\t\t * @private\r\n\t\t */\r\n\t\t_updateSource: function(value, start, end) {\r\n\t\t\t// create modification range\r\n\t\t\tvar r = range.create(start, typeof end === 'undefined' ? 0 : end - start);\r\n\t\t\tvar delta = value.length - r.length();\r\n\t\t\t\r\n\t\t\tvar update = function(obj) {\r\n\t\t\t\tObject.keys(obj).forEach(function(k) {\r\n\t\t\t\t\tif (obj[k] >= r.end) {\r\n\t\t\t\t\t\tobj[k] += delta;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// update affected positions of current container\r\n\t\t\tupdate(this._positions);\r\n\t\t\t\r\n\t\t\t// update affected positions of children\r\n\t\t\tvar recursiveUpdate = function(items) {\r\n\t\t\t\titems.forEach(function(item) {\r\n\t\t\t\t\tupdate(item._positions);\r\n\t\t\t\t\tif (item.type == 'container') {\r\n\t\t\t\t\t\trecursiveUpdate(item.list());\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t};\r\n\r\n\t\t\trecursiveUpdate(this.list());\r\n\t\t\tthis.source = utils.replaceSubstring(this.source, value, r);\r\n\t\t},\r\n\t\t\t\r\n\t\t\t\r\n\t\t/**\r\n\t\t * Adds new attribute \r\n\t\t * @param {String} name Property name\r\n\t\t * @param {String} value Property value\r\n\t\t * @param {Number} pos Position at which to insert new property. By \r\n\t\t * default the property is inserted at the end of rule \r\n\t\t * @returns {EditElement} Newly created element\r\n\t\t */\r\n\t\tadd: function(name, value, pos) {\r\n\t\t\t// this is abstract implementation\r\n\t\t\tvar item = new EditElement(name, value);\r\n\t\t\tthis._children.push(item);\r\n\t\t\treturn item;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns attribute object\r\n\t\t * @param {String} name Attribute name or its index\r\n\t\t * @returns {EditElement}\r\n\t\t */\r\n\t\tget: function(name) {\r\n\t\t\tif (typeof name === 'number') {\r\n\t\t\t\treturn this.list()[name];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof name === 'string') {\r\n\t\t\t\treturn utils.find(this.list(), function(prop) {\r\n\t\t\t\t\treturn prop.name() === name;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all children by name or indexes\r\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\r\n\t\t * <code>Array</code>, <code>Number</code>)\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetAll: function(name) {\r\n\t\t\tif (!Array.isArray(name))\r\n\t\t\t\tname = [name];\r\n\t\t\t\r\n\t\t\t// split names and indexes\r\n\t\t\tvar names = [], indexes = [];\r\n\t\t\tname.forEach(function(item) {\r\n\t\t\t\tif (typeof item === 'string') {\r\n\t\t\t\t\tnames.push(item);\r\n\t\t\t\t} else if (typeof item === 'number') {\r\n\t\t\t\t\tindexes.push(item);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn this.list().filter(function(attribute, i) {\r\n\t\t\t\treturn ~indexes.indexOf(i) || ~names.indexOf(attribute.name());\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns list of all editable child elements\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlist: function() {\r\n\t\t\treturn this._children;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Remove child element\r\n\t\t * @param {String} name Property name or its index\r\n\t\t */\r\n\t\tremove: function(name) {\r\n\t\t\tvar element = this.get(name);\r\n\t\t\tif (element) {\r\n\t\t\t\tthis._updateSource('', element.fullRange());\r\n\t\t\t\tvar ix = this._children.indexOf(element);\r\n\t\t\t\tif (~ix) {\r\n\t\t\t\t\tthis._children.splice(ix, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns index of editble child in list\r\n\t\t * @param {Object} item\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tindexOf: function(item) {\r\n\t\t\treturn this.list().indexOf(this.get(item));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns or updates element value. If such element doesn't exists,\r\n\t\t * it will be created automatically and added at the end of child list.\r\n\t\t * @param {String} name Element name or its index\r\n\t\t * @param {String} value New element value\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalue: function(name, value, pos) {\r\n\t\t\tvar element = this.get(name);\r\n\t\t\tif (element)\r\n\t\t\t\treturn element.value(value);\r\n\t\t\t\r\n\t\t\tif (typeof value !== 'undefined') {\r\n\t\t\t\t// no such element — create it\r\n\t\t\t\treturn this.add(name, value, pos);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns all values of child elements found by <code>getAll()</code>\r\n\t\t * method\r\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\r\n\t\t * <code>Array</code>, <code>Number</code>)\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tvalues: function(name) {\r\n\t\t\treturn this.getAll(name).map(function(element) {\r\n\t\t\t\treturn element.value();\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets or gets container name\r\n\t\t * @param {String} val New name. If not passed, current \r\n\t\t * name is returned\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tname: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._name !== (val = String(val))) {\r\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\r\n\t\t\t\tthis._name = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns name range object\r\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \r\n\t\t * rule offset)\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tnameRange: function(isAbsolute) {\r\n\t\t\treturn range.create(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns range of current source\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t */\r\n\t\trange: function(isAbsolute) {\r\n\t\t\treturn range.create(isAbsolute ? this.options.offset : 0, this.valueOf());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element that belongs to specified position\r\n\t\t * @param {Number} pos\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t * @returns {EditElement}\r\n\t\t */\r\n\t\titemFromPosition: function(pos, isAbsolute) {\r\n\t\t\treturn utils.find(this.list(), function(elem) {\r\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns source code of current container \r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.source;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * @param {EditContainer} parent\r\n\t * @param {Object} nameToken\r\n\t * @param {Object} valueToken\r\n\t */\r\n\tfunction EditElement(parent, nameToken, valueToken) {\r\n\t\t/** @type EditContainer */\r\n\t\tthis.parent = parent;\r\n\t\t\r\n\t\tthis._name = nameToken.value;\r\n\t\tthis._value = valueToken ? valueToken.value : '';\r\n\t\t\r\n\t\tthis._positions = {\r\n\t\t\tname: nameToken.start,\r\n\t\t\tvalue: valueToken ? valueToken.start : -1\r\n\t\t};\r\n\t\t\r\n\t\tthis.initialize.apply(this, arguments);\r\n\t}\r\n\t\r\n\t/**\r\n\t * The self-propagating extend function for classes.\r\n\t * @type Function\r\n\t */\r\n\tEditElement.extend = klass.extend;\r\n\t\r\n\tEditElement.prototype = {\r\n\t\ttype: 'element',\r\n\r\n\t\t/**\r\n\t\t * Child class constructor\r\n\t\t */\r\n\t\tinitialize: function() {},\r\n\t\t\r\n\t\t/**\r\n\t\t * Make position absolute\r\n\t\t * @private\r\n\t\t * @param {Number} num\r\n\t\t * @param {Boolean} isAbsolute\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\t_pos: function(num, isAbsolute) {\r\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\r\n\t\t},\r\n\t\t\t\r\n\t\t/**\r\n\t\t * Sets of gets element value\r\n\t\t * @param {String} val New element value. If not passed, current \r\n\t\t * value is returned\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalue: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._value !== (val = String(val))) {\r\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\r\n\t\t\t\tthis._value = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._value;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets of gets element name\r\n\t\t * @param {String} val New element name. If not passed, current \r\n\t\t * name is returned\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tname: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._name !== (val = String(val))) {\r\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\r\n\t\t\t\tthis._name = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns position of element name token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tnamePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns position of element value token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tvaluePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element name\r\n\t\t * @param {Boolean} isAbsolute Return absolute range \r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\trange: function(isAbsolute) {\r\n\t\t\treturn range.create(this.namePosition(isAbsolute), this.valueOf());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns full element range, including possible indentation\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tfullRange: function(isAbsolute) {\r\n\t\t\treturn this.range(isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element name range\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tnameRange: function(isAbsolute) {\r\n\t\t\treturn range.create(this.namePosition(isAbsolute), this.name());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns element value range\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tvalueRange: function(isAbsolute) {\r\n\t\t\treturn range.create(this.valuePosition(isAbsolute), this.value());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns current element string representation\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\t\t\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.name() + this.value();\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn {\r\n\t\tEditContainer: EditContainer,\r\n\t\tEditElement: EditElement,\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates token that can be fed to <code>EditElement</code>\r\n\t\t * @param {Number} start\r\n\t\t * @param {String} value\r\n\t\t * @param {String} type\r\n\t\t * @returns\r\n\t\t */\r\n\t\tcreateToken: function(start, value, type) {\r\n\t\t\tvar obj = {\r\n\t\t\t\tstart: start || 0,\r\n\t\t\t\tvalue: value || '',\r\n\t\t\t\ttype: type\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tobj.end = obj.start + obj.value.length;\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../utils/common\":\"utils\\\\common.js\",\"../vendor/klass\":\"vendor\\\\klass.js\"}],\"editTree\\\\css.js\":[function(require,module,exports){\r\n/**\r\n * CSS EditTree is a module that can parse a CSS rule into a tree with \r\n * convenient methods for adding, modifying and removing CSS properties. These \r\n * changes can be written back to string with respect of code formatting.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar editTree = require('./base');\r\n\tvar cssParser = require('../parser/css');\r\n\tvar cssSections = require('../utils/cssSections');\r\n\tvar range = require('../assets/range');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar tokenIterator = require('../assets/tokenIterator');\r\n\r\n\tvar defaultOptions = {\r\n\t\tstyleBefore: '\\n\\t',\r\n\t\tstyleSeparator: ': ',\r\n\t\toffset: 0\r\n\t};\r\n\t\r\n\tvar reSpaceStart = /^\\s+/;\r\n\tvar reSpaceEnd = /\\s+$/;\r\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\r\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\r\n\t\r\n\t/**\r\n\t * Modifies given range to remove whitespace from beginning\r\n\t * and/or from the end\r\n\t * @param  {Range} rng Range to modify\r\n\t * @param  {String} text  Text that range belongs to\r\n\t * @param  {Number} mask  Mask indicating from which end \r\n\t * whitespace should be removed\r\n\t * @return {Range}\r\n\t */\r\n\tfunction trimWhitespaceInRange(rng, text, mask) {\r\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\r\n\t\ttext = rng.substring(text);\r\n\t\tvar m;\r\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) && (m = text.match(reSpaceStart))) {\r\n\t\t\trng.start += m[0].length;\r\n\t\t}\r\n\r\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) && (m = text.match(reSpaceEnd))) {\r\n\t\t\trng.end -= m[0].length;\r\n\t\t}\r\n\r\n\t\t// in case given range is just a whatespace\r\n\t\tif (rng.end < rng.start) {\r\n\t\t\trng.end = rng.start;\r\n\t\t}\r\n\r\n\t\treturn rng;\r\n\t}\r\n\r\n\t/**\r\n\t * Consumes CSS property and value from current token\r\n\t * iterator state. Offsets iterator pointer into token\r\n\t * that can be used for next value consmption\r\n\t * @param  {TokenIterator} it\r\n\t * @param  {String} text\r\n\t * @return {Object}    Object with `name` and `value` properties \r\n\t * ar ranges. Value range can be zero-length.\r\n\t */\r\n\tfunction consumeSingleProperty(it, text) {\r\n\t\tvar name, value, end;\r\n\t\tvar token = it.current();\r\n\r\n\t\tif (!token) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// skip whitespace\r\n\t\tvar ws = {'white': 1, 'line': 1, 'comment': 1};\r\n\t\twhile ((token = it.current())) {\r\n\t\t\tif (!(token.type in ws)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tit.next();\r\n\t\t}\r\n\r\n\t\tif (!it.hasNext()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// consume property name\r\n\t\ttoken = it.current();\r\n\t\tname = range(token.start, token.value);\r\n\t\tvar isAtProperty = token.value.charAt(0) == '@';\r\n\t\twhile (token = it.next()) {\r\n\t\t\tname.end = token.end;\r\n\t\t\tif (token.type == ':' || token.type == 'white') {\r\n\t\t\t\tname.end = token.start;\r\n\t\t\t\tit.next();\r\n\t\t\t\tif (token.type == ':' || isAtProperty) {\r\n\t\t\t\t\t// XXX I really ashame of this hardcode, but I need\r\n\t\t\t\t\t// to stop parsing if this is an SCSS mixin call,\r\n\t\t\t\t\t// for example: @include border-radius(10px)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type == ';' || token.type == 'line') {\r\n\t\t\t\t// there’s no value, looks like a mixin\r\n\t\t\t\t// or a special use case:\r\n\t\t\t\t// user is writing a new property or abbreviation\r\n\t\t\t\tname.end = token.start;\r\n\t\t\t\tvalue = range(token.start, 0);\r\n\t\t\t\tit.next();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttoken = it.current();\r\n\t\tif (!value && token) {\r\n\t\t\tif (token.type == 'line') {\r\n\t\t\t\tlastNewline = token;\r\n\t\t\t}\r\n\t\t\t// consume value\r\n\t\t\tvalue = range(token.start, token.value);\r\n\t\t\tvar lastNewline;\r\n\t\t\twhile ((token = it.next())) {\r\n\t\t\t\tvalue.end = token.end;\r\n\t\t\t\tif (token.type == 'line') {\r\n\t\t\t\t\tlastNewline = token;\r\n\t\t\t\t} else if (token.type == '}' || token.type == ';') {\r\n\t\t\t\t\tvalue.end = token.start;\r\n\t\t\t\t\tif (token.type == ';') {\r\n\t\t\t\t\t\tend = range(token.start, token.value);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tit.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if (token.type == ':' && lastNewline) {\r\n\t\t\t\t\t// A special case: \r\n\t\t\t\t\t// user is writing a value before existing\r\n\t\t\t\t\t// property, but didn’t inserted closing semi-colon.\r\n\t\t\t\t\t// In this case, limit value range to previous\r\n\t\t\t\t\t// newline\r\n\t\t\t\t\tvalue.end = lastNewline.start;\r\n\t\t\t\t\tit._i = it.tokens.indexOf(lastNewline);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!value) {\r\n\t\t\tvalue = range(name.end, 0);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tname: trimWhitespaceInRange(name, text),\r\n\t\t\tvalue: trimWhitespaceInRange(value, text, WHITESPACE_REMOVE_FROM_START | (end ? WHITESPACE_REMOVE_FROM_END : 0)),\r\n\t\t\tend: end || range(value.end, 0)\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Finds parts of complex CSS value\r\n\t * @param {String} str\r\n\t * @returns {Array} Returns list of <code>Range</code>'s\r\n\t */\r\n\tfunction findParts(str) {\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(str);\r\n\t\tvar ch;\r\n\t\tvar result = [];\r\n\t\tvar sep = /[\\s\\u00a0,;]/;\r\n\t\t\r\n\t\tvar add = function() {\r\n\t\t\tstream.next();\r\n\t\t\tresult.push(range(stream.start, stream.current()));\r\n\t\t\tstream.start = stream.pos;\r\n\t\t};\r\n\t\t\r\n\t\t// skip whitespace\r\n\t\tstream.eatSpace();\r\n\t\tstream.start = stream.pos;\r\n\t\t\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (ch == '\"' || ch == \"'\") {\r\n\t\t\t\tstream.next();\r\n\t\t\t\tif (!stream.skipTo(ch)) break;\r\n\t\t\t\tadd();\r\n\t\t\t} else if (ch == '(') {\r\n\t\t\t\t// function found, may have nested function\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\r\n\t\t\t\tstream.backUp(1);\r\n\t\t\t\tadd();\r\n\t\t\t} else {\r\n\t\t\t\tif (sep.test(ch)) {\r\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\r\n\t\t\t\t\tstream.eatWhile(sep);\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tadd();\r\n\r\n\t\treturn utils.unique(result.filter(function(item) {\r\n\t\t\treturn !!item.length();\r\n\t\t}));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parses CSS properties from given CSS source\r\n\t * and adds them to CSSEditContainer node\r\n\t * @param  {CSSEditContainer} node\r\n\t * @param  {String} source CSS source\r\n\t * @param {Number} offset Offset of properties subset from original source\r\n\t */\r\n\tfunction consumeProperties(node, source, offset) {\r\n\t\tvar list = extractPropertiesFromSource(source, offset);\r\n\r\n\t\tlist.forEach(function(property) {\r\n\t\t\tnode._children.push(new CSSEditElement(node,\r\n\t\t\t\teditTree.createToken(property.name.start, property.nameText),\r\n\t\t\t\teditTree.createToken(property.value.start, property.valueText),\r\n\t\t\t\teditTree.createToken(property.end.start, property.endText)\r\n\t\t\t\t));\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Parses given CSS source and returns list of ranges of located CSS properties.\r\n\t * Normally, CSS source must contain properties only, it must be,\r\n\t * for example, a content of CSS selector or text between nested\r\n\t * CSS sections\r\n\t * @param  {String} source CSS source\r\n\t * @param {Number} offset Offset of properties subset from original source.\r\n\t * Used to provide proper ranges of locates items\r\n\t */\r\n\tfunction extractPropertiesFromSource(source, offset) {\r\n\t\toffset = offset || 0;\r\n\t\tsource = source.replace(reSpaceEnd, '');\r\n\t\tvar out = [];\r\n\r\n\t\tif (!source) {\r\n\t\t\treturn out;\r\n\t\t}\r\n\r\n\t\tvar tokens = cssParser.parse(source);\r\n\t\tvar it = tokenIterator.create(tokens);\r\n\t\tvar property;\r\n\r\n\t\twhile ((property = consumeSingleProperty(it, source))) {\r\n\t\t\tout.push({\r\n\t\t\t\tnameText: property.name.substring(source),\r\n\t\t\t\tname: property.name.shift(offset),\r\n\r\n\t\t\t\tvalueText: property.value.substring(source),\r\n\t\t\t\tvalue: property.value.shift(offset),\r\n\r\n\t\t\t\tendText: property.end.substring(source),\r\n\t\t\t\tend: property.end.shift(offset)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @class\r\n\t * @extends EditContainer\r\n\t */\r\n\tvar CSSEditContainer = editTree.EditContainer.extend({\r\n\t\tinitialize: function(source, options) {\r\n\t\t\tutils.extend(this.options, defaultOptions, options);\r\n\t\t\t\r\n\t\t\tif (Array.isArray(source)) {\r\n\t\t\t\tsource = cssParser.toSource(source);\r\n\t\t\t}\r\n\r\n\t\t\tvar allRules = cssSections.findAllRules(source);\r\n\t\t\tvar currentRule = allRules.shift();\r\n\r\n\t\t\t// keep top-level rules only since they will\r\n\t\t\t// be parsed by nested CSSEditContainer call\r\n\t\t\tvar topLevelRules = [];\r\n\t\t\tallRules.forEach(function(r) {\r\n\t\t\t\tvar isTopLevel = !utils.find(topLevelRules, function(tr) {\r\n\t\t\t\t\treturn tr.contains(r);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (isTopLevel) {\r\n\t\t\t\t\ttopLevelRules.push(r);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\t\tvar selectorRange = range.create2(currentRule.start, currentRule._selectorEnd);\r\n\t\t\tthis._name = selectorRange.substring(source);\r\n\t\t\tthis._positions.name = selectorRange.start;\r\n\t\t\tthis._positions.contentStart = currentRule._contentStart + 1;\r\n\r\n\t\t\tvar sectionOffset = currentRule._contentStart + 1;\r\n\t\t\tvar sectionEnd = currentRule.end - 1;\r\n\r\n\t\t\t// parse properties between nested rules\r\n\t\t\t// and add nested rules as children\r\n\t\t\tvar that = this;\r\n\t\t\ttopLevelRules.forEach(function(r) {\r\n\t\t\t\tconsumeProperties(that, source.substring(sectionOffset, r.start), sectionOffset);\r\n\t\t\t\tvar opt = utils.extend({}, that.options, {offset: r.start + that.options.offset});\r\n\t\t\t\t// XXX I think I don’t need nested containers here\r\n\t\t\t\t// They should be handled separately\r\n\t\t\t\t// that._children.push(new CSSEditContainer(r.substring(source), opt));\r\n\t\t\t\tsectionOffset = r.end;\r\n\t\t\t});\r\n\r\n\t\t\t// consume the rest of data\r\n\t\t\tconsumeProperties(this, source.substring(sectionOffset, currentRule.end - 1), sectionOffset);\r\n\t\t\tthis._saveStyle();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Remembers all styles of properties\r\n\t\t * @private\r\n\t\t */\r\n\t\t_saveStyle: function() {\r\n\t\t\tvar start = this._positions.contentStart;\r\n\t\t\tvar source = this.source;\r\n\t\t\t\r\n\t\t\tthis.list().forEach(function(p) {\r\n\t\t\t\tif (p.type === 'container') {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\r\n\t\t\t\t// a small hack here:\r\n\t\t\t\t// Sometimes users add empty lines before properties to logically\r\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\r\n\t\t\t\t// characters between rules may lead to undesired behavior,\r\n\t\t\t\t// especially when current rule is duplicated or used as a donor\r\n\t\t\t\t// to create new rule.\r\n\t\t\t\t// To solve this issue, we‘ll take only last newline indentation\r\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\r\n\t\t\t\tif (lines.length > 1) {\r\n\t\t\t\t\tp.styleBefore = '\\n' + lines[lines.length - 1];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\r\n\t\t\t\t\r\n\t\t\t\t// graceful and naive comments removal \r\n\t\t\t\tvar parts = p.styleBefore.split('*/');\r\n\t\t\t\tp.styleBefore = parts[parts.length - 1];\r\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\r\n\t\t\t\t\r\n\t\t\t\tstart = p.range().end;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns position of element name token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tnamePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns position of element value token\r\n\t\t * @param {Boolean} isAbsolute Return absolute position\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tvaluePosition: function(isAbsolute) {\r\n\t\t\treturn this._pos(this._positions.contentStart, isAbsolute);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns element value range\r\n\t\t * @param {Boolean} isAbsolute Return absolute range\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tvalueRange: function(isAbsolute) {\r\n\t\t\treturn range.create2(this.valuePosition(isAbsolute), this._pos(this.valueOf().length, isAbsolute) - 1);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new CSS property \r\n\t\t * @param {String} name Property name\r\n\t\t * @param {String} value Property value\r\n\t\t * @param {Number} pos Position at which to insert new property. By \r\n\t\t * default the property is inserted at the end of rule \r\n\t\t * @returns {CSSEditProperty}\r\n\t\t */\r\n\t\tadd: function(name, value, pos) {\r\n\t\t\tvar list = this.list();\r\n\t\t\tvar start = this._positions.contentStart;\r\n\t\t\tvar styles = utils.pick(this.options, 'styleBefore', 'styleSeparator');\r\n\t\t\t\r\n\t\t\tif (typeof pos === 'undefined') {\r\n\t\t\t\tpos = list.length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/** @type CSSEditProperty */\r\n\t\t\tvar donor = list[pos];\r\n\t\t\tif (donor) {\r\n\t\t\t\tstart = donor.fullRange().start;\r\n\t\t\t} else if ((donor = list[pos - 1])) {\r\n\t\t\t\t// make sure that donor has terminating semicolon\r\n\t\t\t\tdonor.end(';');\r\n\t\t\t\tstart = donor.range().end;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (donor) {\r\n\t\t\t\tstyles = utils.pick(donor, 'styleBefore', 'styleSeparator');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\r\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\r\n\t\t\t\r\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\r\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\r\n\t\t\t\r\n\t\t\tutils.extend(property, styles);\r\n\t\t\t\r\n\t\t\t// write new property into the source\r\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\r\n\t\t\t\r\n\t\t\t// insert new property\r\n\t\t\tthis._children.splice(pos, 0, property);\r\n\t\t\treturn property;\r\n\t\t}\r\n\t});\r\n\t\r\n\t/**\r\n\t * @class\r\n\t * @type CSSEditElement\r\n\t * @constructor\r\n\t */\r\n\tvar CSSEditElement = editTree.EditElement.extend({\r\n\t\tinitialize: function(rule, name, value, end) {\r\n\t\t\tthis.styleBefore = rule.options.styleBefore;\r\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\r\n\t\t\t\r\n\t\t\tthis._end = end.value;\r\n\t\t\tthis._positions.end = end.start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns ranges of complex value parts\r\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\r\n\t\t */\r\n\t\tvalueParts: function(isAbsolute) {\r\n\t\t\tvar parts = findParts(this.value());\r\n\t\t\tif (isAbsolute) {\r\n\t\t\t\tvar offset = this.valuePosition(true);\r\n\t\t\t\tparts.forEach(function(p) {\r\n\t\t\t\t\tp.shift(offset);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn parts;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sets of gets element value. \r\n\t\t * When setting value, this implementation will ensure that your have \r\n\t\t * proper name-value separator\r\n\t\t * @param {String} val New element value. If not passed, current \r\n\t\t * value is returned\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalue: function(val) {\r\n\t\t\tvar isUpdating = typeof val !== 'undefined';\r\n\t\t\tvar allItems = this.parent.list();\r\n\t\t\tif (isUpdating && this.isIncomplete()) {\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tvar donor = utils.find(allItems, function(item) {\r\n\t\t\t\t\treturn item !== self && !item.isIncomplete();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthis.styleSeparator = donor \r\n\t\t\t\t\t? donor.styleSeparator \r\n\t\t\t\t\t: this.parent.options.styleSeparator;\r\n\t\t\t\tthis.parent._updateSource(this.styleSeparator, range(this.valueRange().start, 0));\r\n\t\t\t}\r\n\r\n\t\t\tvar value = this.constructor.__super__.value.apply(this, arguments);\r\n\t\t\tif (isUpdating) {\r\n\t\t\t\t// make sure current property has terminating semi-colon\r\n\t\t\t\t// if it’s not the last one\r\n\t\t\t\tvar ix = allItems.indexOf(this);\r\n\t\t\t\tif (ix !== allItems.length - 1 && !this.end()) {\r\n\t\t\t\t\tthis.end(';');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Test if current element is incomplete, e.g. has no explicit\r\n\t\t * name-value separator\r\n\t\t * @return {Boolean} [description]\r\n\t\t */\r\n\t\tisIncomplete: function() {\r\n\t\t\treturn this.nameRange().end === this.valueRange().start;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets of gets property end value (basically, it's a semicolon)\r\n\t\t * @param {String} val New end value. If not passed, current \r\n\t\t * value is returned\r\n\t\t */\r\n\t\tend: function(val) {\r\n\t\t\tif (typeof val !== 'undefined' && this._end !== val) {\r\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\r\n\t\t\t\tthis._end = val;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._end;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns full rule range, with indentation\r\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\r\n\t\t * rule offset)\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tfullRange: function(isAbsolute) {\r\n\t\t\tvar r = this.range(isAbsolute);\r\n\t\t\tr.start -= this.styleBefore.length;\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns item string representation\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Parses CSS rule into editable tree\r\n\t\t * @param {String} source\r\n\t\t * @param {Object} options\r\n\t\t * @memberOf emmet.cssEditTree\r\n\t\t * @returns {EditContainer}\r\n\t\t */\r\n\t\tparse: function(source, options) {\r\n\t\t\treturn new CSSEditContainer(source, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \r\n\t\t * @param {String} content CSS source code\r\n\t\t * @param {Number} pos Character position where to start source code extraction\r\n\t\t * @returns {EditContainer}\r\n\t\t */\r\n\t\tparseFromPosition: function(content, pos, isBackward) {\r\n\t\t\tvar bounds = cssSections.locateRule(content, pos, isBackward);\r\n\t\t\tif (!bounds || !bounds.inside(pos)) {\r\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this.parse(bounds.substring(content), {\r\n\t\t\t\toffset: bounds.start\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Locates CSS property in given CSS code fragment under specified character position\r\n\t\t * @param  {String} css CSS code or parsed CSSEditContainer\r\n\t\t * @param  {Number} pos Character position where to search CSS property\r\n\t\t * @return {CSSEditElement}\r\n\t\t */\r\n\t\tpropertyFromPosition: function(css, pos) {\r\n\t\t\tvar cssProp = null;\r\n\t\t\t/** @type EditContainer */\r\n\t\t\tvar cssRule = typeof css === 'string' ? this.parseFromPosition(css, pos, true) : css;\r\n\t\t\tif (cssRule) {\r\n\t\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\r\n\t\t\t\tif (!cssProp) {\r\n\t\t\t\t\t// in case user just started writing CSS property\r\n\t\t\t\t\t// and didn't include semicolon–try another approach\r\n\t\t\t\t\tcssProp = utils.find(cssRule.list(), function(elem) {\r\n\t\t\t\t\t\treturn elem.range(true).end == pos;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn cssProp;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes vendor prefix from CSS property\r\n\t\t * @param {String} name CSS property\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tbaseName: function(name) {\r\n\t\t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds parts of complex CSS value\r\n\t\t * @param {String} str\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tfindParts: findParts,\r\n\r\n\t\textractPropertiesFromSource: extractPropertiesFromSource\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../assets/tokenIterator\":\"assets\\\\tokenIterator.js\",\"../parser/css\":\"parser\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/cssSections\":\"utils\\\\cssSections.js\",\"./base\":\"editTree\\\\base.js\"}],\"editTree\\\\xml.js\":[function(require,module,exports){\r\n/**\r\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \r\n * convenient methods for adding, modifying and removing attributes. These \r\n * changes can be written back to string with respect of code formatting.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar editTree = require('./base');\r\n\tvar xmlParser = require('../parser/xml');\r\n\tvar range = require('../assets/range');\r\n\tvar utils = require('../utils/common');\r\n\r\n\tvar defaultOptions = {\r\n\t\tstyleBefore: ' ',\r\n\t\tstyleSeparator: '=',\r\n\t\tstyleQuote: '\"',\r\n\t\toffset: 0\r\n\t};\r\n\t\r\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\r\n\t\r\n\tvar XMLEditContainer = editTree.EditContainer.extend({\r\n\t\tinitialize: function(source, options) {\r\n\t\t\tutils.defaults(this.options, defaultOptions);\r\n\t\t\tthis._positions.name = 1;\r\n\t\t\t\r\n\t\t\tvar attrToken = null;\r\n\t\t\tvar tokens = xmlParser.parse(source);\r\n\t\t\t\r\n\t\t\ttokens.forEach(function(token) {\r\n\t\t\t\ttoken.value = range.create(token).substring(source);\r\n\t\t\t\tswitch (token.type) {\r\n\t\t\t\t\tcase 'tag':\r\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\r\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 'attribute':\r\n\t\t\t\t\t\t// add empty attribute\r\n\t\t\t\t\t\tif (attrToken) {\r\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tattrToken = token;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\r\n\t\t\t\t\t\tattrToken = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\t\r\n\t\t\tif (attrToken) {\r\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._saveStyle();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Remembers all styles of properties\r\n\t\t * @private\r\n\t\t */\r\n\t\t_saveStyle: function() {\r\n\t\t\tvar start = this.nameRange().end;\r\n\t\t\tvar source = this.source;\r\n\t\t\t\r\n\t\t\tthis.list().forEach(function(p) {\r\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\r\n\t\t\t\t\r\n\t\t\t\tif (p.valuePosition() !== -1) {\r\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstart = p.range().end;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new attribute \r\n\t\t * @param {String} name Property name\r\n\t\t * @param {String} value Property value\r\n\t\t * @param {Number} pos Position at which to insert new property. By \r\n\t\t * default the property is inserted at the end of rule \r\n\t\t */\r\n\t\tadd: function(name, value, pos) {\r\n\t\t\tvar list = this.list();\r\n\t\t\tvar start = this.nameRange().end;\r\n\t\t\tvar styles = utils.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\r\n\t\t\t\r\n\t\t\tif (typeof pos === 'undefined') {\r\n\t\t\t\tpos = list.length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t/** @type XMLEditAttribute */\r\n\t\t\tvar donor = list[pos];\r\n\t\t\tif (donor) {\r\n\t\t\t\tstart = donor.fullRange().start;\r\n\t\t\t} else if ((donor = list[pos - 1])) {\r\n\t\t\t\tstart = donor.range().end;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (donor) {\r\n\t\t\t\tstyles = utils.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\r\n\t\t\t\r\n\t\t\tvar attribute = new XMLEditElement(this, \r\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\r\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \r\n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\r\n\t\t\t\t\t);\r\n\t\t\t\r\n\t\t\tutils.extend(attribute, styles);\r\n\t\t\t\r\n\t\t\t// write new attribute into the source\r\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\r\n\t\t\t\r\n\t\t\t// insert new attribute\r\n\t\t\tthis._children.splice(pos, 0, attribute);\r\n\t\t\treturn attribute;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A special case of attribute editing: adds class value to existing\r\n\t\t * `class` attribute\r\n\t\t * @param {String} value\r\n\t\t */\r\n\t\taddClass: function(value) {\r\n\t\t\tvar attr = this.get('class');\r\n\t\t\tvalue = utils.trim(value);\r\n\t\t\tif (!attr) {\r\n\t\t\t\treturn this.add('class', value);\r\n\t\t\t}\r\n\r\n\t\t\tvar classVal = attr.value();\r\n\t\t\tvar classList = ' ' + classVal.replace(/\\n/g, ' ') + ' ';\r\n\t\t\tif (!~classList.indexOf(' ' + value + ' ')) {\r\n\t\t\t\tattr.value(classVal + ' ' + value);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * A special case of attribute editing: removes class value from existing\r\n\t\t * `class` attribute\r\n\t\t * @param {String} value\r\n\t\t */\r\n\t\tremoveClass: function(value) {\r\n\t\t\tvar attr = this.get('class');\r\n\t\t\tvalue = utils.trim(value);\r\n\t\t\tif (!attr) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar reClass = new RegExp('(^|\\\\s+)' + utils.escapeForRegexp(value));\r\n\t\t\tvar classVal = attr.value().replace(reClass, '');\r\n\t\t\tif (!utils.trim(classVal)) {\r\n\t\t\t\tthis.remove('class');\r\n\t\t\t} else {\r\n\t\t\t\tattr.value(classVal);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\t\r\n\tvar XMLEditElement = editTree.EditElement.extend({\r\n\t\tinitialize: function(parent, nameToken, valueToken) {\r\n\t\t\tthis.styleBefore = parent.options.styleBefore;\r\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\r\n\t\t\t\r\n\t\t\tvar value = '', quote = parent.options.styleQuote;\r\n\t\t\tif (valueToken) {\r\n\t\t\t\tvalue = valueToken.value;\r\n\t\t\t\tquote = value.charAt(0);\r\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\r\n\t\t\t\t\tvalue = value.substring(1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tquote = '';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\r\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.styleQuote = quote;\r\n\t\t\t\r\n\t\t\tthis._value = value;\r\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns full rule range, with indentation\r\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\r\n\t\t * rule offset)\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\tfullRange: function(isAbsolute) {\r\n\t\t\tvar r = this.range(isAbsolute);\r\n\t\t\tr.start -= this.styleBefore.length;\r\n\t\t\treturn r;\r\n\t\t},\r\n\t\t\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.name() + this.styleSeparator\r\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Parses HTML element into editable tree\r\n\t\t * @param {String} source\r\n\t\t * @param {Object} options\r\n\t\t * @memberOf emmet.htmlEditTree\r\n\t\t * @returns {EditContainer}\r\n\t\t */\r\n\t\tparse: function(source, options) {\r\n\t\t\treturn new XMLEditContainer(source, options);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extract and parse HTML from specified position in <code>content</code> \r\n\t\t * @param {String} content CSS source code\r\n\t\t * @param {Number} pos Character position where to start source code extraction\r\n\t\t * @returns {XMLEditElement}\r\n\t\t */\r\n\t\tparseFromPosition: function(content, pos, isBackward) {\r\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\r\n\t\t\tif (!bounds || !bounds.inside(pos))\r\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\r\n\t\t\t\treturn null;\r\n\t\t\t\r\n\t\t\treturn this.parse(bounds.substring(content), {\r\n\t\t\t\toffset: bounds.start\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \r\n\t\t * <code>pos</code> position\r\n\t\t * @param {String} content\r\n\t\t * @param {Number} pos\r\n\t\t * @param {Boolean} isBackward\r\n\t\t * @returns {Range}\r\n\t\t */\r\n\t\textractTag: function(content, pos, isBackward) {\r\n\t\t\tvar len = content.length, i;\r\n\t\t\t\r\n\t\t\t// max extraction length. I don't think there may be tags larger \r\n\t\t\t// than 2000 characters length\r\n\t\t\tvar maxLen = Math.min(2000, len);\r\n\t\t\t\r\n\t\t\t/** @type Range */\r\n\t\t\tvar r = null;\r\n\t\t\t\r\n\t\t\tvar match = function(pos) {\r\n\t\t\t\tvar m;\r\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\r\n\t\t\t\t\treturn range.create(pos, m[0]);\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// lookup backward, in case we are inside tag already\r\n\t\t\tfor (i = pos; i >= 0; i--) {\r\n\t\t\t\tif ((r = match(i))) break;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (r && (r.inside(pos) || isBackward))\r\n\t\t\t\treturn r;\r\n\t\t\t\r\n\t\t\tif (!r && isBackward)\r\n\t\t\t\treturn null;\r\n\t\t\t\r\n\t\t\t// search forward\r\n\t\t\tfor (i = pos; i < len; i++) {\r\n\t\t\t\tif ((r = match(i)))\r\n\t\t\t\t\treturn r;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../parser/xml\":\"parser\\\\xml.js\",\"../utils/common\":\"utils\\\\common.js\",\"./base\":\"editTree\\\\base.js\"}],\"filter\\\\bem.js\":[function(require,module,exports){\r\n/**\r\n * Filter for aiding of writing elements with complex class names as described\r\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\r\n * automatically inherit block and element names from parent elements and insert\r\n * them into child element classes\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar htmlFilter = require('./html');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar abbreviationUtils = require('../utils/abbreviation');\r\n\tvar utils = require('../utils/common');\r\n\r\n\tprefs.define('bem.elementSeparator', '__', 'Class name’s element separator.');\r\n\tprefs.define('bem.modifierSeparator', '_', 'Class name’s modifier separator.');\r\n\tprefs.define('bem.shortElementPrefix', '-', \r\n\t\t\t'Symbol for describing short “block-element” notation. Class names '\r\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parent‘s '\r\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \r\n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\r\n\t\r\n\tvar shouldRunHtmlFilter = false;\r\n\t\r\n\tfunction getSeparators() {\r\n\t\treturn {\r\n\t\t\telement: prefs.get('bem.elementSeparator'),\r\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * @param {AbbreviationNode} item\r\n\t */\r\n\tfunction bemParse(item) {\r\n\t\tif (abbreviationUtils.isSnippet(item))\r\n\t\t\treturn item;\r\n\t\t\r\n\t\t// save BEM stuff in cache for faster lookups\r\n\t\titem.__bem = {\r\n\t\t\tblock: '',\r\n\t\t\telement: '',\r\n\t\t\tmodifier: ''\r\n\t\t};\r\n\t\t\r\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\r\n\t\t\r\n\t\t// guess best match for block name\r\n\t\tvar reBlockName = /^[a-z]\\-/i;\r\n\t\titem.__bem.block = utils.find(classNames, function(name) {\r\n\t\t\treturn reBlockName.test(name);\r\n\t\t});\r\n\t\t\r\n\t\t// guessing doesn't worked, pick first class name as block name\r\n\t\tif (!item.__bem.block) {\r\n\t\t\treBlockName = /^[a-z]/i;\r\n\t\t\titem.__bem.block = utils.find(classNames, function(name) {\r\n\t\t\t\treturn reBlockName.test(name);\r\n\t\t\t}) || '';\r\n\t\t}\r\n\r\n\t\tclassNames = classNames.map(function(name) {\r\n\t\t\treturn processClassName(name, item);\r\n\t\t});\r\n\r\n\t\tclassNames = utils.unique(utils.flatten(classNames)).join(' ');\r\n\t\tif (classNames) {\r\n\t\t\titem.attribute('class', classNames);\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param {String} className\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeClassName(className) {\r\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\r\n\t\t\r\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\r\n\t\tif (shortSymbol) {\r\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\r\n\t\t\tclassName = className.replace(re, function(str, p1) {\r\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn utils.trim(className);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes class name\r\n\t * @param {String} name Class name item to process\r\n\t * @param {AbbreviationNode} item Host node for provided class name\r\n\t * @returns Processed class name. May return <code>Array</code> of\r\n\t * class names \r\n\t */\r\n\tfunction processClassName(name, item) {\r\n\t\tname = transformClassName(name, item, 'element');\r\n\t\tname = transformClassName(name, item, 'modifier');\r\n\t\t\r\n\t\t// expand class name\r\n\t\t// possible values:\r\n\t\t// * block__element\r\n\t\t// * block__element_modifier\r\n\t\t// * block__element_modifier1_modifier2\r\n\t\t// * block_modifier\r\n\t\tvar block = '', element = '', modifier = '';\r\n\t\tvar separators = getSeparators();\r\n\t\tif (~name.indexOf(separators.element)) {\r\n\t\t\tvar elements = name.split(separators.element);\r\n\t\t\tblock = elements.shift();\r\n\r\n\t\t\tvar modifiers = elements.pop().split(separators.modifier);\r\n\t\t\telements.push(modifiers.shift());\r\n\t\t\telement = elements.join(separators.element);\r\n\t\t\tmodifier = modifiers.join(separators.modifier);\r\n\t\t} else if (~name.indexOf(separators.modifier)) {\r\n\t\t\tvar blockModifiers = name.split(separators.modifier);\r\n\t\t\t\r\n\t\t\tblock = blockModifiers.shift();\r\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\r\n\t\t}\r\n\t\t\r\n\t\tif (block || element || modifier) {\r\n\t\t\tif (!block) {\r\n\t\t\t\tblock = item.__bem.block;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// inherit parent bem element, if exists\r\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\r\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\r\n\t\t\t\r\n\t\t\t// produce multiple classes\r\n\t\t\tvar prefix = block;\r\n\t\t\tvar result = [];\r\n\t\t\t\r\n\t\t\tif (element) {\r\n\t\t\t\tprefix += separators.element + element;\r\n\t\t\t\tresult.push(prefix);\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(prefix);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (modifier) {\r\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!item.__bem.block || modifier) {\r\n\t\t\t\titem.__bem.block = block;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\titem.__bem.element = element;\r\n\t\t\titem.__bem.modifier = modifier;\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t}\r\n\t\t\r\n\t\t// ...otherwise, return processed or original class name\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Low-level function to transform user-typed class name into full BEM class\r\n\t * @param {String} name Class name item to process\r\n\t * @param {AbbreviationNode} item Host node for provided class name\r\n\t * @param {String} entityType Type of entity to be tried to transform \r\n\t * ('element' or 'modifier')\r\n\t * @returns {String} Processed class name or original one if it can't be\r\n\t * transformed\r\n\t */\r\n\tfunction transformClassName(name, item, entityType) {\r\n\t\tvar separators = getSeparators();\r\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\r\n\t\tif (reSep.test(name)) {\r\n\t\t\tvar depth = 0; // parent lookup depth\r\n\t\t\tvar cleanName = name.replace(reSep, function(str) {\r\n\t\t\t\tdepth = str.length / separators[entityType].length;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// find donor element\r\n\t\t\tvar donor = item;\r\n\t\t\twhile (donor.parent && depth--) {\r\n\t\t\t\tdonor = donor.parent;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!donor || !donor.__bem)\r\n\t\t\t\tdonor = item;\r\n\t\t\t\r\n\t\t\tif (donor && donor.__bem) {\r\n\t\t\t\tvar prefix = donor.__bem.block;\r\n\t\t\t\t\r\n\t\t\t\t// decide if we should inherit element name\r\n//\t\t\t\tif (entityType == 'element') {\r\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\r\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\r\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\r\n//\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\r\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\r\n\t\t\t\t\r\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Recursive function for processing tags, which extends class names \r\n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\r\n\t * <br><br>\r\n\t * It does several things:<br>\r\n\t * <ul>\r\n\t * <li>Expands complex class name (according to BEM symbol semantics):\r\n\t * .block__elem_modifier → .block.block__elem.block__elem_modifier\r\n\t * </li>\r\n\t * <li>Inherits block name on child elements: \r\n\t * .b-block > .__el > .__el → .b-block > .b-block__el > .b-block__el__el\r\n\t * </li>\r\n\t * <li>Treats first dash symbol as '__'</li>\r\n\t * <li>Double underscore (or typographic '–') is also treated as an element \r\n\t * level lookup, e.g. ____el will search for element definition in parent’s \r\n\t * parent element:\r\n\t * .b-block > .__el1 > .____el2 → .b-block > .b-block__el1 > .b-block__el2\r\n\t * </li>\r\n\t * </ul>\r\n\t * \r\n\t * @param {AbbreviationNode} tree\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction process(tree, profile) {\r\n\t\tif (tree.name) {\r\n\t\t\tbemParse(tree, profile);\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tprocess(item, profile);\r\n\t\t\tif (!abbreviationUtils.isSnippet(item) && item.start) {\r\n\t\t\t\tshouldRunHtmlFilter = true;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn function(tree, profile) {\r\n\t\tshouldRunHtmlFilter = false;\r\n\t\ttree = process(tree, profile);\r\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\r\n\t\t// to update output\r\n\t\tif (shouldRunHtmlFilter) {\r\n\t\t\ttree = htmlFilter(tree, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./html\":\"filter\\\\html.js\"}],\"filter\\\\comment.js\":[function(require,module,exports){\r\n/**\r\n * Comment important tags (with 'id' and 'class' attributes)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar utils = require('../utils/common');\r\n\tvar template = require('../utils/template');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar filterCore = require('./main');\r\n\t\r\n\tprefs.define('filter.commentAfter', \r\n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\r\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\r\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\r\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\r\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\r\n\t\t\t+ 'the following properties and functions are availabe:\\n'\r\n\t\t\t+ '<ul>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>attr(name, before, after)</code> – a function that outputs' \r\n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \r\n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \r\n\t\t\t+ 'empty string will be returned.</li>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>node</code> – current node (instance of <code>AbbreviationNode</code>)</li>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>name</code> – name of current tag</li>'\r\n\t\t\t\r\n\t\t\t+ '<li><code>padding</code> – current string padding, can be used ' \r\n\t\t\t+ 'for formatting</li>'\r\n\t\t\t\r\n\t\t\t+'</ul>');\r\n\t\r\n\tprefs.define('filter.commentBefore', \r\n\t\t\t'',\r\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\r\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\r\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\r\n\t\t\t+ 'property');\r\n\t\r\n\tprefs.define('filter.commentTrigger', 'id, class',\r\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\r\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\r\n\t\t\t+ 'every element, set this option to <code>*</code>');\r\n\t\r\n\t/**\r\n\t * Add comments to tag\r\n\t * @param {AbbreviationNode} node\r\n\t */\r\n\tfunction addComments(node, templateBefore, templateAfter) {\r\n\t\t// check if comments should be added\r\n\t\tvar trigger = prefs.get('filter.commentTrigger');\r\n\t\tif (trigger != '*') {\r\n\t\t\tvar shouldAdd = utils.find(trigger.split(','), function(name) {\r\n\t\t\t\treturn !!node.attribute(utils.trim(name));\r\n\t\t\t});\r\n\r\n\t\t\tif (!shouldAdd) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar ctx = {\r\n\t\t\tnode: node,\r\n\t\t\tname: node.name(),\r\n\t\t\tpadding: node.parent ? node.parent.padding : '',\r\n\t\t\tattr: function(name, before, after) {\r\n\t\t\t\tvar attr = node.attribute(name);\r\n\t\t\t\tif (attr) {\r\n\t\t\t\t\treturn (before || '') + attr + (after || '');\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tvar nodeBefore = templateBefore ? templateBefore(ctx) : '';\r\n\t\tvar nodeAfter = templateAfter ? templateAfter(ctx) : '';\r\n\t\t\r\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\r\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\r\n\t}\r\n\t\r\n\tfunction process(tree, before, after) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (abbrUtils.isBlock(item)) {\r\n\t\t\t\taddComments(item, before, after);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, before, after);\r\n\t\t});\r\n\t\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn function(tree) {\r\n\t\tvar templateBefore = template(prefs.get('filter.commentBefore'));\r\n\t\tvar templateAfter = template(prefs.get('filter.commentAfter'));\r\n\t\t\r\n\t\treturn process(tree, templateBefore, templateAfter);\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/template\":\"utils\\\\template.js\",\"./main\":\"filter\\\\main.js\"}],\"filter\\\\css.js\":[function(require,module,exports){\r\n/**\r\n * Filter for outputting CSS and alike\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/**\r\n\t * Test if passed item is very first child in parsed tree\r\n\t * @param {AbbreviationNode} item\r\n\t */\r\n\tfunction isVeryFirstChild(item) {\r\n\t\treturn item.parent && !item.parent.parent && !item.index();\r\n\t}\r\n\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false) {\r\n\t\t\t\titem.start = '\\n' + item.start;\r\n\t\t\t}\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{}],\"filter\\\\escape.js\":[function(require,module,exports){\r\n/**\r\n * Filter for escaping unsafe XML characters: <, >, &\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar charMap = {\r\n\t\t'<': '&lt;',\r\n\t\t'>': '&gt;',\r\n\t\t'&': '&amp;'\r\n\t};\r\n\t\r\n\tfunction escapeChars(str) {\r\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\r\n\t\t\treturn charMap[p1];\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\titem.start = escapeChars(item.start);\r\n\t\t\titem.end = escapeChars(item.end);\r\n\t\t\titem.content = escapeChars(item.content);\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{}],\"filter\\\\format.js\":[function(require,module,exports){\r\n/**\r\n * Generic formatting filter: creates proper indentation for each tree node,\r\n * placing \"%s\" placeholder where the actual output should be. You can use\r\n * this filter to preformat tree and then replace %s placeholder to whatever you\r\n * need. This filter should't be called directly from editor as a part \r\n * of abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\tprefs.define('format.noIndentTags', 'html', \r\n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\r\n\t\r\n\tprefs.define('format.forceIndentationForTags', 'body', \r\n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\r\n\r\n\tvar placeholder = '%s';\r\n\t\r\n\t/**\r\n\t * Get indentation for given node\r\n\t * @param {AbbreviationNode} node\r\n\t * @returns {String}\r\n\t */\r\n\tfunction getIndentation(node) {\r\n\t\tvar items = prefs.getArray('format.noIndentTags') || [];\r\n\t\tif (~items.indexOf(node.name())) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t\t\r\n\t\treturn '\\t';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Test if passed node has block-level sibling element\r\n\t * @param {AbbreviationNode} item\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction hasBlockSibling(item) {\r\n\t\treturn item.parent && abbrUtils.hasBlockChildren(item.parent);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Test if passed item is very first child in parsed tree\r\n\t * @param {AbbreviationNode} item\r\n\t */\r\n\tfunction isVeryFirstChild(item) {\r\n\t\treturn item.parent && !item.parent.parent && !item.index();\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if a newline should be added before element\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction shouldAddLineBreak(node, profile) {\r\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\r\n\t\t\treturn true;\r\n\t\t\r\n\t\tif (!node.parent || !profile.inline_break)\r\n\t\t\treturn false;\r\n\t\t\r\n\t\t// check if there are required amount of adjacent inline element\r\n\t\treturn shouldFormatInline(node.parent, profile);\r\n}\r\n\t\r\n\t/**\r\n\t * Need to add newline because <code>item</code> has too many inline children\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction shouldBreakChild(node, profile) {\r\n\t\t// we need to test only one child element, because \r\n\t\t// hasBlockChildren() method will do the rest\r\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\r\n\t}\r\n\t\r\n\tfunction shouldFormatInline(node, profile) {\r\n\t\tvar nodeCount = 0;\r\n\t\treturn !!utils.find(node.children, function(child) {\r\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\r\n\t\t\t\tnodeCount = 0;\r\n\t\t\telse if (abbrUtils.isInline(child))\r\n\t\t\t\tnodeCount++;\r\n\t\t\t\r\n\t\t\tif (nodeCount >= profile.inline_break)\r\n\t\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\t\r\n\tfunction isRoot(item) {\r\n\t\treturn !item.parent;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with matched resource of type <code>snippet</code>\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processSnippet(item, profile) {\r\n\t\titem.start = item.end = '';\r\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\r\n\t\t\t// check if we’re not inside inline element\r\n\t\t\tif (isRoot(item.parent) || !abbrUtils.isInline(item.parent)) {\r\n\t\t\t\titem.start = '\\n' + item.start;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if we should add line breaks inside inline element\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction shouldBreakInsideInline(node, profile) {\r\n\t\tvar hasBlockElems = node.children.some(function(child) {\r\n\t\t\tif (abbrUtils.isSnippet(child))\r\n\t\t\t\treturn false;\r\n\t\t\t\r\n\t\t\treturn !abbrUtils.isInline(child);\r\n\t\t});\r\n\t\t\r\n\t\tif (!hasBlockElems) {\r\n\t\t\treturn shouldFormatInline(node, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\titem.start = item.end = placeholder;\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar nl = '\\n';\r\n\t\tvar indent = getIndentation(item);\r\n\t\t\t\r\n\t\t// formatting output\r\n\t\tif (profile.tag_nl !== false) {\r\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\r\n\t\t\tif (!forceNl) {\r\n\t\t\t\tvar forceIndentTags = prefs.getArray('format.forceIndentationForTags') || [];\r\n\t\t\t\tforceNl = ~forceIndentTags.indexOf(item.name());\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// formatting block-level elements\r\n\t\t\tif (!item.isTextNode()) {\r\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\r\n\t\t\t\t\t// - do not indent the very first element\r\n\t\t\t\t\t// - do not indent first child of a snippet\r\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\r\n\t\t\t\t\t\titem.start = nl + item.start;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\r\n\t\t\t\t\t\titem.end = nl + item.end;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\r\n\t\t\t\t\t\titem.start += nl + indent;\r\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\r\n\t\t\t\t\titem.start = nl + item.start;\r\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\r\n\t\t\t\t\titem.end = nl + item.end;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\titem.padding = indent;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes simplified tree, making it suitable for output as HTML structure\r\n\t * @param {AbbreviationNode} tree\r\n\t * @param {OutputProfile} profile\r\n\t * @param {Number} level Depth level\r\n\t */\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessSnippet(item, profile, level);\r\n\t\t\t} else {\r\n\t\t\t\tprocessTag(item, profile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"filter\\\\haml.js\":[function(require,module,exports){\r\n/**\r\n * Filter for producing HAML code from abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar formatFilter = require('./format');\r\n\r\n\tfunction transformClassName(className) {\r\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\r\n\t}\r\n\r\n\t/**\r\n\t * Condenses all \"data-\" attributes into a single entry.\r\n\t * HAML allows data attributes to be ouputted as a sub-hash\r\n\t * of `:data` key\r\n\t * @param  {Array} attrs\r\n\t * @return {Array}\r\n\t */\r\n\tfunction condenseDataAttrs(attrs) {\r\n\t\tvar out = [], data = null;\r\n\t\tvar reData = /^data-/i;\r\n\t\tattrs.forEach(function(attr) {\r\n\t\t\tif (reData.test(attr.name)) {\r\n\t\t\t\tif (!data) {\r\n\t\t\t\t\tdata = [];\r\n\t\t\t\t\tout.push({\r\n\t\t\t\t\t\tname: 'data',\r\n\t\t\t\t\t\tvalue: data\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.push(utils.extend({}, attr, {name: attr.name.replace(reData, '')}));\r\n\t\t\t} else {\r\n\t\t\t\tout.push(attr);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction stringifyAttrs(attrs, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\treturn '{' + attrs.map(function(attr) {\r\n\t\t\tvar value = attrQuote + attr.value + attrQuote;\r\n\t\t\tif (Array.isArray(attr.value)) {\r\n\t\t\t\tvalue = stringifyAttrs(attr.value, profile);\r\n\t\t\t} else if (attr.isBoolean) {\r\n\t\t\t\tvalue = 'true';\r\n\t\t\t}\r\n\r\n\t\t\treturn ':' + attr.name + ' => ' + value\r\n\t\t}).join(', ') + '}';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates HAML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} tag\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction makeAttributesString(tag, profile) {\r\n\t\tvar attrs = '';\r\n\t\tvar otherAttrs = [];\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\ttag.attributeList().forEach(function(a) {\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tswitch (attrName.toLowerCase()) {\r\n\t\t\t\t// use short notation for ID and CLASS attributes\r\n\t\t\t\tcase 'id':\r\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'class':\r\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t// process other attributes\r\n\t\t\t\tdefault:\r\n\t\t\t\t\totherAttrs.push({\r\n\t\t\t\t\t\tname: attrName,\r\n\t\t\t\t\t\tvalue: a.value || cursor,\r\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (otherAttrs.length) {\r\n\t\t\tattrs += stringifyAttrs(condenseDataAttrs(otherAttrs), profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn attrs;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent)\r\n\t\t\t// looks like it's root element\r\n\t\t\treturn item;\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile);\r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\r\n\t\tvar start= '';\r\n\t\t\t\r\n\t\t// define tag name\r\n\t\tvar tagName = '%' + profile.tagName(item.name());\r\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\r\n\t\t\t// omit div tag\r\n\t\t\ttagName = '';\r\n\t\t\t\r\n\t\titem.end = '';\r\n\t\tstart = tagName + attrs + selfClosing;\r\n\t\tif (item.content && !/^\\s/.test(item.content)) {\r\n\t\t\titem.content = ' ' + item.content;\r\n\t\t}\r\n\t\t\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\tif (!item.children.length && !isUnary)\r\n\t\t\titem.start += cursor;\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\ttree = formatFilter(tree, '_format', profile);\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, profile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\html.js\":[function(require,module,exports){\r\n/**\r\n * Filter that produces HTML tree\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar utils = require('../utils/common');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar formatFilter = require('./format');\r\n\r\n\t/**\r\n\t * Creates HTML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction makeAttributesString(node, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\treturn node.attributeList().map(function(a) {\r\n\t\t\tvar isBoolean = profile.isBoolean(a.name, a.value);\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tvar attrValue = isBoolean ? attrName : a.value;\r\n\t\t\tif (isBoolean && profile.allowCompactBoolean()) {\r\n\t\t\t\treturn ' ' + attrName;\r\n\t\t\t}\r\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (attrValue || cursor) + attrQuote;\r\n\t\t}).join('');\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent) { // looks like it's root element\r\n\t\t\treturn item;\r\n\t\t}\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile); \r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar start = '';\r\n\t\tvar end = '';\r\n\t\t\t\r\n\t\t// define opening and closing tags\r\n\t\tif (!item.isTextNode()) {\r\n\t\t\tvar tagName = profile.tagName(item.name());\r\n\t\t\tif (isUnary) {\r\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\r\n\t\t\t\titem.end = '';\r\n\t\t\t} else {\r\n\t\t\t\tstart = '<' + tagName + attrs + '>';\r\n\t\t\t\tend = '</' + tagName + '>';\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\t// should we put caret placeholder after opening tag?\r\n\t\tif (\r\n\t\t\t\t!item.children.length \r\n\t\t\t\t&& !isUnary \r\n\t\t\t\t&& !~item.content.indexOf(cursor)\r\n\t\t\t\t&& !tabStops.extract(item.content).tabstops.length\r\n\t\t\t) {\r\n\t\t\titem.start += cursor;\r\n\t\t}\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, profile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\ttree = formatFilter(tree, profile, level)\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, profile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, profile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\jade.js\":[function(require,module,exports){\r\n/**\r\n * Filter for producing Jade code from abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar formatFilter = require('./format');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar profile = require('../assets/profile');\r\n\r\n\tvar reNl = /[\\n\\r]/;\r\n\tvar reIndentedText = /^\\s*\\|/;\r\n\tvar reSpace = /^\\s/;\r\n\r\n\tfunction transformClassName(className) {\r\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\r\n\t}\r\n\r\n\tfunction stringifyAttrs(attrs, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\treturn '(' + attrs.map(function(attr) {\r\n\t\t\tif (attr.isBoolean) {\r\n\t\t\t\treturn attr.name;\r\n\t\t\t}\r\n\r\n\t\t\treturn attr.name + '=' + attrQuote + attr.value + attrQuote;\r\n\t\t}).join(', ') + ')';\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates HAML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} tag\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction makeAttributesString(tag, profile) {\r\n\t\tvar attrs = '';\r\n\t\tvar otherAttrs = [];\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\ttag.attributeList().forEach(function(a) {\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tswitch (attrName.toLowerCase()) {\r\n\t\t\t\t// use short notation for ID and CLASS attributes\r\n\t\t\t\tcase 'id':\r\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'class':\r\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t// process other attributes\r\n\t\t\t\tdefault:\r\n\t\t\t\t\totherAttrs.push({\r\n\t\t\t\t\t\tname: attrName,\r\n\t\t\t\t\t\tvalue: a.value || cursor,\r\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (otherAttrs.length) {\r\n\t\t\tattrs += stringifyAttrs(otherAttrs, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn attrs;\r\n\t}\r\n\r\n\tfunction processTagContent(item) {\r\n\t\tif (!item.content) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar content = tabStops.replaceVariables(item.content, function(str, name) {\r\n\t\t\tif (name === 'nl' || name === 'newline') {\r\n\t\t\t\treturn '\\n';\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t});\r\n\r\n\t\tif (reNl.test(content) && !reIndentedText.test(content)) {\r\n\t\t\t// multiline content: pad it with indentation and pipe\r\n\t\t\tvar pad = '| ';\r\n\t\t\titem.content = '\\n' + pad + utils.padString(content, pad);\r\n\t\t} else if (!reSpace.test(content)) {\r\n\t\t\titem.content = ' ' + content;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent)\r\n\t\t\t// looks like it's a root (empty) element\r\n\t\t\treturn item;\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile);\r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\t\t\r\n\t\t// define tag name\r\n\t\tvar tagName = profile.tagName(item.name());\r\n\t\tif (tagName.toLowerCase() == 'div' && attrs && attrs.charAt(0) != '(')\r\n\t\t\t// omit div tag\r\n\t\t\ttagName = '';\r\n\t\t\t\r\n\t\titem.end = '';\r\n\t\tvar start = tagName + attrs;\r\n\t\tprocessTagContent(item);\r\n\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\tif (!item.children.length && !isUnary)\r\n\t\t\titem.start += cursor;\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, curProfile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\t// always format with `xml` profile since\r\n\t\t\t// Jade requires all tags to be on separate lines\r\n\t\t\ttree = formatFilter(tree, profile.get('xml'));\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, curProfile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, curProfile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\jsx.js\":[function(require,module,exports){\r\n/**\r\n * A filter for React.js (JSX):\r\n * ranames attributes like `class` and `for`\r\n * for proper representation in JSX\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar attrMap = {\r\n\t\t'class': 'className',\r\n\t\t'for': 'htmlFor'\r\n\t};\r\n\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\titem._attributes.forEach(function(attr) {\r\n\t\t\t\tif (attr.name in attrMap) {\r\n\t\t\t\t\tattr.name = attrMap[attr.name]\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{}],\"filter\\\\main.js\":[function(require,module,exports){\r\n/**\r\n * Module for handling filters\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar profile = require('../assets/profile');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\t/** List of registered filters */\r\n\tvar registeredFilters = {\r\n\t\thtml: require('./html'),\r\n\t\thaml: require('./haml'),\r\n\t\tjade: require('./jade'),\r\n\t\tjsx: require('./jsx'),\r\n\t\tslim: require('./slim'),\r\n\t\txsl: require('./xsl'),\r\n\t\tcss: require('./css'),\r\n\t\tbem: require('./bem'),\r\n\t\tc: require('./comment'),\r\n\t\te: require('./escape'),\r\n\t\ts: require('./singleLine'),\r\n\t\tt: require('./trim')\r\n\t};\r\n\t\r\n\t/** Filters that will be applied for unknown syntax */\r\n\tvar basicFilters = 'html';\r\n\t\r\n\tfunction list(filters) {\r\n\t\tif (!filters)\r\n\t\t\treturn [];\r\n\t\t\r\n\t\tif (typeof filters === 'string') {\r\n\t\t\treturn filters.split(/[\\|,]/g);\r\n\t\t}\r\n\t\t\r\n\t\treturn filters;\r\n\t}\r\n\t\r\n\treturn  {\r\n\t\t/**\r\n\t\t * Register new filter\r\n\t\t * @param {String} name Filter name\r\n\t\t * @param {Function} fn Filter function\r\n\t\t */\r\n\t\tadd: function(name, fn) {\r\n\t\t\tregisteredFilters[name] = fn;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Apply filters for final output tree\r\n\t\t * @param {AbbreviationNode} tree Output tree\r\n\t\t * @param {Array} filters List of filters to apply. Might be a \r\n\t\t * <code>String</code>\r\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \r\n\t\t * module. Filters defined it profile are not used, <code>profile</code>\r\n\t\t * is passed to filter function\r\n\t\t * @memberOf emmet.filters\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tapply: function(tree, filters, profileName) {\r\n\t\t\tprofileName = profile.get(profileName);\r\n\t\t\t\r\n\t\t\tlist(filters).forEach(function(filter) {\r\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\r\n\t\t\t\tif (name && name in registeredFilters) {\r\n\t\t\t\t\ttree = registeredFilters[name](tree, profileName);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn tree;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Composes list of filters that should be applied to a tree, based on \r\n\t\t * passed data\r\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\r\n\t\t * @param {Object} profile Output profile\r\n\t\t * @param {String} additionalFilters List or pipe-separated\r\n\t\t * string of additional filters to apply\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tcomposeList: function(syntax, profileName, additionalFilters) {\r\n\t\t\tprofileName = profile.get(profileName);\r\n\t\t\tvar filters = list(profileName.filters || resources.findItem(syntax, 'filters') || basicFilters);\r\n\t\t\t\r\n\t\t\tif (profileName.extraFilters) {\r\n\t\t\t\tfilters = filters.concat(list(profileName.extraFilters));\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tif (additionalFilters) {\r\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tif (!filters || !filters.length) {\r\n\t\t\t\t// looks like unknown syntax, apply basic filters\r\n\t\t\t\tfilters = list(basicFilters);\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\treturn filters;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts filter list from abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \r\n\t\t * extracted filters\r\n\t\t */\r\n\t\textract: function(abbr) {\r\n\t\t\tvar filters = '';\r\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\r\n\t\t\t\tfilters = p1;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn [abbr, list(filters)];\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../utils/common\":\"utils\\\\common.js\",\"./bem\":\"filter\\\\bem.js\",\"./comment\":\"filter\\\\comment.js\",\"./css\":\"filter\\\\css.js\",\"./escape\":\"filter\\\\escape.js\",\"./haml\":\"filter\\\\haml.js\",\"./html\":\"filter\\\\html.js\",\"./jade\":\"filter\\\\jade.js\",\"./jsx\":\"filter\\\\jsx.js\",\"./singleLine\":\"filter\\\\singleLine.js\",\"./slim\":\"filter\\\\slim.js\",\"./trim\":\"filter\\\\trim.js\",\"./xsl\":\"filter\\\\xsl.js\"}],\"filter\\\\singleLine.js\":[function(require,module,exports){\r\n/**\r\n * Output abbreviation on a single line (i.e. no line breaks)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar rePad = /^\\s+/;\r\n\tvar reNl = /[\\n\\r]/g;\r\n\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\t// remove padding from item \r\n\t\t\t\titem.start = item.start.replace(rePad, '');\r\n\t\t\t\titem.end = item.end.replace(rePad, '');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// remove newlines \r\n\t\t\titem.start = item.start.replace(reNl, '');\r\n\t\t\titem.end = item.end.replace(reNl, '');\r\n\t\t\titem.content = item.content.replace(reNl, '');\r\n\t\t\t\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n\r\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\"}],\"filter\\\\slim.js\":[function(require,module,exports){\r\n/**\r\n * Filter for producing Jade code from abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\tvar formatFilter = require('./format');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar profile = require('../assets/profile');\r\n\r\n\tvar reNl = /[\\n\\r]/;\r\n\tvar reIndentedText = /^\\s*\\|/;\r\n\tvar reSpace = /^\\s/;\r\n\r\n\tprefs.define('slim.attributesWrapper', 'none', \r\n\t\t'Defines how attributes will be wrapped:' +\r\n\t\t'<ul>' +\r\n\t\t'<li><code>none</code> – no wrapping;</li>' +\r\n\t\t'<li><code>round</code> — wrap attributes with round braces;</li>' +\r\n\t\t'<li><code>square</code> — wrap attributes with round braces;</li>' +\r\n\t\t'<li><code>curly</code> — wrap attributes with curly braces.</li>' +\r\n\t\t'</ul>');\r\n\r\n\tfunction transformClassName(className) {\r\n\t\treturn utils.trim(className).replace(/\\s+/g, '.');\r\n\t}\r\n\r\n\tfunction getAttrWrapper() {\r\n\t\tvar start = ' ', end = '';\r\n\t\tswitch (prefs.get('slim.attributesWrapper')) {\r\n\t\t\tcase 'round':\r\n\t\t\t\tstart = '(';\r\n\t\t\t\tend = ')';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'square':\r\n\t\t\t\tstart = '[';\r\n\t\t\t\tend = ']';\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'curly':\r\n\t\t\t\tstart = '{';\r\n\t\t\t\tend = '}';\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tstart: start,\r\n\t\t\tend: end\r\n\t\t};\r\n\t}\r\n\r\n\tfunction stringifyAttrs(attrs, profile) {\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar attrWrap = getAttrWrapper();\r\n\t\treturn attrWrap.start + attrs.map(function(attr) {\r\n\t\t\tvar value = attrQuote + attr.value + attrQuote;\r\n\t\t\tif (attr.isBoolean) {\r\n\t\t\t\tif (!attrWrap.end) {\r\n\t\t\t\t\tvalue = 'true';\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn attr.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn attr.name + '=' + value;\r\n\t\t}).join(' ') + attrWrap.end;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates HAML attributes string from tag according to profile settings\r\n\t * @param {AbbreviationNode} tag\r\n\t * @param {Object} profile\r\n\t */\r\n\tfunction makeAttributesString(tag, profile) {\r\n\t\tvar attrs = '';\r\n\t\tvar otherAttrs = [];\r\n\t\tvar attrQuote = profile.attributeQuote();\r\n\t\tvar cursor = profile.cursor();\r\n\t\t\r\n\t\ttag.attributeList().forEach(function(a) {\r\n\t\t\tvar attrName = profile.attributeName(a.name);\r\n\t\t\tswitch (attrName.toLowerCase()) {\r\n\t\t\t\t// use short notation for ID and CLASS attributes\r\n\t\t\t\tcase 'id':\r\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'class':\r\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t// process other attributes\r\n\t\t\t\tdefault:\r\n\t\t\t\t\totherAttrs.push({\r\n\t\t\t\t\t\tname: attrName,\r\n\t\t\t\t\t\tvalue: a.value || cursor,\r\n\t\t\t\t\t\tisBoolean: profile.isBoolean(a.name, a.value)\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (otherAttrs.length) {\r\n\t\t\tattrs += stringifyAttrs(otherAttrs, profile);\r\n\t\t}\r\n\t\t\r\n\t\treturn attrs;\r\n\t}\r\n\r\n\tfunction processTagContent(item) {\r\n\t\tif (!item.content) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar content = tabStops.replaceVariables(item.content, function(str, name) {\r\n\t\t\tif (name === 'nl' || name === 'newline') {\r\n\t\t\t\treturn '\\n';\r\n\t\t\t}\r\n\t\t\treturn str;\r\n\t\t});\r\n\r\n\t\tif (reNl.test(content) && !reIndentedText.test(content)) {\r\n\t\t\t// multiline content: pad it with indentation and pipe\r\n\t\t\tvar pad = '  ';\r\n\t\t\titem.content = '\\n| ' + utils.padString(content, pad);\r\n\t\t} else if (!reSpace.test(content)) {\r\n\t\t\titem.content = ' ' + content;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Processes element with <code>tag</code> type\r\n\t * @param {AbbreviationNode} item\r\n\t * @param {OutputProfile} profile\r\n\t */\r\n\tfunction processTag(item, profile) {\r\n\t\tif (!item.parent)\r\n\t\t\t// looks like it's a root (empty) element\r\n\t\t\treturn item;\r\n\t\t\r\n\t\tvar attrs = makeAttributesString(item, profile);\r\n\t\tvar cursor = profile.cursor();\r\n\t\tvar isUnary = abbrUtils.isUnary(item);\r\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\r\n\t\t\t\r\n\t\t// define tag name\r\n\t\tvar tagName = profile.tagName(item.name());\r\n\t\tif (tagName.toLowerCase() == 'div' && attrs && '([{'.indexOf(attrs.charAt(0)) == -1)\r\n\t\t\t// omit div tag\r\n\t\t\ttagName = '';\r\n\t\t\t\r\n\t\titem.end = '';\r\n\t\tvar start = tagName + attrs + selfClosing;\r\n\t\tprocessTagContent(item);\r\n\r\n\t\tvar placeholder = '%s';\r\n\t\t// We can't just replace placeholder with new value because\r\n\t\t// JavaScript will treat double $ character as a single one, assuming\r\n\t\t// we're using RegExp literal.\r\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\r\n\t\t\r\n\t\tif (!item.children.length && !isUnary)\r\n\t\t\titem.start += cursor;\r\n\t\t\r\n\t\treturn item;\r\n\t}\r\n\r\n\treturn function process(tree, curProfile, level) {\r\n\t\tlevel = level || 0;\r\n\t\t\r\n\t\tif (!level) {\r\n\t\t\t// always format with `xml` profile since\r\n\t\t\t// Slim requires all tags to be on separate lines\r\n\t\t\ttree = formatFilter(tree, profile.get('xml'));\r\n\t\t}\r\n\t\t\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)) {\r\n\t\t\t\tprocessTag(item, curProfile, level);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, curProfile, level + 1);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./format\":\"filter\\\\format.js\"}],\"filter\\\\trim.js\":[function(require,module,exports){\r\n/**\r\n * Trim filter: removes characters at the beginning of the text\r\n * content that indicates lists: numbers, #, *, -, etc.\r\n * \r\n * Useful for wrapping lists with abbreviation.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tprefs.define('filter.trimRegexp', \r\n\t\t'[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\r\n\t\t'Regular expression used to remove list markers (numbers, dashes, ' \r\n\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\r\n\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \r\n\t\t+ 'documents (for example, Word documents).');\r\n\t\r\n\tfunction process(tree, re) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (item.content) {\r\n\t\t\t\titem.content = item.content.replace(re, '');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprocess(item, re);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn function(tree) {\r\n\t\tvar re = new RegExp(prefs.get('filter.trimRegexp'));\r\n\t\treturn process(tree, re);\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\"}],\"filter\\\\xsl.js\":[function(require,module,exports){\r\n/**\r\n * Filter for trimming \"select\" attributes from some tags that contains\r\n * child elements\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar abbrUtils = require('../utils/abbreviation');\r\n\r\n\tvar tags = {\r\n\t\t'xsl:variable': 1,\r\n\t\t'xsl:with-param': 1\r\n\t};\r\n\t\r\n\t/**\r\n\t * Removes \"select\" attribute from node\r\n\t * @param {AbbreviationNode} node\r\n\t */\r\n\tfunction trimAttribute(node) {\r\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\r\n\t}\r\n\r\n\treturn function process(tree) {\r\n\t\ttree.children.forEach(function(item) {\r\n\t\t\tif (!abbrUtils.isSnippet(item)\r\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \r\n\t\t\t\t\t&& item.children.length)\r\n\t\t\t\ttrimAttribute(item);\r\n\t\t\tprocess(item);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t};\r\n});\r\n},{\"../utils/abbreviation\":\"utils\\\\abbreviation.js\"}],\"generator\\\\lorem.js\":[function(require,module,exports){\r\n/**\r\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \r\n * <code>lorem(num)?</code> abbreviation.\r\n * This code is based on Django's contribution: \r\n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\r\n * <br><br>\r\n * Examples to test:<br>\r\n * <code>lipsum</code> – generates 30 words text.<br>\r\n * <code>lipsum*6</code> – generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\r\n * <code>ol>lipsum10*5</code> — generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\r\n * with text of 10 words on each line.<br>\r\n * <code>span*3>lipsum20</code> – generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element.\r\n * Each paragraph phrase is unique.   \r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\r\n\tvar langs = {\r\n\t\ten: {\r\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\r\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\r\n\t\t\t\t'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\r\n\t\t\t\t'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\r\n\t\t\t\t'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\r\n\t\t\t\t'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\r\n\t\t\t\t'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\r\n\t\t\t\t'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\r\n\t\t\t\t'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\r\n\t\t\t\t'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\r\n\t\t\t\t'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\r\n\t\t\t\t'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\r\n\t\t\t\t'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\r\n\t\t\t\t'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\r\n\t\t\t\t'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\r\n\t\t\t\t'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\r\n\t\t\t\t'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\r\n\t\t\t\t'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\r\n\t\t\t\t'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\r\n\t\t\t\t'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\r\n\t\t\t\t'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\r\n\t\t\t\t'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\r\n\t\t\t\t'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\r\n\t\t\t\t'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\r\n\t\t\t\t'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\r\n\t\t\t\t'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\r\n\t\t\t\t'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\r\n\t\t\t\t'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\r\n\t\t\t\t'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\r\n\t\t\t\t'maxime', 'corrupti']\r\n\t\t},\r\n\t\tsp: {\r\n\t\t\tcommon: ['mujer', 'uno', 'dolor', 'más', 'de', 'poder', 'mismo', 'si'],\r\n\t\t\twords: ['ejercicio', 'preferencia', 'perspicacia', 'laboral', 'paño',\r\n\t\t\t\t'suntuoso', 'molde', 'namibia', 'planeador', 'mirar', 'demás', 'oficinista', 'excepción',\r\n\t\t\t\t'odio', 'consecuencia', 'casi', 'auto', 'chicharra', 'velo', 'elixir',\r\n\t\t\t\t'ataque', 'no', 'odio', 'temporal', 'cuórum', 'dignísimo',\r\n\t\t\t\t'facilismo', 'letra', 'nihilista', 'expedición', 'alma', 'alveolar', 'aparte',\r\n\t\t\t\t'león', 'animal', 'como', 'paria', 'belleza', 'modo', 'natividad',\r\n\t\t\t\t'justo', 'ataque', 'séquito', 'pillo', 'sed', 'ex', 'y', 'voluminoso',\r\n\t\t\t\t'temporalidad', 'verdades', 'racional', 'asunción', 'incidente', 'marejada',\r\n\t\t\t\t'placenta', 'amanecer', 'fuga', 'previsor', 'presentación', 'lejos',\r\n\t\t\t\t'necesariamente', 'sospechoso', 'adiposidad', 'quindío', 'pócima',\r\n\t\t\t\t'voluble', 'débito', 'sintió', 'accesorio', 'falda', 'sapiencia',\r\n\t\t\t\t'volutas', 'queso', 'permacultura', 'laudo', 'soluciones', 'entero',\r\n\t\t\t\t'pan', 'litro', 'tonelada', 'culpa', 'libertario', 'mosca', 'dictado',\r\n\t\t\t\t'reincidente', 'nascimiento', 'dolor', 'escolar', 'impedimento', 'mínima',\r\n\t\t\t\t'mayores', 'repugnante', 'dulce', 'obcecado', 'montaña', 'enigma',\r\n\t\t\t\t'total', 'deletéreo', 'décima', 'cábala', 'fotografía', 'dolores',\r\n\t\t\t\t'molesto', 'olvido', 'paciencia', 'resiliencia', 'voluntad', 'molestias',\r\n\t\t\t\t'magnífico', 'distinción', 'ovni', 'marejada', 'cerro', 'torre', 'y',\r\n\t\t\t\t'abogada', 'manantial', 'corporal', 'agua', 'crepúsculo', 'ataque', 'desierto',\r\n\t\t\t\t'laboriosamente', 'angustia', 'afortunado', 'alma', 'encefalograma',\r\n\t\t\t\t'materialidad', 'cosas', 'o', 'renuncia', 'error', 'menos', 'conejo',\r\n\t\t\t\t'abadía', 'analfabeto', 'remo', 'fugacidad', 'oficio', 'en', 'almácigo', 'vos', 'pan',\r\n\t\t\t\t'represión', 'números', 'triste', 'refugiado', 'trote', 'inventor',\r\n\t\t\t\t'corchea', 'repelente', 'magma', 'recusado', 'patrón', 'explícito',\r\n\t\t\t\t'paloma', 'síndrome', 'inmune', 'autoinmune', 'comodidad',\r\n\t\t\t\t'ley', 'vietnamita', 'demonio', 'tasmania', 'repeler', 'apéndice',\r\n\t\t\t\t'arquitecto', 'columna', 'yugo', 'computador', 'mula', 'a', 'propósito',\r\n\t\t\t\t'fantasía', 'alias', 'rayo', 'tenedor', 'deleznable', 'ventana', 'cara',\r\n\t\t\t\t'anemia', 'corrupto']\r\n\t\t},\r\n\t\tru: {\r\n\t\t\tcommon: ['далеко-далеко', 'за', 'словесными', 'горами', 'в стране', 'гласных', 'и согласных', 'живут', 'рыбные', 'тексты'],\r\n\t\t\twords: ['вдали', 'от всех', 'они', 'буквенных', 'домах', 'на берегу', 'семантика', \r\n\t\t\t\t'большого', 'языкового', 'океана', 'маленький', 'ручеек', 'даль', \r\n\t\t\t\t'журчит', 'по всей', 'обеспечивает', 'ее','всеми', 'необходимыми', \r\n\t\t\t\t'правилами', 'эта', 'парадигматическая', 'страна', 'которой', 'жаренные', \r\n\t\t\t\t'предложения', 'залетают', 'прямо', 'рот', 'даже', 'всемогущая', \r\n\t\t\t\t'пунктуация', 'не', 'имеет', 'власти', 'над', 'рыбными', 'текстами', \r\n\t\t\t\t'ведущими', 'безорфографичный', 'образ', 'жизни', 'однажды', 'одна', \r\n\t\t\t\t'маленькая', 'строчка','рыбного', 'текста', 'имени', 'lorem', 'ipsum', \r\n\t\t\t\t'решила', 'выйти', 'большой', 'мир', 'грамматики', 'великий', 'оксмокс', \r\n\t\t\t\t'предупреждал', 'о', 'злых', 'запятых', 'диких', 'знаках', 'вопроса', \r\n\t\t\t\t'коварных', 'точках', 'запятой', 'но', 'текст', 'дал', 'сбить', \r\n\t\t\t\t'себя', 'толку', 'он', 'собрал', 'семь', 'своих', 'заглавных', 'букв', \r\n\t\t\t\t'подпоясал', 'инициал', 'за', 'пояс', 'пустился', 'дорогу', \r\n\t\t\t\t'взобравшись', 'первую', 'вершину', 'курсивных', 'гор', 'бросил', \r\n\t\t\t\t'последний', 'взгляд', 'назад', 'силуэт', 'своего', 'родного', 'города', \r\n\t\t\t\t'буквоград', 'заголовок', 'деревни', 'алфавит', 'подзаголовок', 'своего', \r\n\t\t\t\t'переулка', 'грустный', 'реторический', 'вопрос', 'скатился', 'его', \r\n\t\t\t\t'щеке', 'продолжил', 'свой', 'путь', 'дороге', 'встретил', 'рукопись', \r\n\t\t\t\t'она', 'предупредила',  'моей', 'все', 'переписывается', 'несколько', \r\n\t\t\t\t'раз', 'единственное', 'что', 'меня', 'осталось', 'это', 'приставка', \r\n\t\t\t\t'возвращайся', 'ты', 'лучше', 'свою', 'безопасную', 'страну', 'послушавшись', \r\n\t\t\t\t'рукописи', 'наш', 'продолжил', 'свой', 'путь', 'вскоре', 'ему', \r\n\t\t\t\t'повстречался', 'коварный', 'составитель', 'рекламных', 'текстов', \r\n\t\t\t\t'напоивший', 'языком', 'речью', 'заманивший', 'свое', 'агентство', \r\n\t\t\t\t'которое', 'использовало', 'снова', 'снова', 'своих', 'проектах', \r\n\t\t\t\t'если', 'переписали', 'то', 'живет', 'там', 'до', 'сих', 'пор']\r\n\t\t}\r\n\t};\r\n\r\n\t\r\n\tprefs.define('lorem.defaultLang', 'en', \r\n\t\t'Default language of generated dummy text. Currently, <code>en</code>\\\r\n\t\tand <code>ru</code> are supported, but users can add their own syntaxes\\\r\n\t\tsee <a href=\"http://docs.emmet.io/abbreviations/lorem-ipsum/\">docs</a>.');\r\n\tprefs.define('lorem.omitCommonPart', false,\r\n\t\t'Omit commonly used part (e.g. “Lorem ipsum dolor sit amet“) from generated text.');\r\n\t\r\n\t/**\r\n\t * Returns random integer between <code>from</code> and <code>to</code> values\r\n\t * @param {Number} from\r\n\t * @param {Number} to\r\n\t * @returns {Number}\r\n\t */\r\n\tfunction randint(from, to) {\r\n\t\treturn Math.round(Math.random() * (to - from) + from);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param {Array} arr\r\n\t * @param {Number} count\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction sample(arr, count) {\r\n\t\tvar len = arr.length;\r\n\t\tvar iterations = Math.min(len, count);\r\n\t\tvar result = [];\r\n\t\twhile (result.length < iterations) {\r\n\t\t\tvar randIx = randint(0, len - 1);\r\n\t\t\tif (!~result.indexOf(randIx)) {\r\n\t\t\t\tresult.push(randIx);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result.map(function(ix) {\r\n\t\t\treturn arr[ix];\r\n\t\t});\r\n\t}\r\n\t\r\n\tfunction choice(val) {\r\n\t\tif (typeof val === 'string')\r\n\t\t\treturn val.charAt(randint(0, val.length - 1));\r\n\t\t\r\n\t\treturn val[randint(0, val.length - 1)];\r\n\t}\r\n\t\r\n\tfunction sentence(words, end) {\r\n\t\tif (words.length) {\r\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\r\n\t\t}\r\n\t\t\r\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots than question marks\r\n\t}\r\n\t\r\n\t/**\r\n\t * Insert commas at randomly selected words. This function modifies values\r\n\t * inside <code>words</code> array \r\n\t * @param {Array} words\r\n\t */\r\n\tfunction insertCommas(words) {\r\n\t\tvar len = words.length;\r\n\r\n\t\tif (len < 2) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar totalCommas = 0;\r\n\t\tif (len > 3 && len <= 6) {\r\n\t\t\ttotalCommas = randint(0, 1);\r\n\t\t} else if (len > 6 && len <= 12) {\r\n\t\t\ttotalCommas = randint(0, 2);\r\n\t\t} else {\r\n\t\t\ttotalCommas = randint(1, 4);\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, pos, word; i < totalCommas; i++) {\r\n\t\t\tpos = randint(0, words.length - 2);\r\n\t\t\tword = words[pos];\r\n\t\t\tif (word.charAt(word.length - 1) !== ',') {\r\n\t\t\t\twords[pos] += ',';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Generate a paragraph of \"Lorem ipsum\" text\r\n\t * @param {Number} wordCount Words count in paragraph\r\n\t * @param {Boolean} startWithCommon Should paragraph start with common \r\n\t * \"lorem ipsum\" sentence.\r\n\t * @returns {String}\r\n\t */\r\n\tfunction paragraph(lang, wordCount, startWithCommon) {\r\n\t\tvar data = langs[lang];\r\n\t\tif (!data) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tvar result = [];\r\n\t\tvar totalWords = 0;\r\n\t\tvar words;\r\n\t\t\r\n\t\twordCount = parseInt(wordCount, 10);\r\n\t\t\r\n\t\tif (startWithCommon && data.common) {\r\n\t\t\twords = data.common.slice(0, wordCount);\r\n\t\t\tif (words.length > 5) {\r\n\t\t\t\twords[4] += ',';\r\n\t\t\t}\r\n\t\t\ttotalWords += words.length;\r\n\t\t\tresult.push(sentence(words, '.'));\r\n\t\t}\r\n\t\t\r\n\t\twhile (totalWords < wordCount) {\r\n\t\t\twords = sample(data.words, Math.min(randint(2, 30), wordCount - totalWords));\r\n\t\t\ttotalWords += words.length;\r\n\t\t\tinsertCommas(words);\r\n\t\t\tresult.push(sentence(words));\r\n\t\t}\r\n\t\t\r\n\t\treturn result.join(' ');\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Adds new language words for Lorem Ipsum generator\r\n\t\t * @param {String} lang Two-letter lang definition\r\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \r\n\t\t * list of words (String), Array of words or object with <code>text</code> and\r\n\t\t * <code>common</code> properties\r\n\t\t */\r\n\t\taddLang: function(lang, data) {\r\n\t\t\tif (typeof data === 'string') {\r\n\t\t\t\tdata = {\r\n\t\t\t\t\twords: data.split(' ').filter(function(item) {\r\n\t\t\t\t\t\treturn !!item;\r\n\t\t\t\t\t})\r\n\t\t\t\t};\r\n\t\t\t} else if (Array.isArray(data)) {\r\n\t\t\t\tdata = {words: data};\r\n\t\t\t}\r\n\r\n\t\t\tlangs[lang] = data;\r\n\t\t},\r\n\t\tpreprocessor: function(tree) {\r\n\t\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\r\n\t\t\tvar allowCommon = !prefs.get('lorem.omitCommonPart');\r\n\t\t\t\r\n\t\t\t/** @param {AbbreviationNode} node */\r\n\t\t\ttree.findAll(function(node) {\r\n\t\t\t\tif (node._name && (match = node._name.match(re))) {\r\n\t\t\t\t\tvar wordCound = match[2] || 30;\r\n\t\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\r\n\t\t\t\t\t\r\n\t\t\t\t\t// force node name resolving if node should be repeated\r\n\t\t\t\t\t// or contains attributes. In this case, node should be outputed\r\n\t\t\t\t\t// as tag, otherwise as text-only node\r\n\t\t\t\t\tnode._name = '';\r\n\t\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\r\n\t\t\t\t\tnode.data('pasteOverwrites', true);\r\n\t\t\t\t\tnode.data('paste', function(i) {\r\n\t\t\t\t\t\treturn paragraph(lang, wordCound, !i && allowCommon);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\"}],\"parser\\\\abbreviation.js\":[function(require,module,exports){\r\n/**\r\n * Emmet abbreviation parser.\r\n * Takes string abbreviation and recursively parses it into a tree. The parsed \r\n * tree can be transformed into a string representation with \r\n * <code>toString()</code> method. Note that string representation is defined\r\n * by custom processors (called <i>filters</i>), not by abbreviation parser \r\n * itself.\r\n * \r\n * This module can be extended with custom pre-/post-processors to shape-up\r\n * final tree or its representation. Actually, many features of abbreviation \r\n * engine are defined in other modules as tree processors\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar profile = require('../assets/profile');\r\n\tvar filters = require('../filter/main');\r\n\tvar utils = require('../utils/common');\r\n\tvar abbreviationUtils = require('../utils/abbreviation');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\r\n\t// pre- and post-processorcs\r\n\tvar lorem = require('../generator/lorem');\r\n\tvar procPastedContent = require('./processor/pastedContent');\r\n\tvar procTagName = require('./processor/tagName');\r\n\tvar procResourceMatcher = require('./processor/resourceMatcher');\r\n\tvar procAttributes = require('./processor/attributes');\r\n\tvar procHref = require('./processor/href');\r\n\r\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\r\n\tvar reWord = /[\\w\\-:\\$@]/;\r\n\tvar DEFAULT_ATTR_NAME = '%default';\r\n\t\r\n\tvar pairs = {\r\n\t\t'[': ']',\r\n\t\t'(': ')',\r\n\t\t'{': '}'\r\n\t};\r\n\t\r\n\tvar spliceFn = Array.prototype.splice;\r\n\t\r\n\tvar preprocessors = [];\r\n\tvar postprocessors = [];\r\n\tvar outputProcessors = [];\r\n\t\r\n\t/**\r\n\t * @type AbbreviationNode\r\n\t */\r\n\tfunction AbbreviationNode(parent) {\r\n\t\t/** @type AbbreviationNode */\r\n\t\tthis.parent = null;\r\n\t\tthis.children = [];\r\n\t\tthis._attributes = [];\r\n\t\t\r\n\t\t/** @type String Raw abbreviation for current node */\r\n\t\tthis.abbreviation = '';\r\n\t\tthis.counter = 1;\r\n\t\tthis._name = null;\r\n\t\tthis._text = '';\r\n\t\tthis.repeatCount = 1;\r\n\t\tthis.hasImplicitRepeat = false;\r\n\t\t\r\n\t\t/** Custom data dictionary */\r\n\t\tthis._data = {};\r\n\t\t\r\n\t\t// output properties\r\n\t\tthis.start = '';\r\n\t\tthis.end = '';\r\n\t\tthis.content = '';\r\n\t\tthis.padding = '';\r\n\t}\r\n\t\r\n\tAbbreviationNode.prototype = {\r\n\t\t/**\r\n\t\t * Adds passed node as child or creates new child\r\n\t\t * @param {AbbreviationNode} child\r\n\t\t * @param {Number} position Index in children array where child should \r\n\t\t * be inserted\r\n\t\t * @return {AbbreviationNode}\r\n\t\t */\r\n\t\taddChild: function(child, position) {\r\n\t\t\tchild = child || new AbbreviationNode();\r\n\t\t\tchild.parent = this;\r\n\t\t\t\r\n\t\t\tif (typeof position === 'undefined') {\r\n\t\t\t\tthis.children.push(child);\r\n\t\t\t} else {\r\n\t\t\t\tthis.children.splice(position, 0, child);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn child;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Creates a deep copy of current node\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tclone: function() {\r\n\t\t\tvar node = new AbbreviationNode();\r\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\r\n\t\t\tattrs.forEach(function(a) {\r\n\t\t\t\tnode[a] = this[a];\r\n\t\t\t}, this);\r\n\t\t\t\r\n\t\t\t// clone attributes\r\n\t\t\tnode._attributes = this._attributes.map(function(attr) {\r\n\t\t\t\treturn utils.extend({}, attr);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tnode._data = utils.extend({}, this._data);\r\n\t\t\t\r\n\t\t\t// clone children\r\n\t\t\tnode.children = this.children.map(function(child) {\r\n\t\t\t\tchild = child.clone();\r\n\t\t\t\tchild.parent = node;\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn node;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes current node from parent‘s child list\r\n\t\t * @returns {AbbreviationNode} Current node itself\r\n\t\t */\r\n\t\tremove: function() {\r\n\t\t\tif (this.parent) {\r\n\t\t\t\tvar ix = this.parent.children.indexOf(this);\r\n\t\t\t\tif (~ix) {\r\n\t\t\t\t\tthis.parent.children.splice(ix, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replaces current node in parent‘s children list with passed nodes\r\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\r\n\t\t */\r\n\t\treplace: function() {\r\n\t\t\tvar parent = this.parent;\r\n\t\t\tvar ix = parent.children.indexOf(this);\r\n\t\t\tvar items = utils.flatten(arguments);\r\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\r\n\t\t\t\r\n\t\t\t// update parent\r\n\t\t\titems.forEach(function(item) {\r\n\t\t\t\titem.parent = parent;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\r\n\t\t * node and its children \r\n\t\t * @param {String} name Property to update\r\n\t\t * @param {Object} value New property value\r\n\t\t */\r\n\t\tupdateProperty: function(name, value) {\r\n\t\t\tthis[name] = value;\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tchild.updateProperty(name, value);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds first child node that matches truth test for passed \r\n\t\t * <code>fn</code> function\r\n\t\t * @param {Function} fn\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tfind: function(fn) {\r\n\t\t\treturn this.findAll(fn, {amount: 1})[0];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Finds all child nodes that matches truth test for passed \r\n\t\t * <code>fn</code> function\r\n\t\t * @param {Function} fn\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tfindAll: function(fn, state) {\r\n\t\t\tstate = utils.extend({amount: 0, found: 0}, state || {});\r\n\r\n\t\t\tif (typeof fn !== 'function') {\r\n\t\t\t\tvar elemName = fn.toLowerCase();\r\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tvar result = [];\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tif (fn(child)) {\r\n\t\t\t\t\tresult.push(child);\r\n\t\t\t\t\tstate.found++;\r\n\t\t\t\t\tif (state.amount && state.found >= state.amount) {\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tresult = result.concat(child.findAll(fn));\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn result.filter(function(item) {\r\n\t\t\t\treturn !!item;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets/gets custom data\r\n\t\t * @param {String} name\r\n\t\t * @param {Object} value\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tdata: function(name, value) {\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tthis._data[name] = value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this._data[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns name of current node\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tname: function() {\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns list of attributes for current node\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tattributeList: function() {\r\n\t\t\treturn optimizeAttributes(this._attributes.slice(0));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns or sets attribute value\r\n\t\t * @param {String} name Attribute name\r\n\t\t * @param {String} value New attribute value. `Null` value \r\n\t\t * will remove attribute\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tattribute: function(name, value) {\r\n\t\t\tif (arguments.length == 2) {\r\n\t\t\t\tif (value === null) {\r\n\t\t\t\t\t// remove attribute\r\n\t\t\t\t\tvar vals = this._attributes.filter(function(attr) {\r\n\t\t\t\t\t\treturn attr.name === name;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tvar that = this;\r\n\t\t\t\t\tvals.forEach(function(attr) {\r\n\t\t\t\t\t\tvar ix = that._attributes.indexOf(attr);\r\n\t\t\t\t\t\tif (~ix) {\r\n\t\t\t\t\t\t\tthat._attributes.splice(ix, 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// modify attribute\r\n\t\t\t\tvar attrNames = this._attributes.map(function(attr) {\r\n\t\t\t\t\treturn attr.name;\r\n\t\t\t\t});\r\n\t\t\t\tvar ix = attrNames.indexOf(name.toLowerCase());\r\n\t\t\t\tif (~ix) {\r\n\t\t\t\t\tthis._attributes[ix].value = value;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis._attributes.push({\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn (utils.find(this.attributeList(), function(attr) {\r\n\t\t\t\treturn attr.name == name;\r\n\t\t\t}) || {}).value;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns index of current node in parent‘s children list\r\n\t\t * @returns {Number}\r\n\t\t */\r\n\t\tindex: function() {\r\n\t\t\treturn this.parent ? this.parent.children.indexOf(this) : -1;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets how many times current element should be repeated\r\n\t\t * @private\r\n\t\t */\r\n\t\t_setRepeat: function(count) {\r\n\t\t\tif (count) {\r\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\r\n\t\t\t} else {\r\n\t\t\t\tthis.hasImplicitRepeat = true;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets abbreviation that belongs to current node\r\n\t\t * @param {String} abbr\r\n\t\t */\r\n\t\tsetAbbreviation: function(abbr) {\r\n\t\t\tabbr = abbr || '';\r\n\t\t\t\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\t// find multiplier\r\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\r\n\t\t\t\tthat._setRepeat(repeatCount);\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tthis.abbreviation = abbr;\r\n\t\t\t\r\n\t\t\tvar abbrText = extractText(abbr);\r\n\t\t\tif (abbrText) {\r\n\t\t\t\tabbr = abbrText.element;\r\n\t\t\t\tthis.content = this._text = abbrText.text;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\r\n\t\t\tif (abbrAttrs) {\r\n\t\t\t\tabbr = abbrAttrs.element;\r\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis._name = abbr;\r\n\t\t\t\r\n\t\t\t// validate name\r\n\t\t\tif (this._name && !reValidName.test(this._name)) {\r\n\t\t\t\tthrow new Error('Invalid abbreviation');\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns string representation of current node\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tvalueOf: function() {\r\n\t\t\tvar start = this.start;\r\n\t\t\tvar end = this.end;\r\n\t\t\tvar content = this.content;\r\n\t\t\t\r\n\t\t\t// apply output processors\r\n\t\t\tvar node = this;\r\n\t\t\toutputProcessors.forEach(function(fn) {\r\n\t\t\t\tstart = fn(start, node, 'start');\r\n\t\t\t\tcontent = fn(content, node, 'content');\r\n\t\t\t\tend = fn(end, node, 'end');\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tvar innerContent = this.children.map(function(child) {\r\n\t\t\t\treturn child.valueOf();\r\n\t\t\t}).join('');\r\n\t\t\t\r\n\t\t\tcontent = abbreviationUtils.insertChildContent(content, innerContent, {\r\n\t\t\t\tkeepVariable: false\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn start + utils.padString(content, this.padding) + end;\r\n\t\t},\r\n\r\n\t\ttoString: function() {\r\n\t\t\treturn this.valueOf();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current node contains children with empty <code>expr</code>\r\n\t\t * property\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\thasEmptyChildren: function() {\r\n\t\t\treturn !!utils.find(this.children, function(child) {\r\n\t\t\t\treturn child.isEmpty();\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current node has implied name that should be resolved\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\thasImplicitName: function() {\r\n\t\t\treturn !this._name && !this.isTextNode();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates that current element is a grouping one, e.g. has no \r\n\t\t * representation but serves as a container for other nodes\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisGroup: function() {\r\n\t\t\treturn !this.abbreviation;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \r\n\t\t * grouping node and should not be outputted\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisEmpty: function() {\r\n\t\t\treturn !this.abbreviation && !this.children.length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates that current node should be repeated\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisRepeating: function() {\r\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current node is a text-only node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisTextNode: function() {\r\n\t\t\treturn !this.name() && !this.attributeList().length;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indicates whether this node may be used to build elements or snippets\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisElement: function() {\r\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns latest and deepest child of current tree\r\n\t\t * @returns {AbbreviationNode}\r\n\t\t */\r\n\t\tdeepestChild: function() {\r\n\t\t\tif (!this.children.length)\r\n\t\t\t\treturn null;\r\n\t\t\t\t\r\n\t\t\tvar deepestChild = this;\r\n\t\t\twhile (deepestChild.children.length) {\r\n\t\t\t\tdeepestChild = deepestChild.children[deepestChild.children.length - 1];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn deepestChild;\r\n\t\t}\r\n\t};\r\n\t\r\n\t/**\r\n\t * Returns stripped string: a string without first and last character.\r\n\t * Used for “unquoting” strings\r\n\t * @param {String} str\r\n\t * @returns {String}\r\n\t */\r\n\tfunction stripped(str) {\r\n\t\treturn str.substring(1, str.length - 1);\r\n\t}\r\n\t\r\n\tfunction consumeQuotedValue(stream, quote) {\r\n\t\tvar ch;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (ch === quote)\r\n\t\t\t\treturn true;\r\n\t\t\t\r\n\t\t\tif (ch == '\\\\')\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parses abbreviation into a tree\r\n\t * @param {String} abbr\r\n\t * @returns {AbbreviationNode}\r\n\t */\r\n\tfunction parseAbbreviation(abbr) {\r\n\t\tabbr = utils.trim(abbr);\r\n\t\t\r\n\t\tvar root = new AbbreviationNode();\r\n\t\tvar context = root.addChild(), ch;\r\n\t\t\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(abbr);\r\n\t\tvar loopProtector = 1000, multiplier;\r\n\t\tvar addChild = function(child) {\r\n\t\t\tcontext.addChild(child);\r\n\t\t};\r\n\r\n\t\tvar consumeAbbr = function() {\r\n\t\t\tstream.start = stream.pos;\r\n\t\t\tstream.eatWhile(function(c) {\r\n\t\t\t\tif (c == '[' || c == '{') {\r\n\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\r\n\t\t\t\t\t\tstream.backUp(1);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tthrow new Error('Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (c == '+') {\r\n\t\t\t\t\t// let's see if this is an expando marker\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\r\n\t\t\t\t\tstream.backUp(1);\r\n\t\t\t\t\treturn isMarker;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn c != '(' && isAllowedChar(c);\r\n\t\t\t});\r\n\t\t};\r\n\t\t\r\n\t\twhile (!stream.eol() && --loopProtector > 0) {\r\n\t\t\tch = stream.peek();\r\n\t\t\t\r\n\t\t\tswitch (ch) {\r\n\t\t\t\tcase '(': // abbreviation group\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\r\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\r\n\t\t\t\t\t\tif ((multiplier = stream.match(/^\\*(\\d+)?/, true))) {\r\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tinner.children.forEach(addChild);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthrow new Error('Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '>': // child operator\r\n\t\t\t\t\tcontext = context.addChild();\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '+': // sibling operator\r\n\t\t\t\t\tcontext = context.parent.addChild();\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '^': // climb up operator\r\n\t\t\t\t\tvar parent = context.parent || context;\r\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\tdefault: // consume abbreviation\r\n\t\t\t\t\tconsumeAbbr();\r\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (loopProtector < 1) {\r\n\t\t\tthrow new Error('Endless loop detected');\r\n\t\t}\r\n\t\t\r\n\t\treturn root;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits attribute set into a list of attributes string\r\n\t * @param  {String} attrSet \r\n\t * @return {Array}\r\n\t */\r\n\tfunction splitAttributes(attrSet) {\r\n\t\tattrSet = utils.trim(attrSet);\r\n\t\tvar parts = [];\r\n\r\n\t\t// split attribute set by spaces\r\n\t\tvar stream = stringStream(attrSet), ch;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (ch == ' ') {\r\n\t\t\t\tparts.push(utils.trim(stream.current()));\r\n\t\t\t\t// skip spaces\r\n\t\t\t\twhile (stream.peek() == ' ') {\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t} else if (ch == '\"' || ch == \"'\") {\r\n\t\t\t\t// skip values in strings\r\n\t\t\t\tif (!stream.skipString(ch)) {\r\n\t\t\t\t\tthrow new Error('Invalid attribute set');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tparts.push(utils.trim(stream.current()));\r\n\t\treturn parts;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes opening and closing quotes from given string\r\n\t * @param  {String} str\r\n\t * @return {String}\r\n\t */\r\n\tfunction unquote(str) {\r\n\t\tvar ch = str.charAt(0);\r\n\t\tif (ch == '\"' || ch == \"'\") {\r\n\t\t\tstr = str.substr(1);\r\n\t\t\tvar last = str.charAt(str.length - 1);\r\n\t\t\tif (last === ch) {\r\n\t\t\t\tstr = str.substr(0, str.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t}\r\n\r\n\t/**\r\n\t * Extract attributes and their values from attribute set: \r\n\t * <code>[attr col=3 title=\"Quoted string\"]</code> (without square braces)\r\n\t * @param {String} attrSet\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction extractAttributes(attrSet) {\r\n\t\tvar reAttrName = /^[\\w\\-:\\$@]+\\.?$/;\r\n\t\treturn splitAttributes(attrSet).map(function(attr) {\r\n\t\t\t// attribute name: [attr]\r\n\t\t\tif (reAttrName.test(attr)) {\r\n\t\t\t\tvar value = '';\r\n\t\t\t\tif (attr.charAt(attr.length - 1) == '.') {\r\n\t\t\t\t\t// a boolean attribute\r\n\t\t\t\t\tattr = attr.substr(0, attr.length - 1);\r\n\t\t\t\t\tvalue = attr;\r\n\t\t\t\t}\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: attr,\r\n\t\t\t\t\tvalue: value\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// attribute with value: [name=val], [name=\"val\"]\r\n\t\t\tif (~attr.indexOf('=')) {\r\n\t\t\t\tvar parts = attr.split('=');\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: parts.shift(),\r\n\t\t\t\t\tvalue: unquote(parts.join('='))\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\t// looks like it’s implied attribute\r\n\t\t\treturn {\r\n\t\t\t\tname: DEFAULT_ATTR_NAME,\r\n\t\t\t\tvalue: unquote(attr)\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \r\n\t * returns object with <code>element</code> and <code>attributes</code>\r\n\t * properties\r\n\t * @param {String} abbr\r\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \r\n\t * abbreviation\r\n\t */\r\n\tfunction parseAttributes(abbr) {\r\n\t\t/*\r\n\t\t * Example of incoming data:\r\n\t\t * #header\r\n\t\t * .some.data\r\n\t\t * .some.data#header\r\n\t\t * [attr]\r\n\t\t * #item[attr=Hello other=\"World\"].class\r\n\t\t */\r\n\t\tvar result = [];\r\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\r\n\t\tvar nameEnd = null;\r\n\t\t\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(abbr);\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tswitch (stream.peek()) {\r\n\t\t\t\tcase '#': // id\r\n\t\t\t\tcase '.': // class\r\n\t\t\t\t\tif (nameEnd === null)\r\n\t\t\t\t\t\tnameEnd = stream.pos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\r\n\t\t\t\t\t\r\n\t\t\t\t\tstream.next();\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tstream.eatWhile(reWord);\r\n\t\t\t\t\tresult.push({\r\n\t\t\t\t\t\tname: attrName, \r\n\t\t\t\t\t\tvalue: stream.current()\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '[': //begin attribute set\r\n\t\t\t\t\tif (nameEnd === null)\r\n\t\t\t\t\t\tnameEnd = stream.pos;\r\n\t\t\t\t\t\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) {\r\n\t\t\t\t\t\tthrow new Error('Invalid attribute set definition');\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tresult = result.concat(\r\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\r\n\t\t\t\t\t);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstream.next();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (!result.length)\r\n\t\t\treturn null;\r\n\t\t\r\n\t\treturn {\r\n\t\t\telement: abbr.substring(0, nameEnd),\r\n\t\t\tattributes: optimizeAttributes(result)\r\n\t\t};\r\n\t}\r\n\t\r\n\t/**\r\n\t * Optimize attribute set: remove duplicates and merge class attributes\r\n\t * @param attrs\r\n\t */\r\n\tfunction optimizeAttributes(attrs) {\r\n\t\t// clone all attributes to make sure that original objects are \r\n\t\t// not modified\r\n\t\tattrs = attrs.map(function(attr) {\r\n\t\t\treturn utils.clone(attr);\r\n\t\t});\r\n\t\t\r\n\t\tvar lookup = {};\r\n\r\n\t\treturn attrs.filter(function(attr) {\r\n\t\t\tif (!(attr.name in lookup)) {\r\n\t\t\t\treturn lookup[attr.name] = attr;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar la = lookup[attr.name];\r\n\t\t\t\r\n\t\t\tif (attr.name.toLowerCase() == 'class') {\r\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\r\n\t\t\t} else {\r\n\t\t\t\tla.value = attr.value;\r\n\t\t\t\tla.isImplied = !!attr.isImplied;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\r\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\r\n\t * If nothing found, returns <code>null</code>\r\n\t * @param {String} abbr\r\n\t * \r\n\t */\r\n\tfunction extractText(abbr) {\r\n\t\tif (!~abbr.indexOf('{'))\r\n\t\t\treturn null;\r\n\t\t\r\n\t\t/** @type StringStream */\r\n\t\tvar stream = stringStream.create(abbr);\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tswitch (stream.peek()) {\r\n\t\t\t\tcase '[':\r\n\t\t\t\tcase '(':\r\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\r\n\t\t\t\t\t\r\n\t\t\t\tcase '{':\r\n\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\tstream.skipToPair('{', '}');\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\r\n\t\t\t\t\t\ttext: stripped(stream.current())\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tstream.next();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * “Un-rolls“ contents of current node: recursively replaces all repeating \r\n\t * children with their repeated clones\r\n\t * @param {AbbreviationNode} node\r\n\t * @returns {AbbreviationNode}\r\n\t */\r\n\tfunction unroll(node) {\r\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\r\n\t\t\tchild = node.children[i];\r\n\t\t\t\r\n\t\t\tif (child.isRepeating()) {\r\n\t\t\t\tmaxCount = j = child.repeatCount;\r\n\t\t\t\tchild.repeatCount = 1;\r\n\t\t\t\tchild.updateProperty('counter', 1);\r\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\r\n\t\t\t\twhile (--j > 0) {\r\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\r\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\r\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// to keep proper 'counter' property, we need to walk\r\n\t\t// on children once again\r\n\t\tnode.children.forEach(unroll);\r\n\t\t\r\n\t\treturn node;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Optimizes tree node: replaces empty nodes with their children\r\n\t * @param {AbbreviationNode} node\r\n\t * @return {AbbreviationNode}\r\n\t */\r\n\tfunction squash(node) {\r\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\r\n\t\t\t/** @type AbbreviationNode */\r\n\t\t\tvar n = node.children[i];\r\n\t\t\tif (n.isGroup()) {\r\n\t\t\t\tn.replace(squash(n).children);\r\n\t\t\t} else if (n.isEmpty()) {\r\n\t\t\t\tn.remove();\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tnode.children.forEach(squash);\r\n\t\t\r\n\t\treturn node;\r\n\t}\r\n\t\r\n\tfunction isAllowedChar(ch) {\r\n\t\tvar charCode = ch.charCodeAt(0);\r\n\t\tvar specialChars = '#.*:$-_!@|%';\r\n\t\t\r\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\r\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\r\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\r\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\r\n\t}\r\n\r\n\t// XXX add counter replacer function as output processor\r\n\toutputProcessors.push(function(text, node) {\r\n\t\treturn utils.replaceCounter(text, node.counter, node.maxCount);\r\n\t});\r\n\r\n\t// XXX add tabstop updater\r\n\toutputProcessors.push(tabStops.abbrOutputProcessor.bind(tabStops));\r\n\r\n\t// include default pre- and postprocessors\r\n\t[lorem, procResourceMatcher, procAttributes, procPastedContent, procTagName, procHref].forEach(function(mod) {\r\n\t\tif (mod.preprocessor) {\r\n\t\t\tpreprocessors.push(mod.preprocessor.bind(mod));\r\n\t\t}\r\n\r\n\t\tif (mod.postprocessor) {\r\n\t\t\tpostprocessors.push(mod.postprocessor.bind(mod));\r\n\t\t}\r\n\t});\r\n\r\n\treturn {\r\n\t\tDEFAULT_ATTR_NAME: DEFAULT_ATTR_NAME,\r\n\r\n\t\t/**\r\n\t\t * Parses abbreviation into tree with respect of groups, \r\n\t\t * text nodes and attributes. Each node of the tree is a single \r\n\t\t * abbreviation. Tree represents actual structure of the outputted \r\n\t\t * result\r\n\t\t * @memberOf abbreviationParser\r\n\t\t * @param {String} abbr Abbreviation to parse\r\n\t\t * @param {Object} options Additional options for parser and processors\r\n\t\t * \r\n\t\t * @return {AbbreviationNode}\r\n\t\t */\r\n\t\tparse: function(abbr, options) {\r\n\t\t\toptions = options || {};\r\n\t\t\t\r\n\t\t\tvar tree = parseAbbreviation(abbr);\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\tif (options.contextNode) {\r\n\t\t\t\t// add info about context node –\r\n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \r\n\t\t\t\t// expanded\r\n\t\t\t\ttree._name = options.contextNode.name;\r\n\t\t\t\tvar attrLookup = {};\r\n\t\t\t\ttree._attributes.forEach(function(attr) {\r\n\t\t\t\t\tattrLookup[attr.name] = attr;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\toptions.contextNode.attributes.forEach(function(attr) {\r\n\t\t\t\t\tif (attr.name in attrLookup) {\r\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tattr = utils.clone(attr);\r\n\t\t\t\t\t\ttree._attributes.push(attr);\r\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// apply preprocessors\r\n\t\t\tpreprocessors.forEach(function(fn) {\r\n\t\t\t\tfn(tree, options, that);\r\n\t\t\t});\r\n\r\n\t\t\tif ('counter' in options) {\r\n\t\t\t\ttree.updateProperty('counter', options.counter);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttree = squash(unroll(tree));\r\n\t\t\t\r\n\t\t\t// apply postprocessors\r\n\t\t\tpostprocessors.forEach(function(fn) {\r\n\t\t\t\tfn(tree, options, that);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn tree;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Expands given abbreviation into a formatted code structure.\r\n\t\t * This is the main method that is used for expanding abbreviation\r\n\t\t * @param {String} abbr Abbreviation to expand\r\n\t\t * @param {Options} options Additional options for abbreviation\r\n\t\t * expanding and transformation: `syntax`, `profile`, `contextNode` etc.\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\texpand: function(abbr, options) {\r\n\t\t\tif (!abbr) return '';\r\n\t\t\tif (typeof options == 'string') {\r\n\t\t\t\tthrow new Error('Deprecated use of `expand` method: `options` must be object');\r\n\t\t\t}\r\n\r\n\t\t\toptions = options || {};\r\n\r\n\t\t\tif (!options.syntax) {\r\n\t\t\t\toptions.syntax = utils.defaultSyntax();\r\n\t\t\t}\r\n\r\n\t\t\tvar p = profile.get(options.profile, options.syntax);\r\n\t\t\ttabStops.resetTabstopIndex();\r\n\t\t\t\r\n\t\t\tvar data = filters.extract(abbr);\r\n\t\t\tvar outputTree = this.parse(data[0], options);\r\n\r\n\t\t\tvar filtersList = filters.composeList(options.syntax, p, data[1]);\r\n\t\t\tfilters.apply(outputTree, filtersList, p);\r\n\r\n\t\t\treturn outputTree.valueOf();\r\n\t\t},\r\n\t\t\r\n\t\tAbbreviationNode: AbbreviationNode,\r\n\t\t\r\n\t\t/**\r\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\r\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\r\n\t\t * The passed tree is in unoptimized state.\r\n\t\t * @param {Function} fn Preprocessor function. This function receives\r\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\r\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\r\n\t\t * method\r\n\t\t */\r\n\t\taddPreprocessor: function(fn) {\r\n\t\t\tif (!~preprocessors.indexOf(fn)) {\r\n\t\t\t\tpreprocessors.push(fn);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered preprocessor\r\n\t\t */\r\n\t\tremoveFilter: function(fn) {\r\n\t\t\tvar ix = preprocessors.indexOf(fn);\r\n\t\t\tif (~ix) {\r\n\t\t\t\tpreprocessors.splice(ix, 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \r\n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\r\n\t\t * right before it returns from <code>parse()</code> method\r\n\t\t * @param {Function} fn Postprocessor function. This function receives\r\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\r\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\r\n\t\t * method\r\n\t\t */\r\n\t\taddPostprocessor: function(fn) {\r\n\t\t\tif (!~postprocessors.indexOf(fn)) {\r\n\t\t\t\tpostprocessors.push(fn);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered postprocessor function\r\n\t\t */\r\n\t\tremovePostprocessor: function(fn) {\r\n\t\t\tvar ix = postprocessors.indexOf(fn);\r\n\t\t\tif (~ix) {\r\n\t\t\t\tpostprocessors.splice(ix, 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \r\n\t\t * function that applies to output part (<code>start</code>, \r\n\t\t * <code>end</code> and <code>content</code>) when \r\n\t\t * <code>AbbreviationNode.toString()</code> method is called\r\n\t\t */\r\n\t\taddOutputProcessor: function(fn) {\r\n\t\t\tif (!~outputProcessors.indexOf(fn)) {\r\n\t\t\t\toutputProcessors.push(fn);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes registered output processor\r\n\t\t */\r\n\t\tremoveOutputProcessor: function(fn) {\r\n\t\t\tvar ix = outputProcessors.indexOf(fn);\r\n\t\t\tif (~ix) {\r\n\t\t\t\toutputProcessors.splice(ix, 1);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\r\n\t\t * @param {String} ch\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisAllowedChar: function(ch) {\r\n\t\t\tch = String(ch); // convert Java object to JS\r\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/profile\":\"assets\\\\profile.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../filter/main\":\"filter\\\\main.js\",\"../generator/lorem\":\"generator\\\\lorem.js\",\"../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../utils/common\":\"utils\\\\common.js\",\"./processor/attributes\":\"parser\\\\processor\\\\attributes.js\",\"./processor/href\":\"parser\\\\processor\\\\href.js\",\"./processor/pastedContent\":\"parser\\\\processor\\\\pastedContent.js\",\"./processor/resourceMatcher\":\"parser\\\\processor\\\\resourceMatcher.js\",\"./processor/tagName\":\"parser\\\\processor\\\\tagName.js\"}],\"parser\\\\css.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar session = {tokens: null};\r\n\t\r\n\t// walks around the source\r\n\tvar walker = {\r\n\t\tinit: function (source) {\r\n\t\t\t// this.source = source.replace(/\\r\\n?/g, '\\n');\r\n\t\t\tthis.source = source;\r\n\t\t\tthis.ch = '';\r\n\t\t\tthis.chnum = -1;\r\n\t\t\r\n\t\t\t// advance\r\n\t\t\tthis.nextChar();\r\n\t\t},\r\n\t\tnextChar: function () {\r\n\t\t\treturn this.ch = this.source.charAt(++this.chnum);\r\n\t\t},\r\n\t\tpeek: function() {\r\n\t\t\treturn this.source.charAt(this.chnum + 1);\r\n\t\t}\r\n\t};\r\n\r\n\t// utility helpers\r\n\tfunction isNameChar(c, cc) {\r\n\t\tcc = cc || c.charCodeAt(0);\r\n\t\treturn (\r\n\t\t\t(cc >= 97 && cc <= 122 /* a-z */) || \r\n\t\t\t(cc >= 65 && cc <= 90 /* A-Z */) || \r\n\t\t\t/* \r\n\t\t\tExperimental: include cyrillic ranges \r\n\t\t\tsince some letters, similar to latin ones, can \r\n\t\t\taccidentally appear in CSS tokens\r\n\t\t\t*/\r\n\t\t\t(cc >= 1024 && cc <= 1279) || \r\n\t\t\tc === '&' || /* selector placeholder (LESS, SCSS) */\r\n\t\t\tc === '_' || \r\n\t\t\tc === '<' || /* comparisons (LESS, SCSS) */\r\n\t\t\tc === '>' || \r\n\t\t\tc === '=' || \r\n\t\t\tc === '-'\r\n\t\t);\r\n\t}\r\n\r\n\tfunction isDigit(c, cc) {\r\n\t\tcc = cc || c.charCodeAt(0);\r\n\t\treturn (cc >= 48 && cc <= 57);\r\n\t}\r\n\r\n\tvar isOp = (function () {\r\n\t\tvar opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\r\n\t\t\topsmatcha = \"*^|$~\".split(''),\r\n\t\t\tops = {},\r\n\t\t\topsmatch = {},\r\n\t\t\ti = 0;\r\n\t\tfor (; i < opsa.length; i += 1) {\r\n\t\t\tops[opsa[i]] = true;\r\n\t\t}\r\n\t\tfor (i = 0; i < opsmatcha.length; i += 1) {\r\n\t\t\topsmatch[opsmatcha[i]] = true;\r\n\t\t}\r\n\t\treturn function (ch, matchattr) {\r\n\t\t\tif (matchattr) {\r\n\t\t\t\treturn ch in opsmatch;\r\n\t\t\t}\r\n\t\t\treturn ch in ops;\r\n\t\t};\r\n\t}());\r\n\t\r\n\t// creates token objects and pushes them to a list\r\n\tfunction tokener(value, type) {\r\n\t\tsession.tokens.push({\r\n\t\t\tvalue: value,\r\n\t\t\ttype:  type || value,\r\n\t\t\tstart: null,\r\n\t\t\tend:   null\r\n\t\t});\r\n\t}\r\n\r\n\tfunction getPosInfo(w) {\r\n\t\tvar errPos = w.chnum;\r\n\t\tvar source = w.source.replace(/\\r\\n?/g, '\\n');\r\n\t\tvar part = w.source.substring(0, errPos + 1).replace(/\\r\\n?/g, '\\n');\r\n\t\tvar lines = part.split('\\n');\r\n\t\tvar ch = (lines[lines.length - 1] || '').length;\r\n\t\tvar fullLine = source.split('\\n')[lines.length - 1] || '';\r\n\t\t\r\n\t\tvar chunkSize = 100;\r\n\t\tvar offset = Math.max(0, ch - chunkSize);\r\n\t\tvar formattedLine = fullLine.substr(offset, chunkSize * 2) + '\\n';\r\n\t\tfor (var i = 0; i < ch - offset - 1; i++) {\r\n\t\t\tformattedLine += '-';\r\n\t\t}\r\n\t\tformattedLine += '^';\r\n\r\n\t\treturn {\r\n\t\t\tline: lines.length,\r\n\t\t\tch: ch,\r\n\t\t\ttext: fullLine,\r\n\t\t\thint: formattedLine\r\n\t\t};\r\n\t}\r\n\r\n\tfunction raiseError(message) {\r\n\t\tvar err = error(message);\r\n\t\tvar errObj = new Error(err.message, '', err.line);\r\n\t\terrObj.line = err.line;\r\n\t\terrObj.ch = err.ch;\r\n\t\terrObj.name = err.name;\r\n\t\terrObj.hint = err.hint;\r\n\r\n\t\tthrow errObj;\r\n\t}\r\n\t\r\n\t// oops\r\n\tfunction error(m) { \r\n\t\tvar w = walker;\r\n\t\tvar info = getPosInfo(walker);\r\n\t\tvar tokens = session.tokens;\r\n\t\tsession.tokens = null;\r\n\r\n\t\tvar message = 'CSS parsing error at line ' + info.line + ', char ' + info.ch + ': ' + m;\r\n\t\tmessage += '\\n' +  info.hint;\r\n\t\treturn {\r\n\t\t\tname: \"ParseError\",\r\n\t\t\tmessage: message,\r\n\t\t\thint: info.hint,\r\n\t\t\tline: info.line,\r\n\t\t\tch: info.ch\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t// token handlers follow for:\r\n\t// white space, comment, string, identifier, number, operator\r\n\tfunction white() {\r\n\t\tvar c = walker.ch,\r\n\t\t\ttoken = '';\r\n\t\r\n\t\twhile (c === \" \" || c === \"\\t\") {\r\n\t\t\ttoken += c;\r\n\t\t\tc = walker.nextChar();\r\n\t\t}\r\n\t\r\n\t\ttokener(token, 'white');\r\n\t\r\n\t}\r\n\r\n\tfunction comment() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\ttoken = c,\r\n\t\t\tcnext;\r\n\t \r\n\t\tcnext = w.nextChar();\r\n\r\n\t\tif (cnext === '/') {\r\n\t\t\t// inline comment in SCSS and LESS\r\n\t\t\twhile (c && !(cnext === \"\\n\" || cnext === \"\\r\")) {\r\n\t\t\t\ttoken += cnext;\r\n\t\t\t\tc = cnext;\r\n\t\t\t\tcnext = w.nextChar();\r\n\t\t\t}\r\n\t\t} else if (cnext === '*') {\r\n\t\t\t// multiline CSS commment\r\n\t\t\twhile (c && !(c === \"*\" && cnext === \"/\")) {\r\n\t\t\t\ttoken += cnext;\r\n\t\t\t\tc = cnext;\r\n\t\t\t\tcnext = w.nextChar();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// oops, not a comment, just a /\r\n\t\t\treturn tokener(token, token);\r\n\t\t}\r\n\t\t\r\n\t\ttoken += cnext;\r\n\t\tw.nextChar();\r\n\t\ttokener(token, 'comment');\r\n\t}\r\n\r\n\tfunction eatString() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\tq = c,\r\n\t\t\ttoken = c,\r\n\t\t\tcnext;\r\n\t\r\n\t\tc = w.nextChar();\r\n\r\n\t\twhile (c !== q) {\r\n\t\t\tif (c === '\\n') {\r\n\t\t\t\tcnext = w.nextChar();\r\n\t\t\t\tif (cnext === \"\\\\\") {\r\n\t\t\t\t\ttoken += c + cnext;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// end of line with no \\ escape = bad\r\n\t\t\t\t\traiseError(\"Unterminated string\");\r\n\t\t\t\t}\r\n\t\t\t} else if (c === '') {\r\n\t\t\t\traiseError(\"Unterminated string\");\r\n\t\t\t} else {\r\n\t\t\t\tif (c === \"\\\\\") {\r\n\t\t\t\t\ttoken += c + w.nextChar();\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttoken += c;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\r\n\t\t\tc = w.nextChar();\r\n\t\t}\r\n\r\n\t\ttoken += c;\r\n\r\n\t\treturn token;\r\n\t}\r\n\r\n\tfunction str() {\r\n\t\tvar token = eatString();\r\n\t\twalker.nextChar();\r\n\t\ttokener(token, 'string');\r\n\t}\r\n\t\r\n\tfunction brace() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\tdepth = 1,\r\n\t\t\ttoken = c,\r\n\t\t\tstop = false;\r\n\t\r\n\t\tc = w.nextChar();\r\n\t\r\n\t\twhile (c && !stop) {\r\n\t\t\tif (c === '(') {\r\n\t\t\t\tdepth++;\r\n\t\t\t} else if (c === ')') {\r\n\t\t\t\tdepth--;\r\n\t\t\t\tif (!depth) {\r\n\t\t\t\t\tstop = true;\r\n\t\t\t\t}\r\n\t\t\t} else if (c === '\"' || c === \"'\") {\r\n\t\t\t\tc = eatString();\r\n\t\t\t} else if (c === '') {\r\n\t\t\t\traiseError(\"Unterminated brace\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttoken += c;\r\n\t\t\tc = w.nextChar();\r\n\t\t}\r\n\t\t\r\n\t\ttokener(token, 'brace');\r\n\t}\r\n\r\n\tfunction identifier(pre) {\r\n\t\tvar c = walker.ch;\r\n\t\tvar token = pre ? pre + c : c;\r\n\t\t\t\r\n\t\tc = walker.nextChar();\r\n\t\tvar cc = c.charCodeAt(0);\r\n\t\twhile (isNameChar(c, cc) || isDigit(c, cc)) {\r\n\t\t\ttoken += c;\r\n\t\t\tc = walker.nextChar();\r\n\t\t\tcc = c.charCodeAt(0);\r\n\t\t}\r\n\t\r\n\t\ttokener(token, 'identifier');\r\n\t}\r\n\r\n\tfunction num() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\ttoken = c,\r\n\t\t\tpoint = token === '.',\r\n\t\t\tnondigit;\r\n\t\t\r\n\t\tc = w.nextChar();\r\n\t\tnondigit = !isDigit(c);\r\n\t\r\n\t\t// .2px or .classname?\r\n\t\tif (point && nondigit) {\r\n\t\t\t// meh, NaN, could be a class name, so it's an operator for now\r\n\t\t\treturn tokener(token, '.');    \r\n\t\t}\r\n\t\t\r\n\t\t// -2px or -moz-something\r\n\t\tif (token === '-' && nondigit) {\r\n\t\t\treturn identifier('-');\r\n\t\t}\r\n\t\r\n\t\twhile (c !== '' && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\r\n\t\t\tif (c === '.') {\r\n\t\t\t\tpoint = true;\r\n\t\t\t}\r\n\t\t\ttoken += c;\r\n\t\t\tc = w.nextChar();\r\n\t\t}\r\n\r\n\t\ttokener(token, 'number');    \r\n\t\r\n\t}\r\n\r\n\tfunction op() {\r\n\t\tvar w = walker,\r\n\t\t\tc = w.ch,\r\n\t\t\ttoken = c,\r\n\t\t\tnext = w.nextChar();\r\n\t\t\t\r\n\t\tif (next === \"=\" && isOp(token, true)) {\r\n\t\t\ttoken += next;\r\n\t\t\ttokener(token, 'match');\r\n\t\t\tw.nextChar();\r\n\t\t\treturn;\r\n\t\t} \r\n\t\t\r\n\t\ttokener(token, token);\r\n\t}\r\n\r\n\r\n\t// call the appropriate handler based on the first character in a token suspect\r\n\tfunction tokenize() {\r\n\t\tvar ch = walker.ch;\r\n\t\r\n\t\tif (ch === \" \" || ch === \"\\t\") {\r\n\t\t\treturn white();\r\n\t\t}\r\n\r\n\t\tif (ch === '/') {\r\n\t\t\treturn comment();\r\n\t\t} \r\n\r\n\t\tif (ch === '\"' || ch === \"'\") {\r\n\t\t\treturn str();\r\n\t\t}\r\n\t\t\r\n\t\tif (ch === '(') {\r\n\t\t\treturn brace();\r\n\t\t}\r\n\t\r\n\t\tif (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\r\n\t\t\treturn num();\r\n\t\t}\r\n\t\r\n\t\tif (isNameChar(ch)) {\r\n\t\t\treturn identifier();\r\n\t\t}\r\n\r\n\t\tif (isOp(ch)) {\r\n\t\t\treturn op();\r\n\t\t}\r\n\r\n\t\tif (ch === '\\r') {\r\n\t\t\tif (walker.peek() === '\\n') {\r\n\t\t\t\tch += walker.nextChar();\r\n\t\t\t}\r\n\r\n\t\t\ttokener(ch, 'line');\r\n\t\t\twalker.nextChar();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (ch === '\\n') {\r\n\t\t\ttokener(ch, 'line');\r\n\t\t\twalker.nextChar();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\traiseError(\"Unrecognized character '\" + ch + \"'\");\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Sprits given source into tokens\r\n\t\t * @param {String} source\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlex: function (source) {\r\n\t\t\twalker.init(source);\r\n\t\t\tsession.tokens = [];\r\n\r\n\t\t\t// for empty source, return single space token\r\n\t\t\tif (!source) {\r\n\t\t\t\tsession.tokens.push(this.white());\r\n\t\t\t} else {\r\n\t\t\t\twhile (walker.ch !== '') {\r\n\t\t\t\t\ttokenize();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar tokens = session.tokens;\r\n\t\t\tsession.tokens = null;\r\n\t\t\treturn tokens;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Tokenizes CSS source. It's like `lex()` method,\r\n\t\t * but also stores proper token indexes in source, \r\n\t\t * so it's a bit slower\r\n\t\t * @param {String} source\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tparse: function(source) {\r\n\t\t\t// transform tokens\r\n\t\t\tvar tokens = this.lex(source), pos = 0, token;\r\n\t\t\tfor (var i = 0, il = tokens.length; i < il; i++) {\r\n\t\t\t\ttoken = tokens[i];\r\n\t\t\t\ttoken.start = pos;\r\n\t\t\t\ttoken.end = (pos += token.value.length);\r\n\t\t\t}\r\n\t\t\treturn tokens;\r\n\t\t},\r\n\r\n\t\twhite: function() {\r\n\t\t\treturn {\r\n\t\t\t\tvalue: '',\r\n\t\t\t\ttype:  'white',\r\n\t\t\t\tstart: 0,\r\n\t\t\t\tend:   0\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\ttoSource: function(toks) {\r\n\t\t\tvar i = 0, max = toks.length, src = '';\r\n\t\t\tfor (; i < max; i++) {\r\n\t\t\t\tsrc += toks[i].value;\r\n\t\t\t}\r\n\t\t\treturn src;\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"parser\\\\processor\\\\attributes.js\":[function(require,module,exports){\r\n/**\r\n * Resolves node attribute names: moves `default` attribute value\r\n * from stub to real attribute.\r\n *\r\n * This resolver should be applied *after* resource matcher\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../../utils/common');\r\n\r\n\tvar findDefault = function(attr) {\r\n\t\treturn attr.isDefault;\r\n\t};\r\n\r\n\tvar findImplied = function(attr) {\r\n\t\treturn attr.isImplied;\r\n\t};\r\n\r\n\tvar findEmpty = function(attr) {\r\n\t\treturn !attr.value;\r\n\t};\r\n\r\n\tfunction resolveDefaultAttrs(node, parser) {\r\n\t\tnode.children.forEach(function(item) {\r\n\t\t\tvar attrList = item.attributeList();\r\n\t\t\tvar defaultAttrValue = item.attribute(parser.DEFAULT_ATTR_NAME);\r\n\t\t\tif (typeof defaultAttrValue !== 'undefined') {\r\n\t\t\t\t// remove stub attribute\r\n\t\t\t\titem.attribute(parser.DEFAULT_ATTR_NAME, null);\r\n\t\t\t\t\r\n\t\t\t\tif (attrList.length) {\r\n\t\t\t\t\t// target for default value:\r\n\t\t\t\t\t// 1. default attribute\r\n\t\t\t\t\t// 2. implied attribute\r\n\t\t\t\t\t// 3. first empty attribute\r\n\t\t\t\t\r\n\t\t\t\t\t// find attribute marked as default\r\n\t\t\t\t\tvar defaultAttr = utils.find(attrList, findDefault) \r\n\t\t\t\t\t\t|| utils.find(attrList, findImplied) \r\n\t\t\t\t\t\t|| utils.find(attrList, findEmpty);\r\n\r\n\t\t\t\t\tif (defaultAttr) {\r\n\t\t\t\t\t\tvar oldVal = item.attribute(defaultAttr.name);\r\n\t\t\t\t\t\tvar newVal = utils.replaceUnescapedSymbol(oldVal, '|', defaultAttrValue);\r\n\t\t\t\t\t\t// no replacement, e.g. default value does not contains | symbol\r\n\t\t\t\t\t\tif (oldVal == newVal) {\r\n\t\t\t\t\t\t\tnewVal = defaultAttrValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\titem.attribute(defaultAttr.name, newVal);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// if no default attribute value, remove implied attributes\r\n\t\t\t\tattrList.forEach(function(attr) {\r\n\t\t\t\t\tif (attr.isImplied) {\r\n\t\t\t\t\t\titem.attribute(attr.name, null);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tresolveDefaultAttrs(item, parser);\r\n\t\t});\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * @param  {AbbreviationNode} tree\r\n\t\t * @param  {Object} options\r\n\t\t * @param  {abbreviation} parser\r\n\t\t */\r\n\t\tpreprocessor: function(tree, options, parser) {\r\n\t\t\tresolveDefaultAttrs(tree, parser);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\href.js\":[function(require,module,exports){\r\n/**\r\n * A preptocessor for &lt;a&gt; tag: tests wrapped content\r\n * for common URL patterns and, if matched, inserts it as \r\n * `href` attribute\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../../assets/preferences');\r\n\tvar utils = require('../../utils/common');\r\n\tvar pc = require('./pastedContent');\r\n\r\n\tprefs.define('href.autodetect', true, \r\n\t\t'Enables or disables automatic URL recognition when wrapping\\\r\n\t\ttext with <code>&lt;a&gt;</code> tag. With this option enabled,\\\r\n\t\tif wrapped text matches URL or e-mail pattern it will be automatically\\\r\n\t\tinserted into <code>href</code> attribute.');\r\n\tprefs.define('href.urlPattern', '^(?:(?:https?|ftp|file)://|www\\\\.|ftp\\\\.)(?:\\\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\\\)|[-A-Z0-9+&@#/%=~_|$?!:,.])*(?:\\\\([-A-Z0-9+&@#/%=~_|$?!:,.]*\\\\)|[A-Z0-9+&@#/%=~_|$])', \r\n\t\t'RegExp pattern to match wrapped URLs. Matched content will be inserts\\\r\n\t\tas-is into <code>href</code> attribute, only whitespace will be trimmed.');\r\n\r\n\tprefs.define('href.emailPattern', '^[a-z0-9._%+-]+@[a-z0-9.-]+\\\\.[a-z]{2,5}$', \r\n\t\t'RegExp pattern to match wrapped e-mails. Unlike <code>href.urlPattern</code>,\\\r\n\t\twrapped content will be prefixed with <code>mailto:</code> in <code>href</code>\\\r\n\t\tattribute');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * @param {AbbreviationNode} tree\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\tpostprocessor: function(tree, options) {\r\n\t\t\tif (!prefs.get('href.autodetect')) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar reUrl = new RegExp(prefs.get('href.urlPattern'), 'i');\r\n\t\t\tvar reEmail = new RegExp(prefs.get('href.emailPattern'), 'i');\r\n\t\t\tvar reProto = /^([a-z]+:)?\\/\\//i;\r\n\r\n\t\t\ttree.findAll(function(item) {\r\n\t\t\t\tif (item.name().toLowerCase() != 'a' || item.attribute('href')) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pastedContent = utils.trim(pc.pastedContent(item) || options.pastedContent);\r\n\t\t\t\tif (pastedContent) {\r\n\t\t\t\t\tif (reUrl.test(pastedContent)) {\r\n\t\t\t\t\t\t// do we have protocol?\r\n\t\t\t\t\t\tif (!reProto.test(pastedContent)) {\r\n\t\t\t\t\t\t\tpastedContent = 'http://' + pastedContent;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\titem.attribute('href', pastedContent);\r\n\t\t\t\t\t} else if (reEmail.test(pastedContent)) {\r\n\t\t\t\t\t\titem.attribute('href', 'mailto:' + pastedContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../assets/preferences\":\"assets\\\\preferences.js\",\"../../utils/common\":\"utils\\\\common.js\",\"./pastedContent\":\"parser\\\\processor\\\\pastedContent.js\"}],\"parser\\\\processor\\\\pastedContent.js\":[function(require,module,exports){\r\n/**\r\n * Pasted content abbreviation processor. A pasted content is a content that\r\n * should be inserted into implicitly repeated abbreviation nodes.\r\n * This processor powers “Wrap With Abbreviation” action\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../../utils/common');\r\n\tvar abbrUtils = require('../../utils/abbreviation');\r\n\tvar stringStream = require('../../assets/stringStream');\r\n\tvar range = require('../../assets/range');\r\n\r\n\tvar outputPlaceholder = '$#';\r\n\t\r\n\t/**\r\n\t * Locates output placeholders inside text\r\n\t * @param {String} text\r\n\t * @returns {Array} Array of ranges of output placeholder in text\r\n\t */\r\n\tfunction locateOutputPlaceholder(text) {\r\n\t\tvar result = [];\r\n\t\t\r\n\t\tvar stream = stringStream.create(text);\r\n\t\t\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tif (stream.peek() == '\\\\') {\r\n\t\t\t\tstream.next();\r\n\t\t\t} else {\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\r\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstream.next();\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Replaces output placeholders inside <code>source</code> with \r\n\t * <code>value</code>\r\n\t * @param {String} source\r\n\t * @param {String} value\r\n\t * @returns {String}\r\n\t */\r\n\tfunction replaceOutputPlaceholders(source, value) {\r\n\t\tvar ranges = locateOutputPlaceholder(source);\r\n\t\t\r\n\t\tranges.reverse().forEach(function(r) {\r\n\t\t\tsource = utils.replaceSubstring(source, value, r);\r\n\t\t});\r\n\t\t\r\n\t\treturn source;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if parsed node contains output placeholder – a target where\r\n\t * pasted content should be inserted\r\n\t * @param {AbbreviationNode} node\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction hasOutputPlaceholder(node) {\r\n\t\tif (locateOutputPlaceholder(node.content).length)\r\n\t\t\treturn true;\r\n\t\t\r\n\t\t// check if attributes contains placeholder\r\n\t\treturn !!utils.find(node.attributeList(), function(attr) {\r\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\r\n\t\t});\r\n\t}\r\n\t\r\n\t/**\r\n\t * Insert pasted content into correct positions of parsed node\r\n\t * @param {AbbreviationNode} node\r\n\t * @param {String} content\r\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\r\n\t * found instead of appending to existing content\r\n\t */\r\n\tfunction insertPastedContent(node, content, overwrite) {\r\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\r\n\t\t\treturn hasOutputPlaceholder(item);\r\n\t\t});\r\n\t\t\r\n\t\tif (hasOutputPlaceholder(node))\r\n\t\t\tnodesWithPlaceholders.unshift(node);\r\n\t\t\r\n\t\tif (nodesWithPlaceholders.length) {\r\n\t\t\tnodesWithPlaceholders.forEach(function(item) {\r\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\r\n\t\t\t\titem._attributes.forEach(function(attr) {\r\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// on output placeholders in subtree, insert content in the deepest\r\n\t\t\t// child node\r\n\t\t\tvar deepest = node.deepestChild() || node;\r\n\t\t\tif (overwrite) {\r\n\t\t\t\tdeepest.content = content;\r\n\t\t\t} else {\r\n\t\t\t\tdeepest.content = abbrUtils.insertChildContent(deepest.content, content);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tpastedContent: function(item) {\r\n\t\t\tvar content = item.data('paste');\r\n\t\t\tif (Array.isArray(content)) {\r\n\t\t\t\treturn content[item.counter - 1];\r\n\t\t\t} else if (typeof content === 'function') {\r\n\t\t\t\treturn content(item.counter - 1, item.content);\r\n\t\t\t} else if (content) {\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @param {AbbreviationNode} tree\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\tpreprocessor: function(tree, options) {\r\n\t\t\tif (options.pastedContent) {\r\n\t\t\t\tvar lines = utils.splitByLines(options.pastedContent, true).map(utils.trim);\r\n\t\t\t\t\r\n\t\t\t\t// set repeat count for implicitly repeated elements before\r\n\t\t\t\t// tree is unrolled\r\n\t\t\t\ttree.findAll(function(item) {\r\n\t\t\t\t\tif (item.hasImplicitRepeat) {\r\n\t\t\t\t\t\titem.data('paste', lines);\r\n\t\t\t\t\t\treturn item.repeatCount = lines.length;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * @param {AbbreviationNode} tree\r\n\t\t * @param {Object} options\r\n\t\t */\r\n\t\tpostprocessor: function(tree, options) {\r\n\t\t\tvar that = this;\r\n\t\t\t// for each node with pasted content, update text data\r\n\t\t\tvar targets = tree.findAll(function(item) {\r\n\t\t\t\tvar pastedContent = that.pastedContent(item);\r\n\t\t\t\tif (pastedContent) {\r\n\t\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn !!pastedContent;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (!targets.length && options.pastedContent) {\r\n\t\t\t\t// no implicitly repeated elements, put pasted content in\r\n\t\t\t\t// the deepest child\r\n\t\t\t\tinsertPastedContent(tree, options.pastedContent);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../assets/range\":\"assets\\\\range.js\",\"../../assets/stringStream\":\"assets\\\\stringStream.js\",\"../../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\resourceMatcher.js\":[function(require,module,exports){\r\n/**\r\n * Processor function that matches parsed <code>AbbreviationNode</code>\r\n * against resources defined in <code>resource</code> module\r\n */ \r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar resources = require('../../assets/resources');\r\n\tvar elements = require('../../assets/elements');\r\n\tvar utils = require('../../utils/common');\r\n\tvar abbreviationUtils = require('../../utils/abbreviation');\r\n\r\n\t/**\r\n\t * Finds matched resources for child nodes of passed <code>node</code> \r\n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\r\n\t * that describes output of parsed node \r\n\t * @param {AbbreviationNode} node\r\n\t * @param {String} syntax\r\n\t */\r\n\tfunction matchResources(node, syntax, parser) {\r\n\t\t// do a shallow copy because the children list can be modified during\r\n\t\t// resource matching\r\n\t\tnode.children.slice(0).forEach(function(child) {\r\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\r\n\t\t\tif (typeof r === 'string') {\r\n\t\t\t\tr = elements.create('snippet', r);\r\n\t\t\t}\r\n\r\n\t\t\tchild.data('resource', r);\r\n\t\t\tvar elemType = elements.type(r);\r\n\r\n\t\t\tif (elemType == 'snippet') {\r\n\t\t\t\tvar content = r.data;\r\n\t\t\t\tvar curContent = child._text || child.content;\r\n\t\t\t\tif (curContent) {\r\n\t\t\t\t\tcontent = abbreviationUtils.insertChildContent(content, curContent);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tchild.content = content;\r\n\t\t\t} else if (elemType == 'element') {\r\n\t\t\t\tchild._name = r.name;\r\n\t\t\t\tif (Array.isArray(r.attributes)) {\r\n\t\t\t\t\tchild._attributes = [].concat(r.attributes, child._attributes);\r\n\t\t\t\t}\r\n\t\t\t} else if (elemType == 'reference') {\r\n\t\t\t\t// it’s a reference to another abbreviation:\r\n\t\t\t\t// parse it and insert instead of current child\r\n\t\t\t\t/** @type AbbreviationNode */\r\n\t\t\t\tvar subtree = parser.parse(r.data, {\r\n\t\t\t\t\tsyntax: syntax\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// if context element should be repeated, check if we need to \r\n\t\t\t\t// transfer repeated element to specific child node\r\n\t\t\t\tif (child.repeatCount > 1) {\r\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\r\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tif (!repeatedChildren.length) {\r\n\t\t\t\t\t\trepeatedChildren = subtree.children\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\trepeatedChildren.forEach(function(node) {\r\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\r\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// move child‘s children into the deepest child of new subtree\r\n\t\t\t\tvar deepestChild = subtree.deepestChild();\r\n\t\t\t\tif (deepestChild) {\r\n\t\t\t\t\tchild.children.forEach(function(c) {\r\n\t\t\t\t\t\tdeepestChild.addChild(c);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tdeepestChild.content = child.content;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// copy current attributes to children\r\n\t\t\t\tsubtree.children.forEach(function(node) {\r\n\t\t\t\t\tchild.attributeList().forEach(function(attr) {\r\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tchild.replace(subtree.children);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmatchResources(child, syntax, parser);\r\n\t\t});\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tpreprocessor: function(tree, options, parser) {\r\n\t\t\tvar syntax = options.syntax || utils.defaultSyntax();\r\n\t\t\tmatchResources(tree, syntax, parser);\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../../assets/elements\":\"assets\\\\elements.js\",\"../../assets/resources\":\"assets\\\\resources.js\",\"../../utils/abbreviation\":\"utils\\\\abbreviation.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"parser\\\\processor\\\\tagName.js\":[function(require,module,exports){\r\n/**\r\n * Resolves tag names in abbreviations with implied name\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar tagName = require('../../resolver/tagName');\r\n\r\n\t/**\r\n\t * Resolves implicit node names in parsed tree\r\n\t * @param {AbbreviationNode} tree\r\n\t */\r\n\tfunction resolveNodeNames(tree) {\r\n\t\ttree.children.forEach(function(node) {\r\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\r\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\r\n\t\t\t\tnode.data('nameResolved', true);\r\n\t\t\t}\r\n\t\t\tresolveNodeNames(node);\r\n\t\t});\r\n\t\t\r\n\t\treturn tree;\r\n\t}\r\n\r\n\treturn {\r\n\t\tpostprocessor: resolveNodeNames\r\n\t};\r\n});\r\n},{\"../../resolver/tagName\":\"resolver\\\\tagName.js\"}],\"parser\\\\xml.js\":[function(require,module,exports){\r\n/**\r\n * HTML tokenizer by Marijn Haverbeke\r\n * http://codemirror.net/\r\n * @constructor\r\n * @memberOf __xmlParseDefine\r\n * @param {Function} require\r\n * @param {Underscore} _\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar stringStream = require('../assets/stringStream');\r\n\r\n\tvar Kludges = {\r\n\t\tautoSelfClosers : {},\r\n\t\timplicitlyClosed : {},\r\n\t\tcontextGrabbers : {},\r\n\t\tdoNotIndent : {},\r\n\t\tallowUnquoted : true,\r\n\t\tallowMissing : true\r\n\t};\r\n\r\n\t// Return variables for tokenizers\r\n\tvar tagName = null, type = null;\r\n\r\n\tfunction inText(stream, state) {\r\n\t\tfunction chain(parser) {\r\n\t\t\tstate.tokenize = parser;\r\n\t\t\treturn parser(stream, state);\r\n\t\t}\r\n\r\n\t\tvar ch = stream.next();\r\n\t\tif (ch == \"<\") {\r\n\t\t\tif (stream.eat(\"!\")) {\r\n\t\t\t\tif (stream.eat(\"[\")) {\r\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\r\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t} else if (stream.match(\"--\"))\r\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\r\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\r\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\r\n\t\t\t\t\treturn chain(doctype(1));\r\n\t\t\t\t} else\r\n\t\t\t\t\treturn null;\r\n\t\t\t} else if (stream.eat(\"?\")) {\r\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\r\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\r\n\t\t\t\treturn \"meta\";\r\n\t\t\t} else {\r\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\r\n\t\t\t\tstream.eatSpace();\r\n\t\t\t\ttagName = \"\";\r\n\t\t\t\tvar c;\r\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\r\n\t\t\t\t\ttagName += c;\r\n\t\t\t\tstate.tokenize = inTag;\r\n\t\t\t\treturn \"tag\";\r\n\t\t\t}\r\n\t\t} else if (ch == \"&\") {\r\n\t\t\tvar ok;\r\n\t\t\tif (stream.eat(\"#\")) {\r\n\t\t\t\tif (stream.eat(\"x\")) {\r\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\r\n\t\t\t}\r\n\t\t\treturn ok ? \"atom\" : \"error\";\r\n\t\t} else {\r\n\t\t\tstream.eatWhile(/[^&<]/);\r\n\t\t\treturn \"text\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction inTag(stream, state) {\r\n\t\tvar ch = stream.next();\r\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\r\n\t\t\tstate.tokenize = inText;\r\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\r\n\t\t\treturn \"tag\";\r\n\t\t} else if (ch == \"=\") {\r\n\t\t\ttype = \"equals\";\r\n\t\t\treturn null;\r\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\r\n\t\t\tstate.tokenize = inAttribute(ch);\r\n\t\t\treturn state.tokenize(stream, state);\r\n\t\t} else {\r\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\r\n\t\t\treturn \"word\";\r\n\t\t}\r\n\t}\r\n\r\n\tfunction inAttribute(quote) {\r\n\t\treturn function(stream, state) {\r\n\t\t\twhile (!stream.eol()) {\r\n\t\t\t\tif (stream.next() == quote) {\r\n\t\t\t\t\tstate.tokenize = inTag;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"string\";\r\n\t\t};\r\n\t}\r\n\r\n\tfunction inBlock(style, terminator) {\r\n\t\treturn function(stream, state) {\r\n\t\t\twhile (!stream.eol()) {\r\n\t\t\t\tif (stream.match(terminator)) {\r\n\t\t\t\t\tstate.tokenize = inText;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tstream.next();\r\n\t\t\t}\r\n\t\t\treturn style;\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction doctype(depth) {\r\n\t\treturn function(stream, state) {\r\n\t\t\tvar ch;\r\n\t\t\twhile ((ch = stream.next()) !== null) {\r\n\t\t\t\tif (ch == \"<\") {\r\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\r\n\t\t\t\t\treturn state.tokenize(stream, state);\r\n\t\t\t\t} else if (ch == \">\") {\r\n\t\t\t\t\tif (depth == 1) {\r\n\t\t\t\t\t\tstate.tokenize = inText;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\r\n\t\t\t\t\t\treturn state.tokenize(stream, state);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"meta\";\r\n\t\t};\r\n\t}\r\n\r\n\tvar curState = null, setStyle;\r\n\tfunction pass() {\r\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\r\n\t\t\tcurState.cc.push(arguments[i]);\r\n\t}\r\n\t\r\n\tfunction cont() {\r\n\t\tpass.apply(null, arguments);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction pushContext(tagName, startOfLine) {\r\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \r\n\t\t\t|| (curState.context && curState.context.noIndent);\r\n\t\tcurState.context = {\r\n\t\t\tprev : curState.context,\r\n\t\t\ttagName : tagName,\r\n\t\t\tindent : curState.indented,\r\n\t\t\tstartOfLine : startOfLine,\r\n\t\t\tnoIndent : noIndent\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction popContext() {\r\n\t\tif (curState.context)\r\n\t\t\tcurState.context = curState.context.prev;\r\n\t}\r\n\r\n\tfunction element(type) {\r\n\t\tif (type == \"openTag\") {\r\n\t\t\tcurState.tagName = tagName;\r\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\r\n\t\t} else if (type == \"closeTag\") {\r\n\t\t\tvar err = false;\r\n\t\t\tif (curState.context) {\r\n\t\t\t\tif (curState.context.tagName != tagName) {\r\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\r\n\t\t\t\t\t\tpopContext();\r\n\t\t\t\t\t}\r\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\terr = true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (err)\r\n\t\t\t\tsetStyle = \"error\";\r\n\t\t\treturn cont(endclosetag(err));\r\n\t\t}\r\n\t\treturn cont();\r\n\t}\r\n\t\r\n\tfunction endtag(startOfLine) {\r\n\t\treturn function(type) {\r\n\t\t\tif (type == \"selfcloseTag\"\r\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\r\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\r\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\r\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\r\n\t\t\t\treturn cont();\r\n\t\t\t}\r\n\t\t\tif (type == \"endTag\") {\r\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\r\n\t\t\t\tpushContext(curState.tagName, startOfLine);\r\n\t\t\t\treturn cont();\r\n\t\t\t}\r\n\t\t\treturn cont();\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction endclosetag(err) {\r\n\t\treturn function(type) {\r\n\t\t\tif (err)\r\n\t\t\t\tsetStyle = \"error\";\r\n\t\t\tif (type == \"endTag\") {\r\n\t\t\t\tpopContext();\r\n\t\t\t\treturn cont();\r\n\t\t\t}\r\n\t\t\tsetStyle = \"error\";\r\n\t\t\treturn cont(arguments.callee);\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction maybePopContext(nextTagName) {\r\n\t\tvar parentTagName;\r\n\t\twhile (true) {\r\n\t\t\tif (!curState.context) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\r\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\r\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tpopContext();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction attributes(type) {\r\n\t\tif (type == \"word\") {\r\n\t\t\tsetStyle = \"attribute\";\r\n\t\t\treturn cont(attribute, attributes);\r\n\t\t}\r\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\r\n\t\t\treturn pass();\r\n\t\tsetStyle = \"error\";\r\n\t\treturn cont(attributes);\r\n\t}\r\n\t\r\n\tfunction attribute(type) {\r\n\t\tif (type == \"equals\")\r\n\t\t\treturn cont(attvalue, attributes);\r\n\t\tif (!Kludges.allowMissing)\r\n\t\t\tsetStyle = \"error\";\r\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\r\n\t\t\t\t: cont();\r\n\t}\r\n\t\r\n\tfunction attvalue(type) {\r\n\t\tif (type == \"string\")\r\n\t\t\treturn cont(attvaluemaybe);\r\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\r\n\t\t\tsetStyle = \"string\";\r\n\t\t\treturn cont();\r\n\t\t}\r\n\t\tsetStyle = \"error\";\r\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\r\n\t\t\t\t: cont();\r\n\t}\r\n\t\r\n\tfunction attvaluemaybe(type) {\r\n\t\tif (type == \"string\")\r\n\t\t\treturn cont(attvaluemaybe);\r\n\t\telse\r\n\t\t\treturn pass();\r\n\t}\r\n\t\r\n\tfunction startState() {\r\n\t\treturn {\r\n\t\t\ttokenize : inText,\r\n\t\t\tcc : [],\r\n\t\t\tindented : 0,\r\n\t\t\tstartOfLine : true,\r\n\t\t\ttagName : null,\r\n\t\t\tcontext : null\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction token(stream, state) {\r\n\t\tif (stream.sol()) {\r\n\t\t\tstate.startOfLine = true;\r\n\t\t\tstate.indented = 0;\r\n\t\t}\r\n\t\t\r\n\t\tif (stream.eatSpace())\r\n\t\t\treturn null;\r\n\r\n\t\tsetStyle = type = tagName = null;\r\n\t\tvar style = state.tokenize(stream, state);\r\n\t\tstate.type = type;\r\n\t\tif ((style || type) && style != \"comment\") {\r\n\t\t\tcurState = state;\r\n\t\t\twhile (true) {\r\n\t\t\t\tvar comb = state.cc.pop() || element;\r\n\t\t\t\tif (comb(type || style))\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tstate.startOfLine = false;\r\n\t\treturn setStyle || style;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * @memberOf emmet.xmlParser\r\n\t\t * @returns\r\n\t\t */\r\n\t\tparse: function(data, offset) {\r\n\t\t\toffset = offset || 0;\r\n\t\t\tvar state = startState();\r\n\t\t\tvar stream = stringStream.create(data);\r\n\t\t\tvar tokens = [];\r\n\t\t\twhile (!stream.eol()) {\r\n\t\t\t\ttokens.push({\r\n\t\t\t\t\ttype: token(stream, state),\r\n\t\t\t\t\tstart: stream.start + offset,\r\n\t\t\t\t\tend: stream.pos + offset\r\n\t\t\t\t});\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn tokens;\r\n\t\t}\t\t\r\n\t};\r\n});\r\n\r\n},{\"../assets/stringStream\":\"assets\\\\stringStream.js\"}],\"plugin\\\\file.js\":[function(require,module,exports){\r\n/**\r\n * Module for working with file. Shall implement\r\n * IEmmetFile interface.\r\n *\r\n * Since implementation of this module depends\r\n * greatly on current runtime, this module must be\r\n * initialized with actual implementation first\r\n * before use. E.g.\r\n * require('./plugin/file')({\r\n * \tread: function() {...}\r\n * })\r\n *\r\n * By default, this module provides Node.JS implementation\r\n */\r\n\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\tvar _transport = {};\r\n\r\n\t// hide it from Require.JS parser\r\n\t(function(r) {\r\n\t\tif (typeof define === 'undefined' || !define.amd) {\r\n\t\t\ttry {\r\n\t\t\t\tfs = r('fs');\r\n\t\t\t\tpath = r('path');\r\n\t\t\t\t_transport.http = r('http');\r\n\t\t\t\t_transport.https = r('https');\r\n\t\t\t} catch(e) { }\r\n\t\t}\r\n\t})(require);\r\n\r\n\t// module is a function that can extend itself\r\n\tmodule.exports = function(obj) {\r\n\t\tif (obj) {\r\n\t\t\tutils.extend(module.exports, obj);\r\n\t\t}\r\n\t};\r\n\r\n\tfunction bts(bytes) {\r\n\t\tvar out = [];\r\n\t\tfor (var i = 0, il = bytes.length; i < il; i++) {\r\n\t\t\tout.push(String.fromCharCode(bytes[i]));\r\n\t\t}\r\n\t\treturn out.join('');\r\n\t}\r\n\r\n\tfunction isURL(path) {\r\n\t\tvar re = /^https?:\\/\\//;\r\n\t\treturn re.test(path);\r\n\t}\r\n\r\n\treturn utils.extend(module.exports, {\r\n\t\t_parseParams: function(args) {\r\n\t\t\tvar params = {\r\n\t\t\t\tpath: args[0],\r\n\t\t\t\tsize: 0\r\n\t\t\t};\r\n\r\n\t\t\targs = utils.toArray(args, 1);\r\n\t\t\tparams.callback = args[args.length - 1];\r\n\t\t\targs = args.slice(0, args.length - 1);\r\n\t\t\tif (args.length) {\r\n\t\t\t\tparams.size = args[0];\r\n\t\t\t}\r\n\r\n\t\t\treturn params;\r\n\t\t},\r\n\r\n\t\t_read: function(params, callback) {\r\n\t\t\tif (isURL(params.path)) {\r\n\t\t\t\tvar req = _transport[/^https:/.test(params.path) ? 'https' : 'http'].get(params.path, function(res) {\r\n\t\t\t\t\tvar bufs = [];\r\n\t\t\t\t\tvar totalLength = 0;\r\n\t\t\t\t\tvar finished = false;\r\n\t\t\t\t\tres\r\n\t\t\t\t\t\t.on('data', function(chunk) {\r\n\t\t\t\t\t\t\ttotalLength += chunk.length;\r\n\t\t\t\t\t\t\tbufs.push(chunk);\r\n\t\t\t\t\t\t\tif (params.size && totalLength >= params.size) {\r\n\t\t\t\t\t\t\t\tfinished = true;\r\n\t\t\t\t\t\t\t\tcallback(null, Buffer.concat(bufs));\r\n\t\t\t\t\t\t\t\treq.abort();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on('end', function() {\r\n\t\t\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\t\t\tfinished = true;\r\n\t\t\t\t\t\t\t\tcallback(null, Buffer.concat(bufs));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t}).on('error', callback);\r\n\t\t\t} else {\r\n\t\t\t\tif (params.size) {\r\n\t\t\t\t\tvar fd = fs.openSync(params.path, 'r');\r\n\t\t\t\t\tvar buf = new Buffer(params.size);\r\n\t\t\t\t\tfs.read(fd, buf, 0, params.size, null, function(err, bytesRead) {\r\n\t\t\t\t\t\tcallback(err, buf)\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcallback(null, fs.readFileSync(params.path));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Reads binary file content and return it\r\n\t\t * @param {String} path File's relative or absolute path\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tread: function(path, size, callback) {\r\n\t\t\tvar params = this._parseParams(arguments);\r\n\t\t\tthis._read(params, function(err, buf) {\r\n\t\t\t\tparams.callback(err, err ? '' : bts(buf));\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Read file content and return it\r\n\t\t * @param {String} path File's relative or absolute path\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treadText: function(path, size, callback) {\r\n\t\t\tvar params = this._parseParams(arguments);\r\n\t\t\tthis._read(params, function(err, buf) {\r\n\t\t\t\tparams.callback(err, err ? '' : buf.toString());\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Locate <code>file_name</code> file that relates to <code>editor_file</code>.\r\n\t\t * File name may be absolute or relative path\r\n\t\t *\r\n\t\t * <b>Dealing with absolute path.</b>\r\n\t\t * Many modern editors have a \"project\" support as information unit, but you\r\n\t\t * should not rely on project path to find file with absolute path. First,\r\n\t\t * it requires user to create a project before using this method (and this\r\n\t\t * is not very convenient). Second, project path doesn't always points to\r\n\t\t * to website's document root folder: it may point, for example, to an\r\n\t\t * upper folder which contains server-side scripts.\r\n\t\t *\r\n\t\t * For better result, you should use the following algorithm in locating\r\n\t\t * absolute resources:\r\n\t\t * 1) Get parent folder for <code>editorFile</code> as a start point\r\n\t\t * 2) Append required <code>fileName</code> to start point and test if\r\n\t\t * file exists\r\n\t\t * 3) If it doesn't exists, move start point one level up (to parent folder)\r\n\t\t * and repeat step 2.\r\n\t\t *\r\n\t\t * @param {String} editorFile\r\n\t\t * @param {String} fileName\r\n\t\t * @return {String} Returns null if <code>fileName</code> cannot be located\r\n\t\t */\r\n\t\tlocateFile: function(editorFile, fileName, callback) {\r\n\t\t\tif (isURL(fileName)) {\r\n\t\t\t\treturn callback(fileName);\r\n\t\t\t}\r\n\r\n\t\t\tvar dirname = editorFile\r\n\t\t\tvar filepath;\r\n\t\t\tfileName = fileName.replace(/^\\/+/, '');\r\n\t\t\twhile (dirname && dirname !== path.dirname(dirname)) {\r\n\t\t\t\tdirname = path.dirname(dirname);\r\n\t\t\t\tfilepath = path.join(dirname, fileName);\r\n\t\t\t\tif (fs.existsSync(filepath))\r\n\t\t\t\t\treturn callback(filepath);\r\n\t\t\t}\r\n\r\n\t\t\tcallback(null);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Creates absolute path by concatenating <code>parent</code> and <code>fileName</code>.\r\n\t\t * If <code>parent</code> points to file, its parent directory is used\r\n\t\t * @param {String} parent\r\n\t\t * @param {String} fileName\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tcreatePath: function(parent, fileName, callback) {\r\n\t\t\tfs.stat(parent, function(err, stat) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\treturn callback(err);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (stat.isFile()) {\r\n\t\t\t\t\tparent = path.dirname(parent);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar filepath = path.resolve(parent, fileName);\r\n\t\t\t\tcallback(null, filepath);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Saves <code>content</code> as <code>file</code>\r\n\t\t * @param {String} file File's absolute path\r\n\t\t * @param {String} content File content\r\n\t\t */\r\n\t\tsave: function(file, content, callback) {\r\n\t\t\tfs.writeFile(file, content, 'ascii', function(err) {\r\n\t\t\t\tcallback(err ? err : null);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns file extension in lower case\r\n\t\t * @param {String} file\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetExt: function(file) {\r\n\t\t\tvar m = (file || '').match(/\\.([\\w\\-]+)$/);\r\n\t\t\treturn m ? m[1].toLowerCase() : '';\r\n\t\t}\r\n\r\n\t});\r\n});\r\n\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"resolver\\\\css.js\":[function(require,module,exports){\r\n/**\r\n * Resolver for fast CSS typing. Handles abbreviations with the following \r\n * notation:<br>\r\n * \r\n * <code>(-vendor prefix)?property(value)*(!)?</code>\r\n * \r\n * <br><br>\r\n * <b>Abbreviation handling</b><br>\r\n * \r\n * By default, Emmet searches for matching snippet definition for provided abbreviation.\r\n * If snippet wasn't found, Emmet automatically generates element with \r\n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\r\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\r\n * <br><br>\r\n * This module will capture all expanded properties and upgrade them with values, \r\n * vendor prefixes and !important declarations. All unmatched abbreviations will \r\n * be automatically transformed into <code>property-name: ${1}</code> snippets. \r\n * \r\n * <b>Vendor prefixes<b><br>\r\n * \r\n * If CSS-property is preceded with dash, resolver should output property with\r\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \r\n * abbreviation generates <code>border-radius: ${value};</code> snippet,\r\n * the <code>-brad</code> abbreviation should generate:\r\n * <pre><code>\r\n * -webkit-border-radius: ${value};\r\n * -moz-border-radius: ${value};\r\n * border-radius: ${value};\r\n * </code></pre>\r\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \r\n * supports unprefixed property.<br><br>\r\n * \r\n * Users can also provide an explicit list of one-character prefixes for any\r\n * CSS property. For example, <code>-wm-float</code> will produce\r\n * \r\n * <pre><code>\r\n * -webkit-float: ${1};\r\n * -moz-float: ${1};\r\n * float: ${1};\r\n * </code></pre>\r\n * \r\n * Although this example looks pointless, users can use this feature to write\r\n * cutting-edge properties implemented by browser vendors recently.  \r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar resources = require('../assets/resources');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar ciu = require('../assets/caniuse');\r\n\tvar utils = require('../utils/common');\r\n\tvar template = require('../utils/template');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\r\n\tvar prefixObj = {\r\n\t\t/** Real vendor prefix name */\r\n\t\tprefix: 'emmet',\r\n\t\t\r\n\t\t/** \r\n\t\t * Indicates this prefix is obsolete and should't be used when user \r\n\t\t * wants to generate all-prefixed properties\r\n\t\t */\r\n\t\tobsolete: false,\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns prefixed CSS property name\r\n\t\t * @param {String} name Unprefixed CSS property\r\n\t\t */\r\n\t\ttransformName: function(name) {\r\n\t\t\treturn '-' + this.prefix + '-' + name;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * List of unprefixed CSS properties that supported by \r\n\t\t * current prefix. This list is used to generate all-prefixed property\r\n\t\t * @returns {Array} \r\n\t\t */\r\n\t\tproperties: function() {\r\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if given property is supported by current prefix\r\n\t\t * @param name\r\n\t\t */\r\n\t\tsupports: function(name) {\r\n\t\t\treturn ~this.properties().indexOf(name);\r\n\t\t}\r\n\t};\r\n\t\r\n\t\r\n\t/** \r\n\t * List of registered one-character prefixes. Key is a one-character prefix, \r\n\t * value is an <code>prefixObj</code> object\r\n\t */\r\n\tvar vendorPrefixes = {};\r\n\t\r\n\tvar defaultValue = '${1};';\r\n\t\r\n\t// XXX module preferences\r\n\tprefs.define('css.valueSeparator', ': ',\r\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \r\n\t\t\t+ 'value when expanding CSS abbreviations.');\r\n\tprefs.define('css.propertyEnd', ';',\r\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \r\n\t\t\t+ 'when expanding CSS abbreviations.');\r\n\t\r\n\tprefs.define('stylus.valueSeparator', ' ',\r\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \r\n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\r\n\tprefs.define('stylus.propertyEnd', '',\r\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \r\n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\r\n\t\r\n\tprefs.define('sass.propertyEnd', '',\r\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \r\n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\r\n\r\n\tprefs.define('css.syntaxes', 'css, less, sass, scss, stylus, styl',\r\n\t\t\t'List of syntaxes that should be treated as CSS dialects.');\r\n\t\r\n\tprefs.define('css.autoInsertVendorPrefixes', true,\r\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \r\n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\r\n\t\t\t+ 'properties only when you put dash before abbreviation ' \r\n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you don’t ' \r\n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \r\n\t\t\t+ 'vendor-prefixed properties for you.');\r\n\r\n\tprefs.define('less.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for LESS syntax');\r\n\tprefs.define('scss.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for SCSS syntax');\r\n\tprefs.define('sass.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for SASS syntax');\r\n\tprefs.define('stylus.autoInsertVendorPrefixes', false, 'Same as <code>css.autoInsertVendorPrefixes</code> but for Stylus syntax');\r\n\t\r\n\tvar descTemplate = template('A comma-separated list of CSS properties that may have ' \r\n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\r\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\r\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \r\n\t\t+ 'have <code><%= vendor %></code> prefix.');\r\n\t\r\n\tvar descAddonTemplate = template('A comma-separated list of <em>additional</em> CSS properties ' \r\n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \r\n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \r\n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\r\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\r\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\r\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\r\n\t\r\n\t// properties list is created from cssFeatures.html file\r\n\tvar props = {\r\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\r\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\r\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, wrap-flow, wrap-margin, wrap-through, writing-mode',\r\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\r\n\t};\r\n\t\r\n\tObject.keys(props).forEach(function(k) {\r\n\t\tprefs.define('css.' + k + 'Properties', props[k], descTemplate({vendor: k}));\r\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\r\n\t});\r\n\t\r\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \r\n\t\t\t'The list of properties whose values ​​must not contain units.');\r\n\t\r\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\r\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\r\n\t\r\n\tprefs.define('css.keywords', 'auto, inherit, all', \r\n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\r\n\t\r\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \r\n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\r\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\r\n\t\r\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \r\n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\r\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\r\n\t\r\n\tprefs.define('css.color.short', true, \r\n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\r\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\r\n\t\r\n\tprefs.define('css.color.case', 'keep', \r\n\t\t\t'Letter case of color values generated by abbreviations with color '\r\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\r\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\r\n\t\r\n\tprefs.define('css.fuzzySearch', true, \r\n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \r\n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\r\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\r\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \r\n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\r\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\r\n\t\t\t+ '<code>oh</code>');\r\n\t\r\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \r\n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \r\n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\r\n\t\t\t+ 'higher values may reduce possible matches.');\r\n\t\r\n\tprefs.define('css.alignVendor', false, \r\n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \r\n\t\t\t+ 'will be aligned by real property name.');\r\n\t\r\n\t\r\n\tfunction isNumeric(ch) {\r\n\t\tvar code = ch && ch.charCodeAt(0);\r\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if provided snippet contains only one CSS property and value.\r\n\t * @param {String} snippet\r\n\t * @returns {Boolean}\r\n\t */\r\n\tfunction isSingleProperty(snippet) {\r\n\t\tsnippet = utils.trim(snippet);\r\n\t\t\r\n\t\t// check if it doesn't contain a comment and a newline\r\n\t\tif (/\\/\\*|\\n|\\r/.test(snippet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// check if it's a valid snippet definition\r\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\treturn snippet.replace(/\\$\\{.+?\\}/g, '').split(':').length == 2;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Normalizes abbreviated value to final CSS one\r\n\t * @param {String} value\r\n\t * @returns {String}\r\n\t */\r\n\tfunction normalizeValue(value) {\r\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\r\n\t\t\tvalue = value.replace(/^\\-+/, '');\r\n\t\t}\r\n\t\t\r\n\t\tvar ch = value.charAt(0);\r\n\t\tif (ch == '#') {\r\n\t\t\treturn normalizeHexColor(value);\r\n\t\t}\r\n\r\n\t\tif (ch == '$') {\r\n\t\t\treturn utils.escapeText(value);\r\n\t\t}\r\n\r\n\t\treturn getKeyword(value);\r\n\t}\r\n\t\r\n\tfunction normalizeHexColor(value) {\r\n\t\tvar hex = value.replace(/^#+/, '') || '0';\r\n\t\tif (hex.toLowerCase() == 't') {\r\n\t\t\treturn 'transparent';\r\n\t\t}\r\n\r\n\t\tvar opacity = '';\r\n\t\thex = hex.replace(/\\.(\\d+)$/, function(str) {\r\n\t\t\topacity = '0' + str;\r\n\t\t\treturn '';\r\n\t\t});\r\n\t\t\r\n\t\tvar repeat = utils.repeatString;\r\n\t\tvar color = null;\r\n\t\tswitch (hex.length) {\r\n\t\t\tcase 1:\r\n\t\t\t\tcolor = repeat(hex, 6);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tcolor = repeat(hex, 3);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tcolor = hex + hex.substr(0, 2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcolor = hex + hex.charAt(0);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tcolor = hex.substr(0, 6);\r\n\t\t}\r\n\r\n\t\tif (opacity) {\r\n\t\t\treturn toRgba(color, opacity);\r\n\t\t}\r\n\t\t\r\n\t\t// color must be shortened?\r\n\t\tif (prefs.get('css.color.short')) {\r\n\t\t\tvar p = color.split('');\r\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\r\n\t\t\t\tcolor = p[0] + p[2] + p[4];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// should transform case?\r\n\t\tswitch (prefs.get('css.color.case')) {\r\n\t\t\tcase 'upper':\r\n\t\t\t\tcolor = color.toUpperCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'lower':\r\n\t\t\t\tcolor = color.toLowerCase();\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t\r\n\t\treturn '#' + color;\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms HEX color definition into RGBA one\r\n\t * @param  {String} color   HEX color, 6 characters\r\n\t * @param  {String} opacity Opacity value\r\n\t * @return {String}\r\n\t */\r\n\tfunction toRgba(color, opacity) {\r\n\t\tvar r = parseInt(color.substr(0, 2), 16);\r\n\t\tvar g = parseInt(color.substr(2, 2), 16);\r\n\t\tvar b = parseInt(color.substr(4, 2), 16);\r\n\r\n\t\treturn 'rgba(' + [r, g, b, opacity].join(', ') + ')';\r\n\t}\r\n\t\r\n\tfunction getKeyword(name) {\r\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\r\n\t\treturn name in aliases ? aliases[name] : name;\r\n\t}\r\n\t\r\n\tfunction getUnit(name) {\r\n\t\tvar aliases = prefs.getDict('css.unitAliases');\r\n\t\treturn name in aliases ? aliases[name] : name;\r\n\t}\r\n\t\r\n\tfunction isValidKeyword(keyword) {\r\n\t\treturn ~prefs.getArray('css.keywords').indexOf(getKeyword(keyword));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Check if passed CSS property support specified vendor prefix \r\n\t * @param {String} property\r\n\t * @param {String} prefix\r\n\t */\r\n\tfunction hasPrefix(property, prefix) {\r\n\t\tvar info = vendorPrefixes[prefix];\r\n\t\t\r\n\t\tif (!info)\r\n\t\t\tinfo = utils.find(vendorPrefixes, function(data) {\r\n\t\t\t\treturn data.prefix == prefix;\r\n\t\t\t});\r\n\t\t\r\n\t\treturn info && info.supports(property);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds available vendor prefixes for given CSS property.\r\n\t * Search is performed within Can I Use database and internal\r\n\t * property list\r\n\t * @param  {String} property CSS property name\r\n\t * @return {Array} Array of resolved prefixes or null if\r\n\t * prefixes are not available for this property at all.\r\n\t * Empty array means prefixes are not available for current\r\n\t * user-define era\r\n\t */\r\n\tfunction findVendorPrefixes(property) {\r\n\t\tvar prefixes = ciu.resolvePrefixes(property);\r\n\t\tif (!prefixes) {\r\n\t\t\t// Can I Use database is disabled or prefixes are not\r\n\t\t\t// available for this property\r\n\t\t\tprefixes = [];\r\n\t\t\tObject.keys(vendorPrefixes).forEach(function(key) {\r\n\t\t\t\tif (hasPrefix(property, key)) {\r\n\t\t\t\t\tprefixes.push(vendorPrefixes[key].prefix);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (!prefixes.length) {\r\n\t\t\t\tprefixes = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn prefixes;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Search for a list of supported prefixes for CSS property. This list\r\n\t * is used to generate all-prefixed snippet\r\n\t * @param {String} property CSS property name\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction findInternalPrefixes(property, noAutofill) {\r\n\t\tvar result = [];\r\n\t\tvar prefixes = findVendorPrefixes(property);\r\n\t\t\r\n\t\tif (prefixes) {\r\n\t\t\tvar prefixMap = {};\r\n\t\t\tObject.keys(vendorPrefixes).forEach(function(key) {\r\n\t\t\t\tprefixMap[vendorPrefixes[key].prefix] = key;\r\n\t\t\t});\r\n\r\n\t\t\tresult = prefixes.map(function(prefix) {\r\n\t\t\t\treturn prefixMap[prefix];\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tif (!result.length && !noAutofill) {\r\n\t\t\t// add all non-obsolete prefixes\r\n\t\t\tObject.keys(vendorPrefixes).forEach(function(prefix) {\r\n\t\t\t\tif (!vendorPrefixes[prefix].obsolete) {\r\n\t\t\t\t\tresult.push(prefix);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t}\r\n\t\r\n\tfunction addPrefix(name, obj) {\r\n\t\tif (typeof obj === 'string') {\r\n\t\t\tobj = {prefix: obj};\r\n\t\t}\r\n\t\t\r\n\t\tvendorPrefixes[name] = utils.extend({}, prefixObj, obj);\r\n\t}\r\n\t\r\n\tfunction getSyntaxPreference(name, syntax) {\r\n\t\tif (syntax) {\r\n\t\t\t// hacky alias for Stylus dialect\r\n\t\t\tif (syntax == 'styl') {\r\n\t\t\t\tsyntax = 'stylus';\r\n\t\t\t}\r\n\r\n\t\t\tvar val = prefs.get(syntax + '.' + name);\r\n\t\t\tif (typeof val !== 'undefined') {\r\n\t\t\t\treturn val;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn prefs.get('css.' + name);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Format CSS property according to current syntax dialect\r\n\t * @param {String} property\r\n\t * @param {String} syntax\r\n\t * @returns {String}\r\n\t */\r\n\tfunction formatProperty(property, syntax) {\r\n\t\tvar ix = property.indexOf(':');\r\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \r\n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\r\n\t\t\t+ utils.trim(property.substring(ix + 1));\r\n\t\t\r\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\r\n\t}\r\n\t\r\n\t/**\r\n\t * Transforms snippet value if required. For example, this transformation\r\n\t * may add <i>!important</i> declaration to CSS property\r\n\t * @param {String} snippet\r\n\t * @param {Boolean} isImportant\r\n\t * @returns {String}\r\n\t */\r\n\tfunction transformSnippet(snippet, isImportant, syntax) {\r\n\t\tif (typeof snippet !== 'string') {\r\n\t\t\tsnippet = snippet.data;\r\n\t\t}\r\n\t\t\r\n\t\tif (!isSingleProperty(snippet)) {\r\n\t\t\treturn snippet;\r\n\t\t}\r\n\t\t\r\n\t\tif (isImportant) {\r\n\t\t\tif (~snippet.indexOf(';')) {\r\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\r\n\t\t\t} else {\r\n\t\t\t\tsnippet += ' !important';\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn formatProperty(snippet, syntax);\r\n\t}\r\n\t\r\n\tfunction getProperties(key) {\r\n\t\tvar list = prefs.getArray(key);\r\n\t\tvar addon = prefs.getArray(key + 'Addon');\r\n\t\tif (addon) {\r\n\t\t\taddon.forEach(function(prop) {\r\n\t\t\t\tif (prop.charAt(0) == '-') {\r\n\t\t\t\t\tlist = utils.without(list, prop.substr(1));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (prop.charAt(0) == '+')\r\n\t\t\t\t\t\tprop = prop.substr(1);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlist.push(prop);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn list;\r\n\t}\r\n\r\n\t/**\r\n\t * Tries to produce properties with vendor-prefixed value\r\n\t * @param  {Object} snippetObj Parsed snippet object\r\n\t * @return {Array} Array of properties with prefixed values\r\n\t */\r\n\tfunction resolvePrefixedValues(snippetObj, isImportant, syntax) {\r\n\t\tvar prefixes = [];\r\n\t\tvar lookup = {};\r\n\r\n\t\tvar parts = cssEditTree.findParts(snippetObj.value);\r\n\t\tparts.reverse();\r\n\t\tparts.forEach(function(p) {\r\n\t\t\tvar partValue = p.substring(snippetObj.value);\r\n\t\t\t(findVendorPrefixes(partValue) || []).forEach(function(prefix) {\r\n\t\t\t\tif (!lookup[prefix]) {\r\n\t\t\t\t\tlookup[prefix] = snippetObj.value;\r\n\t\t\t\t\tprefixes.push(prefix);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlookup[prefix] = utils.replaceSubstring(lookup[prefix], '-' + prefix + '-' + partValue, p);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn prefixes.map(function(prefix) {\r\n\t\t\treturn transformSnippet(snippetObj.name + ':' + lookup[prefix], isImportant, syntax);\r\n\t\t});\r\n\t}\r\n\t\r\n\t\r\n\t// TODO refactor, this looks awkward now\r\n\taddPrefix('w', {\r\n\t\tprefix: 'webkit'\r\n\t});\r\n\taddPrefix('m', {\r\n\t\tprefix: 'moz'\r\n\t});\r\n\taddPrefix('s', {\r\n\t\tprefix: 'ms'\r\n\t});\r\n\taddPrefix('o', {\r\n\t\tprefix: 'o'\r\n\t});\r\n\t\r\n\t\r\n\tmodule = module || {};\r\n\tmodule.exports = {\r\n\t\t/**\r\n\t\t * Adds vendor prefix\r\n\t\t * @param {String} name One-character prefix name\r\n\t\t * @param {Object} obj Object describing vendor prefix\r\n\t\t * @memberOf cssResolver\r\n\t\t */\r\n\t\taddPrefix: addPrefix,\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed CSS property supports specified vendor prefix\r\n\t\t * @param {String} property\r\n\t\t * @param {String} prefix\r\n\t\t */\r\n\t\tsupportsPrefix: hasPrefix,\r\n\r\n\t\tresolve: function(node, syntax) {\r\n\t\t\tvar cssSyntaxes = prefs.getArray('css.syntaxes');\r\n\t\t\tif (cssSyntaxes && ~cssSyntaxes.indexOf(syntax) && node.isElement()) {\r\n\t\t\t\treturn this.expandToSnippet(node.abbreviation, syntax);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns prefixed version of passed CSS property, only if this\r\n\t\t * property supports such prefix\r\n\t\t * @param {String} property\r\n\t\t * @param {String} prefix\r\n\t\t * @returns\r\n\t\t */\r\n\t\tprefixed: function(property, prefix) {\r\n\t\t\treturn hasPrefix(property, prefix) \r\n\t\t\t\t? '-' + prefix + '-' + property \r\n\t\t\t\t: property;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns list of all registered vendor prefixes\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tlistPrefixes: function() {\r\n\t\t\treturn vendorPrefixes.map(function(obj) {\r\n\t\t\t\treturn obj.prefix;\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns object describing vendor prefix\r\n\t\t * @param {String} name\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tgetPrefix: function(name) {\r\n\t\t\treturn vendorPrefixes[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes prefix object\r\n\t\t * @param {String} name\r\n\t\t */\r\n\t\tremovePrefix: function(name) {\r\n\t\t\tif (name in vendorPrefixes)\r\n\t\t\t\tdelete vendorPrefixes[name];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extract vendor prefixes from abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {Object} Object containing array of prefixes and clean \r\n\t\t * abbreviation name\r\n\t\t */\r\n\t\textractPrefixes: function(abbr) {\r\n\t\t\tif (abbr.charAt(0) != '-') {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproperty: abbr,\r\n\t\t\t\t\tprefixes: null\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\r\n\t\t\t// or just dash, meaning that user wants to produce all possible\r\n\t\t\t// prefixed properties\r\n\t\t\tvar i = 1, il = abbr.length, ch;\r\n\t\t\tvar prefixes = [];\r\n\t\t\t\r\n\t\t\twhile (i < il) {\r\n\t\t\t\tch = abbr.charAt(i);\r\n\t\t\t\tif (ch == '-') {\r\n\t\t\t\t\t// end-sequence character found, stop searching\r\n\t\t\t\t\ti++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (ch in vendorPrefixes) {\r\n\t\t\t\t\tprefixes.push(ch);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// no prefix found, meaning user want to produce all\r\n\t\t\t\t\t// vendor-prefixed properties\r\n\t\t\t\t\tprefixes.length = 0;\r\n\t\t\t\t\ti = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// reached end of abbreviation and no property name left\r\n\t\t\tif (i == il -1) {\r\n\t\t\t\ti = 1;\r\n\t\t\t\tprefixes.length = 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\tproperty: abbr.substring(i),\r\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Search for value substring in abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {String} Value substring\r\n\t\t */\r\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\r\n\t\t\tsyntax = syntax || 'css';\r\n\t\t\t\r\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\r\n\t\t\twhile (i < il) {\r\n\t\t\t\tch = abbr.charAt(i);\r\n\t\t\t\tif (isNumeric(ch) || ch == '#' || ch == '$' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\r\n\t\t\t\t\tvalue = abbr.substring(i);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// try to find keywords in abbreviation\r\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\r\n\t\t\tvar keywords = [];\r\n\t\t\t// try to extract some commonly-used properties\r\n\t\t\twhile (~property.indexOf('-') && !resources.findSnippet(syntax, property)) {\r\n\t\t\t\tvar parts = property.split('-');\r\n\t\t\t\tvar lastPart = parts.pop();\r\n\t\t\t\tif (!isValidKeyword(lastPart)) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tkeywords.unshift(lastPart);\r\n\t\t\t\tproperty = parts.join('-');\r\n\t\t\t}\r\n\r\n\t\t\treturn keywords.join('-') + value;\r\n\t\t},\r\n\t\t\r\n\t\tparseValues: function(str) {\r\n\t\t\t/** @type StringStream */\r\n\t\t\tvar stream = stringStream.create(str);\r\n\t\t\tvar values = [];\r\n\t\t\tvar ch = null;\r\n\t\t\t\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (ch == '$') {\r\n\t\t\t\t\tstream.match(/^[^\\$]+/, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t} else if (ch == '#') {\r\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+(\\.\\d+)?/i, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t} else if (ch == '-') {\r\n\t\t\t\t\tif (isValidKeyword(utils.last(values)) || \r\n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\r\n\t\t\t\t\tvalues.push(stream.current());\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn values\r\n\t\t\t\t.filter(function(item) {\r\n\t\t\t\t\treturn !!item;\r\n\t\t\t\t})\r\n\t\t\t\t.map(normalizeValue);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts values from abbreviation\r\n\t\t * @param {String} abbr\r\n\t\t * @returns {Object} Object containing array of values and clean \r\n\t\t * abbreviation name\r\n\t\t */\r\n\t\textractValues: function(abbr) {\r\n\t\t\t// search for value start\r\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\r\n\t\t\tif (!abbrValues) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tproperty: abbr,\r\n\t\t\t\t\tvalues: null\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\r\n\t\t\t\tvalues: this.parseValues(abbrValues)\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Normalizes value, defined in abbreviation.\r\n\t\t * @param {String} value\r\n\t\t * @param {String} property\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tnormalizeValue: function(value, property) {\r\n\t\t\tproperty = (property || '').toLowerCase();\r\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\r\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\r\n\t\t\t\tif (!unit && (val == '0' || ~unitlessProps.indexOf(property)))\r\n\t\t\t\t\treturn val;\r\n\t\t\t\t\r\n\t\t\t\tif (!unit)\r\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\r\n\t\t\t\t\r\n\t\t\t\treturn val + getUnit(unit);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Expands abbreviation into a snippet\r\n\t\t * @param {String} abbr Abbreviation name to expand\r\n\t\t * @param {String} value Abbreviation value\r\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\r\n\t\t * @returns {Object} Array of CSS properties and values or predefined\r\n\t\t * snippet (string or element)\r\n\t\t */\r\n\t\texpand: function(abbr, value, syntax) {\r\n\t\t\tsyntax = syntax || 'css';\r\n\t\t\tvar autoInsertPrefixes = prefs.get(syntax + '.autoInsertVendorPrefixes');\r\n\t\t\t\r\n\t\t\t// check if snippet should be transformed to !important\r\n\t\t\tvar isImportant = /^(.+)\\!$/.test(abbr);\r\n\t\t\tif (isImportant) {\r\n\t\t\t\tabbr = RegExp.$1;\r\n\t\t\t}\r\n\r\n\t\t\t// check if we have abbreviated resource\r\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\r\n\t\t\tif (snippet && !autoInsertPrefixes) {\r\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// no abbreviated resource, parse abbreviation\r\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\r\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\r\n\t\t\tvar abbrData = utils.extend(prefixData, valuesData);\r\n\r\n\t\t\tif (!snippet) {\r\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\r\n\t\t\t} else {\r\n\t\t\t\tabbrData.values = null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\r\n\t\t\t\t// let’s try fuzzy search\r\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!snippet) {\r\n\t\t\t\tif (!abbrData.property || abbrData.property.endsWith(':')) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\r\n\t\t\t} else if (typeof snippet !== 'string') {\r\n\t\t\t\tsnippet = snippet.data;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (!isSingleProperty(snippet)) {\r\n\t\t\t\treturn snippet;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\r\n\t\t\tvar result = [];\r\n\t\t\tif (!value && abbrData.values) {\r\n\t\t\t\tvalue = abbrData.values.map(function(val) {\r\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\r\n\t\t\t\t}, this).join(' ') + ';';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tsnippetObj.value = value || snippetObj.value;\r\n\r\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \r\n\t\t\t\t? findInternalPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\r\n\t\t\t\t: abbrData.prefixes;\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\tvar names = [], propName;\r\n\t\t\t(prefixes || []).forEach(function(p) {\r\n\t\t\t\tif (p in vendorPrefixes) {\r\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\r\n\t\t\t\t\tnames.push(propName);\r\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\r\n\t\t\t\t\t\t\tisImportant, syntax));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// put the original property\r\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\r\n\t\t\tnames.push(snippetObj.name);\r\n\r\n\t\t\tresult = resolvePrefixedValues(snippetObj, isImportant, syntax).concat(result);\r\n\t\t\t\r\n\t\t\tif (prefs.get('css.alignVendor')) {\r\n\t\t\t\tvar pads = utils.getStringsPads(names);\r\n\t\t\t\tresult = result.map(function(prop, i) {\r\n\t\t\t\t\treturn pads[i] + prop;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Same as <code>expand</code> method but transforms output into \r\n\t\t * Emmet snippet\r\n\t\t * @param {String} abbr\r\n\t\t * @param {String} syntax\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\texpandToSnippet: function(abbr, syntax) {\r\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\r\n\t\t\tif (snippet === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(snippet)) {\r\n\t\t\t\treturn snippet.join('\\n');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof snippet !== 'string') {\r\n\t\t\t\treturn snippet.data;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn snippet + '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Split snippet into a CSS property-value pair\r\n\t\t * @param {String} snippet\r\n\t\t */\r\n\t\tsplitSnippet: function(snippet) {\r\n\t\t\tsnippet = utils.trim(snippet);\r\n\t\t\tif (snippet.indexOf(':') == -1) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tname: snippet,\r\n\t\t\t\t\tvalue: defaultValue\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar pair = snippet.split(':');\r\n\t\t\t\r\n\t\t\treturn {\r\n\t\t\t\tname: utils.trim(pair.shift()),\r\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\r\n\t\t\t\t// where possible\r\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\tgetSyntaxPreference: getSyntaxPreference,\r\n\t\ttransformSnippet: transformSnippet,\r\n\t\tvendorPrefixes: findVendorPrefixes\r\n\t};\r\n\r\n\treturn module.exports;\r\n});\r\n},{\"../assets/caniuse\":\"assets\\\\caniuse.js\",\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/template\":\"utils\\\\template.js\"}],\"resolver\\\\cssGradient.js\":[function(require,module,exports){\r\n/**\r\n * 'Expand Abbreviation' handler that parses gradient definition from under \r\n * cursor and updates CSS rule with vendor-prefixed values.\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar prefs = require('../assets/preferences');\r\n\tvar resources = require('../assets/resources');\r\n\tvar utils = require('../utils/common');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar cssResolver = require('./css');\r\n\tvar range = require('../assets/range');\r\n\tvar cssEditTree = require('../editTree/css');\r\n\tvar editorUtils = require('../utils/editor');\r\n\tvar linearGradient = require('./gradient/linear');\r\n\r\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\r\n\t\r\n\t// XXX define preferences\r\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\r\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \r\n\t\t\t+ 'be generated.');\r\n\t\r\n\tprefs.define('css.gradient.oldWebkit', false,\r\n\t\t\t'Generate gradient definition for old Webkit implementations');\r\n\t\r\n\tprefs.define('css.gradient.omitDefaultDirection', true,\r\n\t\t'Do not output default direction definition in generated gradients.');\r\n\t\r\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\r\n\t\t'When gradient expanded outside CSS value context, it will produce '\r\n\t\t\t+ 'properties with this name.');\r\n\t\r\n\tprefs.define('css.gradient.fallback', false,\r\n\t\t\t'With this option enabled, CSS gradient generator will produce '\r\n\t\t\t+ '<code>background-color</code> property with gradient first color '\r\n\t\t\t+ 'as fallback for old browsers.');\r\n\r\n\t/**\r\n\t * Resolves property name (abbreviation): searches for snippet definition in \r\n\t * 'resources' and returns new name of matched property\r\n\t */\r\n\tfunction resolvePropertyName(name, syntax) {\r\n\t\tvar snippet = resources.findSnippet(syntax, name);\r\n\t\t\r\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\r\n\t\t\tvar minScore = parseFloat(prefs.get('css.fuzzySearchMinScore'));\r\n\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, name, minScore);\r\n\t\t}\r\n\t\t\r\n\t\tif (snippet) {\r\n\t\t\tif (typeof snippet !== 'string') {\r\n\t\t\t\tsnippet = snippet.data;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn cssResolver.splitSnippet(snippet).name;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns vendor prefixes for given gradient type\r\n\t * @param {String} type Gradient type (currently, 'linear-gradient' \r\n\t * is the only supported value)\r\n\t * @return {Array}\r\n\t */\r\n\tfunction getGradientPrefixes(type) {\r\n\t\tvar prefixes = cssResolver.vendorPrefixes(type);\r\n\t\tif (!prefixes) {\r\n\t\t\t// disabled Can I Use, fallback to property list\r\n\t\t\tprefixes = prefs.getArray('css.gradient.prefixes');\r\n\t\t}\r\n\r\n\t\treturn prefixes || [];\r\n\t}\r\n\t\r\n\tfunction getPrefixedNames(type) {\r\n\t\tvar prefixes = getGradientPrefixes(type);\r\n\t\tvar names = prefixes \r\n\t\t\t? prefixes.map(function(p) {\r\n\t\t\t\treturn '-' + p + '-' + type;\r\n\t\t\t}) \r\n\t\t\t: [];\r\n\t\t\r\n\t\tnames.push(type);\r\n\t\t\r\n\t\treturn names;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns list of CSS properties with gradient\r\n\t * @param {Array} gradient List of gradient objects\r\n\t * @param {CSSEditElement} property Original CSS property\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction getPropertiesForGradient(gradients, property) {\r\n\t\tvar props = [];\r\n\t\tvar propertyName = property.name();\r\n\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\r\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\r\n\t\t\tprops.push({\r\n\t\t\t\tname: 'background-color',\r\n\t\t\t\tvalue: '${1:' + gradients[0].gradient.colorStops[0].color + '}'\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tvar value = property.value();\r\n\t\tgetGradientPrefixes('linear-gradient').forEach(function(prefix) {\r\n\t\t\tvar name = cssResolver.prefixed(propertyName, prefix);\r\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tprops.push({\r\n\t\t\t\t\t\tname: name,\r\n\t\t\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\t\t\t\t\tprefix: prefix, \r\n\t\t\t\t\t\t\toldWebkit: true,\r\n\t\t\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t} catch(e) {}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tprops.push({\r\n\t\t\t\tname: name,\r\n\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\t\t\tprefix: prefix,\r\n\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t})\r\n\t\t\t});\r\n\t\t});\r\n\t\t\r\n\t\treturn props.sort(function(a, b) {\r\n\t\t\treturn b.name.length - a.name.length;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces old gradient definitions in given CSS property value\r\n\t * with new ones, preserving original formatting\r\n\t * @param  {Array} gradients List of CSS gradients\r\n\t * @param  {String} value     Original CSS value\r\n\t * @param  {Object} options   Options for gradient’s stringify() method\r\n\t * @return {String}\r\n\t */\r\n\tfunction insertGradientsIntoCSSValue(gradients, value, options) {\r\n\t\t// gradients *should* passed in order they actually appear in CSS property\r\n\t\t// iterate over it in backward direction to preserve gradient locations\r\n\t\toptions = options || {};\r\n\t\tgradients = utils.clone(gradients);\r\n\t\tgradients.reverse().forEach(function(item, i) {\r\n\t\t\tvar suffix = !i && options.placeholder ? options.placeholder : '';\r\n\t\t\tvar str = options.oldWebkit ? item.gradient.stringifyOldWebkit(options) : item.gradient.stringify(options);\r\n\t\t\tvalue = utils.replaceSubstring(value, str + suffix, item.matchedPart);\r\n\t\t});\r\n\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns list of properties with the same meaning \r\n\t * (e.g. vendor-prefixed + original name)\r\n\t * @param  {String} property CSS property name\r\n\t * @return {Array}\r\n\t */\r\n\tfunction similarPropertyNames(property) {\r\n\t\tif (typeof property !== 'string') {\r\n\t\t\tproperty = property.name();\r\n\t\t}\r\n\r\n\t\tvar similarProps = (cssResolver.vendorPrefixes(property) || []).map(function(prefix) {\r\n\t\t\treturn '-' + prefix + '-' + property;\r\n\t\t});\r\n\t\tsimilarProps.push(property);\r\n\t\treturn similarProps;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\r\n\t * @param {EditElement} property Matched CSS property\r\n\t * @param {Array} gradients List of gradients to insert\r\n\t */\r\n\tfunction pasteGradient(property, gradients) {\r\n\t\tvar rule = property.parent;\r\n\t\tvar alignVendor = prefs.get('css.alignVendor');\r\n\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\r\n\t\t// we may have aligned gradient definitions: find the smallest value\r\n\t\t// separator\r\n\t\tvar sep = property.styleSeparator;\r\n\t\tvar before = property.styleBefore;\r\n\t\t\r\n\t\t// first, remove all properties within CSS rule with the same name and\r\n\t\t// gradient definition\r\n\t\trule.getAll(similarPropertyNames(property)).forEach(function(item) {\r\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\r\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\r\n\t\t\t\t\tsep = item.styleSeparator;\r\n\t\t\t\t}\r\n\t\t\t\tif (item.styleBefore.length < before.length) {\r\n\t\t\t\t\tbefore = item.styleBefore;\r\n\t\t\t\t}\r\n\t\t\t\trule.remove(item);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tif (alignVendor) {\r\n\t\t\t// update prefix\r\n\t\t\tif (before != property.styleBefore) {\r\n\t\t\t\tvar fullRange = property.fullRange();\r\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\r\n\t\t\t\tproperty.styleBefore = before;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// update separator value\r\n\t\t\tif (sep != property.styleSeparator) {\r\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\r\n\t\t\t\tproperty.styleSeparator = sep;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar value = property.value();\r\n\r\n\t\t// create list of properties to insert\r\n\t\tvar propsToInsert = getPropertiesForGradient(gradients, property);\r\n\t\t\r\n\t\t// align prefixed values\r\n\t\tif (alignVendor) {\r\n\t\t\tvar names = [], values = [];\r\n\t\t\tpropsToInsert.forEach(function(item) {\r\n\t\t\t\tnames.push(item.name);\r\n\t\t\t\tvalues.push(item.value);\r\n\t\t\t});\r\n\t\t\tvalues.push(property.value());\r\n\t\t\tnames.push(property.name());\r\n\t\t\t\r\n\t\t\tvar valuePads = utils.getStringsPads(values.map(function(v) {\r\n\t\t\t\treturn v.substring(0, v.indexOf('('));\r\n\t\t\t}));\r\n\t\t\t\r\n\t\t\tvar namePads = utils.getStringsPads(names);\r\n\t\t\tproperty.name(namePads[namePads.length - 1] + property.name());\r\n\t\t\t\r\n\t\t\tpropsToInsert.forEach(function(prop, i) {\r\n\t\t\t\tprop.name = namePads[i] + prop.name;\r\n\t\t\t\tprop.value = valuePads[i] + prop.value;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tproperty.value(valuePads[valuePads.length - 1] + property.value());\r\n\t\t}\r\n\t\t\r\n\t\t// put vendor-prefixed definitions before current rule\r\n\t\tpropsToInsert.forEach(function(prop) {\r\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\r\n\t\t});\r\n\r\n\t\t// put vanilla-clean gradient definition into current rule\r\n\t\tproperty.value(insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\tplaceholder: '${2}',\r\n\t\t\tomitDefaultDirection: omitDir\r\n\t\t}));\r\n\t}\r\n\r\n\t/**\r\n\t * Validates caret position relatively to located gradients\r\n\t * in CSS rule. In other words, it checks if it’s safe to \r\n\t * expand gradients for current caret position or not.\r\n\t * \r\n\t * See issue https://github.com/sergeche/emmet-sublime/issues/411\r\n\t * \r\n\t * @param  {Array} gradients List of parsed gradients\r\n\t * @param  {Number} caretPos  Current caret position\r\n\t * @param  {String} syntax    Current document syntax\r\n\t * @return {Boolean}\r\n\t */\r\n\tfunction isValidCaretPosition(gradients, caretPos, syntax) {\r\n\t\tsyntax = syntax || 'css';\r\n\t\tif (syntax == 'css' || syntax == 'less' || syntax == 'scss') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tvar offset = gradients.property.valueRange(true).start;\r\n\t\tvar parts = gradients.gradients;\r\n\r\n\t\t// in case of preprocessors where properties are separated with\r\n\t\t// newlines, make sure there’s no gradient definition past\r\n\t\t// current caret position. \r\n\t\tfor (var i = parts.length - 1; i >= 0; i--) {\r\n\t\t\tif (parts[i].matchedPart.start + offset >= caretPos) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tmodule = module || {};\r\n\treturn module.exports = {\r\n\t\t/**\r\n\t\t * Search for gradient definitions inside CSS property value\r\n\t\t * @returns {Array} Array of matched gradients\r\n\t\t */\r\n\t\tfindGradients: function(cssProp) {\r\n\t\t\tvar value = cssProp.value();\r\n\t\t\tvar gradients = [];\r\n\t\t\tvar that = this;\r\n\t\t\tcssProp.valueParts().forEach(function(part) {\r\n\t\t\t\tvar partValue = part.substring(value);\r\n\t\t\t\tif (linearGradient.isLinearGradient(partValue)) {\r\n\t\t\t\t\tvar gradient = linearGradient.parse(partValue);\r\n\t\t\t\t\tif (gradient) {\r\n\t\t\t\t\t\tgradients.push({\r\n\t\t\t\t\t\t\tgradient: gradient,\r\n\t\t\t\t\t\t\tmatchedPart: part\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn gradients.length ? gradients : null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns list of gradients found in CSS property\r\n\t\t * of given CSS code in specified (caret) position\r\n\t\t * @param  {String} css CSS code snippet\r\n\t\t * @param  {Number} pos Character index where to start searching for CSS property\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tgradientsFromCSSProperty: function(css, pos) {\r\n\t\t\tvar cssProp = cssEditTree.propertyFromPosition(css, pos);\r\n\t\t\tif (cssProp) {\r\n\t\t\t\tvar grd = this.findGradients(cssProp);\r\n\t\t\t\tif (grd) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tproperty: cssProp,\r\n\t\t\t\t\t\tgradients: grd\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Handler for “Expand Abbreviation” action\r\n\t\t * @param  {IEmmetEditor} editor\r\n\t\t * @param  {String} syntax\r\n\t\t * @param  {String} profile\r\n\t\t * return {Boolean}\r\n\t\t */\r\n\t\texpandAbbreviationHandler: function(editor, syntax, profile) {\r\n\t\t\tvar info = editorUtils.outputInfo(editor, syntax, profile);\r\n\t\t\tif (!~cssSyntaxes.indexOf(info.syntax)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// let's see if we are expanding gradient definition\r\n\t\t\tvar caret = editor.getCaretPos();\r\n\t\t\tvar content = info.content;\r\n\t\t\tvar gradients = this.gradientsFromCSSProperty(content, caret);\r\n\t\t\tif (gradients) {\r\n\t\t\t\tif (!isValidCaretPosition(gradients, caret, info.syntax)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar cssProperty = gradients.property;\r\n\t\t\t\tvar cssRule = cssProperty.parent;\r\n\t\t\t\tvar ruleStart = cssRule.options.offset || 0;\r\n\t\t\t\tvar ruleEnd = ruleStart + cssRule.toString().length;\r\n\t\t\t\t\r\n\t\t\t\t// Handle special case:\r\n\t\t\t\t// user wrote gradient definition between existing CSS \r\n\t\t\t\t// properties and did not finished it with semicolon.\r\n\t\t\t\t// In this case, we have semicolon right after gradient \r\n\t\t\t\t// definition and re-parse rule again\r\n\t\t\t\tif (/[\\n\\r]/.test(cssProperty.value())) {\r\n\t\t\t\t\t// insert semicolon at the end of gradient definition\r\n\t\t\t\t\tvar insertPos = cssProperty.valueRange(true).start + utils.last(gradients.gradients).matchedPart.end;\r\n\t\t\t\t\tcontent = utils.replaceSubstring(content, ';', insertPos);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar _gradients = this.gradientsFromCSSProperty(content, caret);\r\n\t\t\t\t\tif (_gradients) {\r\n\t\t\t\t\t\tgradients = _gradients;\r\n\t\t\t\t\t\tcssProperty = gradients.property;\r\n\t\t\t\t\t\tcssRule = cssProperty.parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// make sure current property has terminating semicolon\r\n\t\t\t\tcssProperty.end(';');\r\n\t\t\t\t\r\n\t\t\t\t// resolve CSS property name\r\n\t\t\t\tvar resolvedName = resolvePropertyName(cssProperty.name(), syntax);\r\n\t\t\t\tif (resolvedName) {\r\n\t\t\t\t\tcssProperty.name(resolvedName);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tpasteGradient(cssProperty, gradients.gradients);\r\n\t\t\t\teditor.replaceContent(cssRule.toString(), ruleStart, ruleEnd, true);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn this.expandGradientOutsideValue(editor, syntax);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Tries to expand gradient outside CSS value \r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {String} syntax\r\n\t\t */\r\n\t\texpandGradientOutsideValue: function(editor, syntax) {\r\n\t\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\r\n\t\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\t\r\n\t\t\tif (!propertyName) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// assuming that gradient definition is written on new line,\r\n\t\t\t// do a simplified parsing\r\n\t\t\tvar content = String(editor.getContent());\r\n\t\t\t/** @type Range */\r\n\t\t\tvar lineRange = range.create(editor.getCurrentLineRange());\r\n\t\t\t\r\n\t\t\t// get line content and adjust range with padding\r\n\t\t\tvar line = lineRange.substring(content)\r\n\t\t\t\t.replace(/^\\s+/, function(pad) {\r\n\t\t\t\t\tlineRange.start += pad.length;\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t})\r\n\t\t\t\t.replace(/\\s+$/, function(pad) {\r\n\t\t\t\t\tlineRange.end -= pad.length;\r\n\t\t\t\t\treturn '';\r\n\t\t\t\t});\r\n\r\n\t\t\t// trick parser: make it think that we’re parsing actual CSS property\r\n\t\t\tvar fakeCSS = 'a{' + propertyName + ': ' + line + ';}';\r\n\t\t\tvar gradients = this.gradientsFromCSSProperty(fakeCSS, fakeCSS.length - 2);\r\n\t\t\tif (gradients) {\r\n\t\t\t\tvar props = getPropertiesForGradient(gradients.gradients, gradients.property);\r\n\t\t\t\tprops.push({\r\n\t\t\t\t\tname: gradients.property.name(),\r\n\t\t\t\t\tvalue: insertGradientsIntoCSSValue(gradients.gradients, gradients.property.value(), {\r\n\t\t\t\t\t\tplaceholder: '${2}',\r\n\t\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tvar sep = cssResolver.getSyntaxPreference('valueSeparator', syntax);\r\n\t\t\t\tvar end = cssResolver.getSyntaxPreference('propertyEnd', syntax);\r\n\t\t\t\t\r\n\t\t\t\tif (prefs.get('css.alignVendor')) {\r\n\t\t\t\t\tvar pads = utils.getStringsPads(props.map(function(prop) {\r\n\t\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\r\n\t\t\t\t\t}));\r\n\t\t\t\t\tprops.forEach(function(prop, i) {\r\n\t\t\t\t\t\tprop.value = pads[i] + prop.value;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tprops = props.map(function(item) {\r\n\t\t\t\t\treturn item.name + sep + item.value + end;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Handler for “Reflect CSS Value“ action\r\n\t\t * @param  {String} property\r\n\t\t */\r\n\t\treflectValueHandler: function(property) {\r\n\t\t\tvar omitDir = prefs.get('css.gradient.omitDefaultDirection');\r\n\t\t\tvar gradients = this.findGradients(property);\r\n\t\t\tif (!gradients) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar that = this;\r\n\t\t\tvar value = property.value();\r\n\t\t\t\r\n\t\t\t// reflect value for properties with the same name\r\n\t\t\tproperty.parent.getAll(similarPropertyNames(property)).forEach(function(prop) {\r\n\t\t\t\tif (prop === property) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// make sure current property contains gradient definition,\r\n\t\t\t\t// otherwise – skip it\r\n\t\t\t\tvar localGradients = that.findGradients(prop);\r\n\t\t\t\tif (localGradients) {\r\n\t\t\t\t\t// detect vendor prefix for current property\r\n\t\t\t\t\tvar localValue = prop.value();\r\n\t\t\t\t\tvar dfn = localGradients[0].matchedPart.substring(localValue);\r\n\t\t\t\t\tvar prefix = '';\r\n\t\t\t\t\tif (/^\\s*\\-([a-z]+)\\-/.test(dfn)) {\r\n\t\t\t\t\t\tprefix = RegExp.$1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tprop.value(insertGradientsIntoCSSValue(gradients, value, {\r\n\t\t\t\t\t\tprefix: prefix,\r\n\t\t\t\t\t\tomitDefaultDirection: omitDir\r\n\t\t\t\t\t}));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/preferences\":\"assets\\\\preferences.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/css\":\"editTree\\\\css.js\",\"../utils/common\":\"utils\\\\common.js\",\"../utils/editor\":\"utils\\\\editor.js\",\"./css\":\"resolver\\\\css.js\",\"./gradient/linear\":\"resolver\\\\gradient\\\\linear.js\"}],\"resolver\\\\gradient\\\\linear.js\":[function(require,module,exports){\r\n/**\r\n * CSS linear gradient definition\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar stringStream = require('../../assets/stringStream');\r\n\tvar utils = require('../../utils/common');\r\n\r\n\t// all directions are expressed in “new style” degrees\r\n\tvar directions = {\r\n\t\t'bottom': 0,\r\n\t\t'bottom left': 45,\r\n\t\t'left': 90,\r\n\t\t'top left': 135,\r\n\t\t'top': 180,\r\n\t\t'top right': 225,\r\n\t\t'right': 270,\r\n\t\t'bottom right': 315,\r\n\t\t\r\n\t\t'to top': 0,\r\n\t\t'to top right': 45,\r\n\t\t'to right': 90,\r\n\t\t'to bottom right': 135,\r\n\t\t'to bottom': 180,\r\n\t\t'to bottom left': 225,\r\n\t\t'to left': 270,\r\n\t\t'to top left': 315\r\n\t};\r\n\r\n\tvar defaultDirections = ['top', 'to bottom', '0deg'];\r\n\r\n\r\n\tvar reLinearGradient = /^\\s*(\\-[a-z]+\\-)?(lg|linear\\-gradient)\\s*\\(/i;\r\n\tvar reDeg = /(\\d+)deg/i;\r\n\tvar reKeyword = /top|bottom|left|right/i;\r\n\r\n\tfunction LinearGradient(dfn) {\r\n\t\tthis.colorStops = [];\r\n\t\tthis.direction = 180;\r\n\r\n\t\t// extract tokens\r\n\t\tvar stream = stringStream.create(utils.trim(dfn));\r\n\t\tvar ch, cur;\r\n\t\twhile ((ch = stream.next())) {\r\n\t\t\tif (stream.peek() == ',') {\r\n\t\t\t\t// Is it a first entry? Check if it’s a direction\r\n\t\t\t\tcur = stream.current();\r\n\r\n\t\t\t\tif (!this.colorStops.length && (reDeg.test(cur) || reKeyword.test(cur))) {\r\n\t\t\t\t\tthis.direction = resolveDirection(cur);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.addColorStop(cur);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tstream.next();\r\n\t\t\t\tstream.eatSpace();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\r\n\t\t\t\tstream.skipTo(')');\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// add last token\r\n\t\tthis.addColorStop(stream.current());\t\t\r\n\t}\r\n\r\n\tLinearGradient.prototype = {\r\n\t\ttype: 'linear-gradient',\r\n\t\taddColorStop: function(color, ix) {\r\n\t\t\tcolor = normalizeSpace(color || '');\r\n\t\t\tif (!color) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tcolor = this.parseColorStop(color);\r\n\r\n\t\t\tif (typeof ix === 'undefined') {\r\n\t\t\t\tthis.colorStops.push(color);\r\n\t\t\t} else {\r\n\t\t\t\tthis.colorStops.splice(ix, 0, color);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses color stop definition\r\n\t\t * @param {String} colorStop\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tparseColorStop: function(colorStop) {\r\n\t\t\tcolorStop = normalizeSpace(colorStop);\r\n\t\t\t\r\n\t\t\t// find color declaration\r\n\t\t\t// first, try complex color declaration, like rgb(0,0,0)\r\n\t\t\tvar color = null;\r\n\t\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\r\n\t\t\t\tcolor = c;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (!color) {\r\n\t\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\r\n\t\t\t\tvar parts = colorStop.split(' ');\r\n\t\t\t\tcolor = parts[0];\r\n\t\t\t\tcolorStop = parts[1] || '';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar result = {\r\n\t\t\t\tcolor: color\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif (colorStop) {\r\n\t\t\t\t// there's position in color stop definition\r\n\t\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\r\n\t\t\t\t\tresult.position = pos;\r\n\t\t\t\t\tif (~pos.indexOf('.')) {\r\n\t\t\t\t\t\tunit = '';\r\n\t\t\t\t\t} else if (!unit) {\r\n\t\t\t\t\t\tunit = '%';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (unit) {\r\n\t\t\t\t\t\tresult.unit = unit;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\tstringify: function(options) {\r\n\t\t\toptions = options || {};\r\n\t\t\tvar fn = 'linear-gradient';\r\n\t\t\tif (options.prefix) {\r\n\t\t\t\tfn = '-' + options.prefix + '-' + fn;\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\t// transform color-stops\r\n\t\t\tvar parts = this.colorStops.map(function(cs) {\r\n\t\t\t\tvar pos = cs.position ? ' ' + cs.position + (cs.unit || '') : '';\r\n\t\t\t\treturn cs.color + pos;\r\n\t\t\t});\r\n\r\n\t\t\tvar dir = stringifyDirection(this.direction, !!options.prefix);\r\n\t\t\tif (!options.omitDefaultDirection || !~defaultDirections.indexOf(dir)) {\r\n\t\t\t\tparts.unshift(dir);\r\n\t\t\t}\r\n\r\n\t\t\treturn fn + '(' + parts.join(', ') + ')';\r\n\t\t},\r\n\r\n\t\tstringifyOldWebkit: function() {\r\n\t\t\tvar colorStops = this.colorStops.map(function(item) {\r\n\t\t\t\treturn utils.clone(item);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// normalize color-stops position\r\n\t\t\tcolorStops.forEach(function(cs) {\r\n\t\t\t\tif (!('position' in cs)) // implied position\r\n\t\t\t\t\treturn;\r\n\t\t\t\t\r\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\r\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tthis._fillImpliedPositions(colorStops);\r\n\t\t\t\r\n\t\t\t// transform color-stops into string representation\r\n\t\t\tcolorStops = colorStops.map(function(cs, i) {\r\n\t\t\t\tif (!cs.position && !i) {\r\n\t\t\t\t\treturn 'from(' + cs.color + ')';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1) {\r\n\t\t\t\t\treturn 'to(' + cs.color + ')';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn '-webkit-gradient(linear, ' \r\n\t\t\t\t+ oldWebkitDirection((this.direction + 180) % 360)\r\n\t\t\t\t+ ', '\r\n\t\t\t\t+ colorStops.join(', ')\r\n\t\t\t\t+ ')';\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Fills-out implied positions in color-stops. This function is useful for\r\n\t\t * old Webkit gradient definitions\r\n\t\t */\r\n\t\t_fillImpliedPositions: function(colorStops) {\r\n\t\t\tvar from = 0;\r\n\t\t\t\r\n\t\t\tcolorStops.forEach(function(cs, i) {\r\n\t\t\t\t// make sure that first and last positions are defined\r\n\t\t\t\tif (!i) {\r\n\t\t\t\t\treturn cs.position = cs.position || 0;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (i == colorStops.length - 1 && !('position' in cs)) {\r\n\t\t\t\t\tcs.position = 1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif ('position' in cs) {\r\n\t\t\t\t\tvar start = colorStops[from].position || 0;\r\n\t\t\t\t\tvar step = (cs.position - start) / (i - from);\r\n\t\t\t\t\tcolorStops.slice(from, i).forEach(function(cs2, j) {\r\n\t\t\t\t\t\tcs2.position = start + step * j;\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\tfrom = i;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tvalueOf: function() {\r\n\t\t\treturn this.stringify();\r\n\t\t}\r\n\t};\r\n\r\n\tfunction normalizeSpace(str) {\r\n\t\treturn utils.trim(str).replace(/\\s+/g, ' ');\r\n\t}\r\n\r\n\t/**\r\n\t * Resolves textual direction to degrees\r\n\t * @param  {String} dir Direction to resolve\r\n\t * @return {Number}\r\n\t */\r\n\tfunction resolveDirection(dir) {\r\n\t\tif (typeof dir == 'number') {\r\n\t\t\treturn dir;\r\n\t\t}\r\n\r\n\t\tdir = normalizeSpace(dir).toLowerCase();\r\n\t\tif (reDeg.test(dir)) {\r\n\t\t\treturn +RegExp.$1;\r\n\t\t}\r\n\r\n\t\tvar prefix = /^to\\s/.test(dir) ? 'to ' : '';\r\n\t\tvar left   = ~dir.indexOf('left')   && 'left';\r\n\t\tvar right  = ~dir.indexOf('right')  && 'right';\r\n\t\tvar top    = ~dir.indexOf('top')    && 'top';\r\n\t\tvar bottom = ~dir.indexOf('bottom') && 'bottom';\r\n\r\n\t\tvar key = normalizeSpace(prefix + (top || bottom || '') + ' ' + (left || right || ''));\r\n\t\treturn directions[key] || 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Tries to find keyword for given direction, expressed in degrees\r\n\t * @param  {Number} dir Direction (degrees)\r\n\t * @param {Boolean} oldStyle Use old style keywords (e.g. \"top\" instead of \"to bottom\")\r\n\t * @return {String}     Keyword or <code>Ndeg</code> expression\r\n\t */\r\n\tfunction stringifyDirection(dir, oldStyle) {\r\n\t\tvar reNewStyle = /^to\\s/;\r\n\t\tvar keys = Object.keys(directions).filter(function(k) {\r\n\t\t\tvar hasPrefix = reNewStyle.test(k);\r\n\t\t\treturn oldStyle ? !hasPrefix : hasPrefix;\r\n\t\t});\r\n\r\n\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\tif (directions[keys[i]] == dir) {\r\n\t\t\t\treturn keys[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (oldStyle) {\r\n\t\t\tdir = (dir + 270) % 360;\r\n\t\t}\r\n\r\n\t\treturn dir + 'deg';\r\n\t}\r\n\r\n\t/**\r\n\t * Creates direction definition for old Webkit gradients\r\n\t * @param {String} direction\r\n\t * @returns {String}\r\n\t */\r\n\tfunction oldWebkitDirection(dir) {\r\n\t\tdir = stringifyDirection(dir, true);\r\n\t\t\r\n\t\tif(reDeg.test(dir)) {\r\n\t\t\tthrow \"The direction is an angle that can’t be converted.\";\r\n\t\t}\r\n\t\t\r\n\t\tvar v = function(pos) {\r\n\t\t\treturn ~dir.indexOf(pos) ? '100%' : '0';\r\n\t\t};\r\n\t\t\r\n\t\treturn v('left') + ' ' + v('top') + ', ' + v('right') + ' ' + v('bottom');\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Parses gradient definition into an object.\r\n\t\t * This object can be used to transform gradient into various\r\n\t\t * forms\r\n\t\t * @param  {String} gradient Gradient definition\r\n\t\t * @return {LinearGradient}\r\n\t\t */\r\n\t\tparse: function(gradient) {\r\n\t\t\t// cut out all redundant data\r\n\t\t\tif (this.isLinearGradient(gradient)) {\r\n\t\t\t\tgradient = gradient.replace(/^\\s*[\\-a-z]+\\s*\\(|\\)\\s*$/ig, '');\r\n\t\t\t} else {\r\n\t\t\t\tthrow 'Invalid linear gradient definition:\\n' + gradient;\r\n\t\t\t}\r\n\r\n\t\t\treturn new LinearGradient(gradient);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if given string can be parsed as linear gradient\r\n\t\t * @param  {String}  str\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisLinearGradient: function(str) {\r\n\t\t\treturn reLinearGradient.test(str);\r\n\t\t},\r\n\r\n\t\tresolveDirection: resolveDirection,\r\n\t\tstringifyDirection: stringifyDirection\r\n\t};\r\n});\r\n},{\"../../assets/stringStream\":\"assets\\\\stringStream.js\",\"../../utils/common\":\"utils\\\\common.js\"}],\"resolver\\\\tagName.js\":[function(require,module,exports){\r\n/**\r\n * Module for resolving tag names: returns best matched tag name for child\r\n * element based on passed parent's tag name. Also provides utility function\r\n * for element type detection (inline, block-level, empty)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\t\r\n\tvar elementTypes = {\r\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\r\n\t\tempty: [],\r\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\r\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\r\n\t};\r\n\t\r\n\tvar elementMap = {\r\n\t\t'p': 'span',\r\n\t\t'ul': 'li',\r\n\t\t'ol': 'li',\r\n\t\t'table': 'tr',\r\n\t\t'tr': 'td',\r\n\t\t'tbody': 'tr',\r\n\t\t'thead': 'tr',\r\n\t\t'tfoot': 'tr',\r\n\t\t'colgroup': 'col',\r\n\t\t'select': 'option',\r\n\t\t'optgroup': 'option',\r\n\t\t'audio': 'source',\r\n\t\t'video': 'source',\r\n\t\t'object': 'param',\r\n\t\t'map': 'area'\r\n\t};\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Returns best matched child element name for passed parent's\r\n\t\t * tag name\r\n\t\t * @param {String} name\r\n\t\t * @returns {String}\r\n\t\t * @memberOf tagName\r\n\t\t */\r\n\t\tresolve: function(name) {\r\n\t\t\tname = (name || '').toLowerCase();\r\n\t\t\t\r\n\t\t\tif (name in elementMap)\r\n\t\t\t\treturn this.getMapping(name);\r\n\t\t\t\r\n\t\t\tif (this.isInlineLevel(name))\r\n\t\t\t\treturn 'span';\r\n\t\t\t\r\n\t\t\treturn 'div';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns mapped child element name for passed parent's name \r\n\t\t * @param {String} name\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetMapping: function(name) {\r\n\t\t\treturn elementMap[name.toLowerCase()];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element name belongs to inline-level element\r\n\t\t * @param {String} name\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisInlineLevel: function(name) {\r\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element belongs to block-level element.\r\n\t\t * For better matching of unknown elements (for XML, for example), \r\n\t\t * you should use <code>!this.isInlineLevel(name)</code>\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisBlockLevel: function(name) {\r\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed element is void (i.e. should not have closing tag).\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisEmptyElement: function(name) {\r\n\t\t\treturn this.isTypeOf(name, 'empty');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Generic function for testing if element name belongs to specified\r\n\t\t * elements collection\r\n\t\t * @param {String} name Element name\r\n\t\t * @param {String} type Collection name\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisTypeOf: function(name, type) {\r\n\t\t\treturn ~elementTypes[type].indexOf(name);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new parent–child mapping\r\n\t\t * @param {String} parent\r\n\t\t * @param {String} child\r\n\t\t */\r\n\t\taddMapping: function(parent, child) {\r\n\t\t\telementMap[parent] = child;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes parent-child mapping\r\n\t\t */\r\n\t\tremoveMapping: function(parent) {\r\n\t\t\tif (parent in elementMap)\r\n\t\t\t\tdelete elementMap[parent];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Adds new element into collection\r\n\t\t * @param {String} name Element name\r\n\t\t * @param {String} collection Collection name\r\n\t\t */\r\n\t\taddElementToCollection: function(name, collection) {\r\n\t\t\tif (!elementTypes[collection])\r\n\t\t\t\telementTypes[collection] = [];\r\n\t\t\t\r\n\t\t\tvar col = this.getCollection(collection);\r\n\t\t\tif (!~col.indexOf(name)) {\r\n\t\t\t\tcol.push(name);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes element name from specified collection\r\n\t\t * @param {String} name Element name\r\n\t\t * @param {String} collection Collection name\r\n\t\t * @returns\r\n\t\t */\r\n\t\tremoveElementFromCollection: function(name, collection) {\r\n\t\t\tif (collection in elementTypes) {\r\n\t\t\t\telementTypes[collection] = utils.without(this.getCollection(collection), name);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns elements name collection\r\n\t\t * @param {String} name Collection name\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetCollection: function(name) {\r\n\t\t\treturn elementTypes[name];\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"snippets.json\":[function(require,module,exports){\r\nmodule.exports={\r\n\t\"variables\": {\r\n\t\t\"lang\": \"en\",\r\n\t\t\"locale\": \"en-US\",\r\n\t\t\"charset\": \"UTF-8\",\r\n\t\t\"indentation\": \"\\t\",\r\n\t\t\"newline\": \"\\n\"\r\n\t},\r\n\t\r\n\t\"css\": {\r\n\t\t\"filters\": \"css\",\r\n\t\t\"profile\": \"css\",\r\n\t\t\"snippets\": {\r\n\t\t\t\"@i\": \"@import url(|);\",\r\n\t\t\t\"@import\": \"@import url(|);\",\r\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\r\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\r\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\r\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\r\n\r\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\r\n\r\n\t\t\t\"anim\": \"animation:|;\",\r\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\r\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\r\n\t\t\t\r\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\r\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\r\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\r\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\r\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\r\n\t\t\t\r\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\r\n\t\t\t\r\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\r\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\r\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\r\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\r\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\r\n\t\t\t\r\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\r\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\r\n\t\t\t\r\n\t\t\t\"animn\": \"animation-name:${1:none};\",\r\n\r\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\r\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\r\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\r\n\r\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\r\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\r\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\r\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\r\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\r\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\r\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\r\n\t\t\t\r\n\t\t\t\"ap\": \"appearance:${none};\",\r\n\r\n\t\t\t\"!\": \"!important\",\r\n\t\t\t\"pos\": \"position:${1:relative};\",\r\n\t\t\t\"pos:s\": \"position:static;\",\r\n\t\t\t\"pos:a\": \"position:absolute;\",\r\n\t\t\t\"pos:r\": \"position:relative;\",\r\n\t\t\t\"pos:f\": \"position:fixed;\",\r\n\t\t\t\"t\": \"top:|;\",\r\n\t\t\t\"t:a\": \"top:auto;\",\r\n\t\t\t\"r\": \"right:|;\",\r\n\t\t\t\"r:a\": \"right:auto;\",\r\n\t\t\t\"b\": \"bottom:|;\",\r\n\t\t\t\"b:a\": \"bottom:auto;\",\r\n\t\t\t\"l\": \"left:|;\",\r\n\t\t\t\"l:a\": \"left:auto;\",\r\n\t\t\t\"z\": \"z-index:|;\",\r\n\t\t\t\"z:a\": \"z-index:auto;\",\r\n\t\t\t\"fl\": \"float:${1:left};\",\r\n\t\t\t\"fl:n\": \"float:none;\",\r\n\t\t\t\"fl:l\": \"float:left;\",\r\n\t\t\t\"fl:r\": \"float:right;\",\r\n\t\t\t\"cl\": \"clear:${1:both};\",\r\n\t\t\t\"cl:n\": \"clear:none;\",\r\n\t\t\t\"cl:l\": \"clear:left;\",\r\n\t\t\t\"cl:r\": \"clear:right;\",\r\n\t\t\t\"cl:b\": \"clear:both;\",\r\n\r\n\t\t\t\"colm\": \"columns:|;\",\r\n\t\t\t\"colmc\": \"column-count:|;\",\r\n\t\t\t\"colmf\": \"column-fill:|;\",\r\n\t\t\t\"colmg\": \"column-gap:|;\",\r\n\t\t\t\"colmr\": \"column-rule:|;\",\r\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\r\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\r\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\r\n\t\t\t\"colms\": \"column-span:|;\",\r\n\t\t\t\"colmw\": \"column-width:|;\",\r\n\r\n\t\t\t\"d\": \"display:${1:block};\",\r\n\t\t\t\"d:n\": \"display:none;\",\r\n\t\t\t\"d:b\": \"display:block;\",\r\n\t\t\t\"d:f\": \"display:flex;\",\r\n\t\t\t\"d:if\": \"display:inline-flex;\",\r\n\t\t\t\"d:i\": \"display:inline;\",\r\n\t\t\t\"d:ib\": \"display:inline-block;\",\r\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\r\n\t\t\t\"d:li\": \"display:list-item;\",\r\n\t\t\t\"d:ri\": \"display:run-in;\",\r\n\t\t\t\"d:cp\": \"display:compact;\",\r\n\t\t\t\"d:tb\": \"display:table;\",\r\n\t\t\t\"d:itb\": \"display:inline-table;\",\r\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\r\n\t\t\t\"d:tbcl\": \"display:table-column;\",\r\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\r\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\r\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\r\n\t\t\t\"d:tbr\": \"display:table-row;\",\r\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\r\n\t\t\t\"d:tbc\": \"display:table-cell;\",\r\n\t\t\t\"d:rb\": \"display:ruby;\",\r\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\r\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\r\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\r\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\r\n\t\t\t\"v\": \"visibility:${1:hidden};\",\r\n\t\t\t\"v:v\": \"visibility:visible;\",\r\n\t\t\t\"v:h\": \"visibility:hidden;\",\r\n\t\t\t\"v:c\": \"visibility:collapse;\",\r\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\r\n\t\t\t\"ov:v\": \"overflow:visible;\",\r\n\t\t\t\"ov:h\": \"overflow:hidden;\",\r\n\t\t\t\"ov:s\": \"overflow:scroll;\",\r\n\t\t\t\"ov:a\": \"overflow:auto;\",\r\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\r\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\r\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\r\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\r\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\r\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\r\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\r\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\r\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\r\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\r\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\r\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\r\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\r\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\r\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\r\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\r\n\t\t\t\"zoo\": \"zoom:1;\",\r\n\t\t\t\"zm\": \"zoom:1;\",\r\n\t\t\t\"cp\": \"clip:|;\",\r\n\t\t\t\"cp:a\": \"clip:auto;\",\r\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\r\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\r\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\r\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\r\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\r\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\r\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\r\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\r\n\t\t\t\"m\": \"margin:|;\",\r\n\t\t\t\"m:a\": \"margin:auto;\",\r\n\t\t\t\"mt\": \"margin-top:|;\",\r\n\t\t\t\"mt:a\": \"margin-top:auto;\",\r\n\t\t\t\"mr\": \"margin-right:|;\",\r\n\t\t\t\"mr:a\": \"margin-right:auto;\",\r\n\t\t\t\"mb\": \"margin-bottom:|;\",\r\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\r\n\t\t\t\"ml\": \"margin-left:|;\",\r\n\t\t\t\"ml:a\": \"margin-left:auto;\",\r\n\t\t\t\"p\": \"padding:|;\",\r\n\t\t\t\"pt\": \"padding-top:|;\",\r\n\t\t\t\"pr\": \"padding-right:|;\",\r\n\t\t\t\"pb\": \"padding-bottom:|;\",\r\n\t\t\t\"pl\": \"padding-left:|;\",\r\n\t\t\t\"w\": \"width:|;\",\r\n\t\t\t\"w:a\": \"width:auto;\",\r\n\t\t\t\"h\": \"height:|;\",\r\n\t\t\t\"h:a\": \"height:auto;\",\r\n\t\t\t\"maw\": \"max-width:|;\",\r\n\t\t\t\"maw:n\": \"max-width:none;\",\r\n\t\t\t\"mah\": \"max-height:|;\",\r\n\t\t\t\"mah:n\": \"max-height:none;\",\r\n\t\t\t\"miw\": \"min-width:|;\",\r\n\t\t\t\"mih\": \"min-height:|;\",\r\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\r\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\r\n\t\t\t\"ori\": \"orientation:|;\",\r\n\t\t\t\"ori:l\": \"orientation:landscape;\",\r\n\t\t\t\"ori:p\": \"orientation:portrait;\",\r\n\t\t\t\"ol\": \"outline:|;\",\r\n\t\t\t\"ol:n\": \"outline:none;\",\r\n\t\t\t\"olo\": \"outline-offset:|;\",\r\n\t\t\t\"olw\": \"outline-width:|;\",\r\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\r\n\t\t\t\"olw:m\": \"outline-width:medium;\",\r\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\r\n\t\t\t\"ols\": \"outline-style:|;\",\r\n\t\t\t\"ols:n\": \"outline-style:none;\",\r\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\r\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\r\n\t\t\t\"ols:s\": \"outline-style:solid;\",\r\n\t\t\t\"ols:db\": \"outline-style:double;\",\r\n\t\t\t\"ols:g\": \"outline-style:groove;\",\r\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\r\n\t\t\t\"ols:i\": \"outline-style:inset;\",\r\n\t\t\t\"ols:o\": \"outline-style:outset;\",\r\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\r\n\t\t\t\"olc:i\": \"outline-color:invert;\",\r\n\t\t\t\"bfv\": \"backface-visibility:|;\",\r\n\t\t\t\"bfv:h\": \"backface-visibility:hidden;\",\r\n\t\t\t\"bfv:v\": \"backface-visibility:visible;\",\r\n\t\t\t\"bd\": \"border:|;\",\r\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bd:n\": \"border:none;\",\r\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\r\n\t\t\t\"bdbk:c\": \"border-break:close;\",\r\n\t\t\t\"bdcl\": \"border-collapse:|;\",\r\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\r\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\r\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\r\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\r\n\t\t\t\"bdi\": \"border-image:url(|);\",\r\n\t\t\t\"bdi:n\": \"border-image:none;\",\r\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\r\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\r\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\r\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\r\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\r\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\r\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\r\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\r\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\r\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\r\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\r\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\r\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\r\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\r\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\r\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\r\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\r\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\r\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\r\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\r\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\r\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\r\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\r\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\r\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\r\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\r\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\r\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\r\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\r\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\r\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\r\n\t\t\t\"bdlen\": \"border-length:|;\",\r\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\r\n\t\t\t\"bdsp\": \"border-spacing:|;\",\r\n\t\t\t\"bds\": \"border-style:|;\",\r\n\t\t\t\"bds:n\": \"border-style:none;\",\r\n\t\t\t\"bds:h\": \"border-style:hidden;\",\r\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\r\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\r\n\t\t\t\"bds:s\": \"border-style:solid;\",\r\n\t\t\t\"bds:db\": \"border-style:double;\",\r\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\r\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\r\n\t\t\t\"bds:w\": \"border-style:wave;\",\r\n\t\t\t\"bds:g\": \"border-style:groove;\",\r\n\t\t\t\"bds:r\": \"border-style:ridge;\",\r\n\t\t\t\"bds:i\": \"border-style:inset;\",\r\n\t\t\t\"bds:o\": \"border-style:outset;\",\r\n\t\t\t\"bdw\": \"border-width:|;\",\r\n\t\t\t\"bdtw\": \"border-top-width:|;\",\r\n\t\t\t\"bdrw\": \"border-right-width:|;\",\r\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\r\n\t\t\t\"bdlw\": \"border-left-width:|;\",\r\n\t\t\t\"bdt\": \"border-top:|;\",\r\n\t\t\t\"bt\": \"border-top:|;\",\r\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdt:n\": \"border-top:none;\",\r\n\t\t\t\"bdts\": \"border-top-style:|;\",\r\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\r\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\r\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\r\n\t\t\t\"bdr\": \"border-right:|;\",\r\n\t\t\t\"br\": \"border-right:|;\",\r\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdr:n\": \"border-right:none;\",\r\n\t\t\t\"bdrst\": \"border-right-style:|;\",\r\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\r\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\r\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\r\n\t\t\t\"bdb\": \"border-bottom:|;\",\r\n\t\t\t\"bb\": \"border-bottom:|;\",\r\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\r\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\r\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\r\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\r\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\r\n\t\t\t\"bdl\": \"border-left:|;\",\r\n\t\t\t\"bl\": \"border-left:|;\",\r\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\r\n\t\t\t\"bdl:n\": \"border-left:none;\",\r\n\t\t\t\"bdls\": \"border-left-style:|;\",\r\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\r\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\r\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\r\n\t\t\t\"bdrs\": \"border-radius:|;\",\r\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\r\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\r\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\r\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\r\n\t\t\t\"bg\": \"background:#${1:000};\",\r\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\r\n\t\t\t\"bg:n\": \"background:none;\",\r\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\r\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\r\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\r\n\t\t\t\"bgi\": \"background-image:url(|);\",\r\n\t\t\t\"bgi:n\": \"background-image:none;\",\r\n\t\t\t\"bgr\": \"background-repeat:|;\",\r\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\r\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\r\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\r\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\r\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\r\n\t\t\t\"bga\": \"background-attachment:|;\",\r\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\r\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\r\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\r\n\t\t\t\"bgpx\": \"background-position-x:|;\",\r\n\t\t\t\"bgpy\": \"background-position-y:|;\",\r\n\t\t\t\"bgbk\": \"background-break:|;\",\r\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\r\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\r\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\r\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\r\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\r\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\r\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\r\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\r\n\t\t\t\"bgo\": \"background-origin:|;\",\r\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\r\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\r\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\r\n\t\t\t\"bgsz\": \"background-size:|;\",\r\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\r\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\r\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\r\n\t\t\t\"c\": \"color:#${1:000};\",\r\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\r\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\r\n\t\t\t\"cm\": \"/* |${child} */\",\r\n\t\t\t\"cnt\": \"content:'|';\",\r\n\t\t\t\"cnt:n\": \"content:normal;\",\r\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\r\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\r\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\r\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\r\n\t\t\t\"cnt:a\": \"content:attr(|);\",\r\n\t\t\t\"cnt:c\": \"content:counter(|);\",\r\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\r\n\r\n\t\t\t\"tbl\": \"table-layout:|;\",\r\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\r\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\r\n\t\t\t\"cps\": \"caption-side:|;\",\r\n\t\t\t\"cps:t\": \"caption-side:top;\",\r\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\r\n\t\t\t\"ec\": \"empty-cells:|;\",\r\n\t\t\t\"ec:s\": \"empty-cells:show;\",\r\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\r\n\t\t\t\"lis\": \"list-style:|;\",\r\n\t\t\t\"lis:n\": \"list-style:none;\",\r\n\t\t\t\"lisp\": \"list-style-position:|;\",\r\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\r\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\r\n\t\t\t\"list\": \"list-style-type:|;\",\r\n\t\t\t\"list:n\": \"list-style-type:none;\",\r\n\t\t\t\"list:d\": \"list-style-type:disc;\",\r\n\t\t\t\"list:c\": \"list-style-type:circle;\",\r\n\t\t\t\"list:s\": \"list-style-type:square;\",\r\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\r\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\r\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\r\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\r\n\t\t\t\"lisi\": \"list-style-image:|;\",\r\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\r\n\t\t\t\"q\": \"quotes:|;\",\r\n\t\t\t\"q:n\": \"quotes:none;\",\r\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\r\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\r\n\t\t\t\"ct\": \"content:|;\",\r\n\t\t\t\"ct:n\": \"content:normal;\",\r\n\t\t\t\"ct:oq\": \"content:open-quote;\",\r\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\r\n\t\t\t\"ct:cq\": \"content:close-quote;\",\r\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\r\n\t\t\t\"ct:a\": \"content:attr(|);\",\r\n\t\t\t\"ct:c\": \"content:counter(|);\",\r\n\t\t\t\"ct:cs\": \"content:counters(|);\",\r\n\t\t\t\"coi\": \"counter-increment:|;\",\r\n\t\t\t\"cor\": \"counter-reset:|;\",\r\n\t\t\t\"va\": \"vertical-align:${1:top};\",\r\n\t\t\t\"va:sup\": \"vertical-align:super;\",\r\n\t\t\t\"va:t\": \"vertical-align:top;\",\r\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\r\n\t\t\t\"va:m\": \"vertical-align:middle;\",\r\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\r\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\r\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\r\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\r\n\t\t\t\"ta\": \"text-align:${1:left};\",\r\n\t\t\t\"ta:l\": \"text-align:left;\",\r\n\t\t\t\"ta:c\": \"text-align:center;\",\r\n\t\t\t\"ta:r\": \"text-align:right;\",\r\n\t\t\t\"ta:j\": \"text-align:justify;\",\r\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\r\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\r\n\t\t\t\"tal:l\": \"text-align-last:left;\",\r\n\t\t\t\"tal:c\": \"text-align-last:center;\",\r\n\t\t\t\"tal:r\": \"text-align-last:right;\",\r\n\t\t\t\"td\": \"text-decoration:${1:none};\",\r\n\t\t\t\"td:n\": \"text-decoration:none;\",\r\n\t\t\t\"td:u\": \"text-decoration:underline;\",\r\n\t\t\t\"td:o\": \"text-decoration:overline;\",\r\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\r\n\t\t\t\"te\": \"text-emphasis:|;\",\r\n\t\t\t\"te:n\": \"text-emphasis:none;\",\r\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\r\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\r\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\r\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\r\n\t\t\t\"te:b\": \"text-emphasis:before;\",\r\n\t\t\t\"te:a\": \"text-emphasis:after;\",\r\n\t\t\t\"th\": \"text-height:|;\",\r\n\t\t\t\"th:a\": \"text-height:auto;\",\r\n\t\t\t\"th:f\": \"text-height:font-size;\",\r\n\t\t\t\"th:t\": \"text-height:text-size;\",\r\n\t\t\t\"th:m\": \"text-height:max-size;\",\r\n\t\t\t\"ti\": \"text-indent:|;\",\r\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\r\n\t\t\t\"tj\": \"text-justify:|;\",\r\n\t\t\t\"tj:a\": \"text-justify:auto;\",\r\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\r\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\r\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\r\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\r\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\r\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\r\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\r\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\r\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\r\n\t\t\t\"to\": \"text-outline:|;\",\r\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\r\n\t\t\t\"to:n\": \"text-outline:none;\",\r\n\t\t\t\"tr\": \"text-replace:|;\",\r\n\t\t\t\"tr:n\": \"text-replace:none;\",\r\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\r\n\t\t\t\"tt:n\": \"text-transform:none;\",\r\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\r\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\r\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\r\n\t\t\t\"tw\": \"text-wrap:|;\",\r\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\r\n\t\t\t\"tw:no\": \"text-wrap:none;\",\r\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\r\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\r\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\r\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\r\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\r\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\r\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\r\n\t\t\t\"trf\": \"transform:|;\",\r\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\r\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\r\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\r\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\r\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\r\n\t\t\t\"trf:scz\": \"transform: scaleZ(${1:z});\",\r\n\t\t\t\"trf:sc3\": \"transform: scale3d(${1:x}, ${2:y}, ${3:z});\",\r\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\r\n\t\t\t\"trf:rx\": \"transform: rotateX(${1:angle});\",\r\n\t\t\t\"trf:ry\": \"transform: rotateY(${1:angle});\",\r\n\t\t\t\"trf:rz\": \"transform: rotateZ(${1:angle});\",\r\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\r\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\r\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\r\n\t\t\t\"trf:tz\": \"transform: translateZ(${1:z});\",\r\n\t\t\t\"trf:t3\": \"transform: translate3d(${1:tx}, ${2:ty}, ${3:tz});\",\r\n\t\t\t\"trfo\": \"transform-origin:|;\",\r\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\r\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\r\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\r\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\r\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\r\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\r\n\t\t\t\"lh\": \"line-height:|;\",\r\n\t\t\t\"whs\": \"white-space:|;\",\r\n\t\t\t\"whs:n\": \"white-space:normal;\",\r\n\t\t\t\"whs:p\": \"white-space:pre;\",\r\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\r\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\r\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\r\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\r\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\r\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\r\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\r\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\r\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\r\n\t\t\t\"wob\": \"word-break:|;\",\r\n\t\t\t\"wob:n\": \"word-break:normal;\",\r\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\r\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\r\n\t\t\t\"wos\": \"word-spacing:|;\",\r\n\t\t\t\"wow\": \"word-wrap:|;\",\r\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\r\n\t\t\t\"wow:n\": \"word-wrap:none;\",\r\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\r\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\r\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\r\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\r\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\r\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\r\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\r\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\r\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\r\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\r\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\r\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\r\n\t\t\t\"lts\": \"letter-spacing:|;\",\r\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\r\n\t\t\t\"f\": \"font:|;\",\r\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\r\n\t\t\t\"fw\": \"font-weight:|;\",\r\n\t\t\t\"fw:n\": \"font-weight:normal;\",\r\n\t\t\t\"fw:b\": \"font-weight:bold;\",\r\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\r\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\r\n\t\t\t\"fs\": \"font-style:${italic};\",\r\n\t\t\t\"fs:n\": \"font-style:normal;\",\r\n\t\t\t\"fs:i\": \"font-style:italic;\",\r\n\t\t\t\"fs:o\": \"font-style:oblique;\",\r\n\t\t\t\"fv\": \"font-variant:|;\",\r\n\t\t\t\"fv:n\": \"font-variant:normal;\",\r\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\r\n\t\t\t\"fz\": \"font-size:|;\",\r\n\t\t\t\"fza\": \"font-size-adjust:|;\",\r\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\r\n\t\t\t\"ff\": \"font-family:|;\",\r\n\t\t\t\"ff:s\": \"font-family:serif;\",\r\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\r\n\t\t\t\"ff:c\": \"font-family:cursive;\",\r\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\r\n\t\t\t\"ff:m\": \"font-family:monospace;\",\r\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\r\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\r\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\r\n\t\t\t\"fef\": \"font-effect:|;\",\r\n\t\t\t\"fef:n\": \"font-effect:none;\",\r\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\r\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\r\n\t\t\t\"fef:o\": \"font-effect:outline;\",\r\n\t\t\t\"fem\": \"font-emphasize:|;\",\r\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\r\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\r\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\r\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\r\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\r\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\r\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\r\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\r\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\r\n\t\t\t\"fsm\": \"font-smooth:|;\",\r\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\r\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\r\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\r\n\t\t\t\"fst\": \"font-stretch:|;\",\r\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\r\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\r\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\r\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\r\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\r\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\r\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\r\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\r\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\r\n\t\t\t\"op\": \"opacity:|;\",\r\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\r\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\r\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\r\n\t\t\t\"rsz\": \"resize:|;\",\r\n\t\t\t\"rsz:n\": \"resize:none;\",\r\n\t\t\t\"rsz:b\": \"resize:both;\",\r\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\r\n\t\t\t\"rsz:v\": \"resize:vertical;\",\r\n\t\t\t\"cur\": \"cursor:${pointer};\",\r\n\t\t\t\"cur:a\": \"cursor:auto;\",\r\n\t\t\t\"cur:d\": \"cursor:default;\",\r\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\r\n\t\t\t\"cur:ha\": \"cursor:hand;\",\r\n\t\t\t\"cur:he\": \"cursor:help;\",\r\n\t\t\t\"cur:m\": \"cursor:move;\",\r\n\t\t\t\"cur:p\": \"cursor:pointer;\",\r\n\t\t\t\"cur:t\": \"cursor:text;\",\r\n\t\t\t\"fxd\": \"flex-direction:|;\",\r\n\t\t\t\"fxd:r\": \"flex-direction:row;\",\r\n\t\t\t\"fxd:rr\": \"flex-direction:row-reverse;\",\r\n\t\t\t\"fxd:c\": \"flex-direction:column;\",\r\n\t\t\t\"fxd:cr\": \"flex-direction:column-reverse;\",\r\n\t\t\t\"fxw\": \"flex-wrap: |;\",\r\n\t\t\t\"fxw:n\": \"flex-wrap:nowrap;\",\r\n\t\t\t\"fxw:w\": \"flex-wrap:wrap;\",\r\n\t\t\t\"fxw:wr\": \"flex-wrap:wrap-reverse;\",\r\n\t\t\t\"fxf\": \"flex-flow:|;\",\r\n\t\t\t\"jc\": \"justify-content:|;\",\r\n\t\t\t\"jc:fs\": \"justify-content:flex-start;\",\r\n\t\t\t\"jc:fe\": \"justify-content:flex-end;\",\r\n\t\t\t\"jc:c\": \"justify-content:center;\",\r\n\t\t\t\"jc:sb\": \"justify-content:space-between;\",\r\n\t\t\t\"jc:sa\": \"justify-content:space-around;\",\r\n\t\t\t\"ai\": \"align-items:|;\",\r\n\t\t\t\"ai:fs\": \"align-items:flex-start;\",\r\n\t\t\t\"ai:fe\": \"align-items:flex-end;\",\r\n\t\t\t\"ai:c\": \"align-items:center;\",\r\n\t\t\t\"ai:b\": \"align-items:baseline;\",\r\n\t\t\t\"ai:s\": \"align-items:stretch;\",\r\n\t\t\t\"ac\": \"align-content:|;\",\r\n\t\t\t\"ac:fs\": \"align-content:flex-start;\",\r\n\t\t\t\"ac:fe\": \"align-content:flex-end;\",\r\n\t\t\t\"ac:c\": \"align-content:center;\",\r\n\t\t\t\"ac:sb\": \"align-content:space-between;\",\r\n\t\t\t\"ac:sa\": \"align-content:space-around;\",\r\n\t\t\t\"ac:s\": \"align-content:stretch;\",\r\n\t\t\t\"ord\": \"order:|;\",\r\n\t\t\t\"fxg\": \"flex-grow:|;\",\r\n\t\t\t\"fxsh\": \"flex-shrink:|;\",\r\n\t\t\t\"fxb\": \"flex-basis:|;\",\r\n\t\t\t\"fx\": \"flex:|;\",\r\n\t\t\t\"as\": \"align-self:|;\",\r\n\t\t\t\"as:a\": \"align-self:auto;\",\r\n\t\t\t\"as:fs\": \"align-self:flex-start;\",\r\n\t\t\t\"as:fe\": \"align-self:flex-end;\",\r\n\t\t\t\"as:c\": \"align-self:center;\",\r\n\t\t\t\"as:b\": \"align-self:baseline;\",\r\n\t\t\t\"as:s\": \"align-self:stretch;\",\r\n\t\t\t\"pgbb\": \"page-break-before:|;\",\r\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\r\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\r\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\r\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\r\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\r\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\r\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\r\n\t\t\t\"pgba\": \"page-break-after:|;\",\r\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\r\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\r\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\r\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\r\n\t\t\t\"orp\": \"orphans:|;\",\r\n\t\t\t\"us\": \"user-select:${none};\",\r\n\t\t\t\"wid\": \"widows:|;\",\r\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\r\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\r\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\r\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\r\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"html\": {\r\n\t\t\"filters\": \"html\",\r\n\t\t\"profile\": \"html\",\r\n\t\t\"snippets\": {\r\n\t\t\t\"!!!\":    \"<!DOCTYPE html>\",\r\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\r\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\r\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\r\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\r\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\r\n\r\n\t\t\t\"c\": \"<!-- |${child} -->\",\r\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\r\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\r\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\r\n\t\t},\r\n\t\t\r\n\t\t\"abbreviations\": {\r\n\t\t\t\"!\": \"html:5\",\r\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\r\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\r\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\r\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\r\n\t\t\t\"acr|acronym\": \"<acronym title=\\\"\\\">\",\r\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\r\n\t\t\t\"basefont\": \"<basefont/>\",\r\n\t\t\t\"br\": \"<br/>\",\r\n\t\t\t\"frame\": \"<frame/>\",\r\n\t\t\t\"hr\": \"<hr/>\",\r\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\r\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\r\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\r\n\t\t\t\"col\": \"<col/>\",\r\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\r\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\r\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\r\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\r\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\r\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\r\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\r\n\t\t\t\"link:im|link:import\": \"<link rel=\\\"import\\\" href=\\\"${1:component}.html\\\" />\",\r\n\t\t\t\"meta\": \"<meta/>\",\r\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\r\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\r\n\t\t\t\"meta:edge\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:ie=edge}\\\" />\",\r\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, initial-scale=${3:1.0}\\\" />\",\r\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\r\n\t\t\t\"meta:redirect\": \"<meta http-equiv=\\\"refresh\\\" content=\\\"0; url=${1:http://example.com}\\\" />\",\r\n\t\t\t\"style\": \"<style>\",\r\n\t\t\t\"script\": \"<script !src=\\\"\\\">\",\r\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\r\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"img:s|img:srcset\": \"<img srcset=\\\"\\\" src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"img:z|img:sizes\": \"<img sizes=\\\"\\\" srcset=\\\"\\\" src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"picture\": \"<picture>\",\r\n\t\t\t\"src|source\": \"<source/>\",\r\n\t\t\t\"src:sc|source:src\": \"<source src=\\\"\\\" type=\\\"\\\"/>\",\r\n\t\t\t\"src:s|source:srcset\": \"<source srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:m|source:media\": \"<source media=\\\"(${1:min-width: })\\\" srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:t|source:type\": \"<source srcset=\\\"|\\\" type=\\\"${1:image/}\\\"/>\",\r\n\t\t\t\"src:z|source:sizes\": \"<source sizes=\\\"\\\" srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:mt|source:media:type\": \"<source media=\\\"(${1:min-width: })\\\" srcset=\\\"\\\" type=\\\"${2:image/}\\\"/>\",\r\n\t\t\t\"src:mz|source:media:sizes\": \"<source media=\\\"(${1:min-width: })\\\" sizes=\\\"\\\" srcset=\\\"\\\"/>\",\r\n\t\t\t\"src:zt|source:sizes:type\": \"<source sizes=\\\"\\\" srcset=\\\"\\\" type=\\\"${1:image/}\\\"/>\",\r\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\r\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\r\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\r\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\r\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\r\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\r\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\r\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\r\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\r\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\r\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\r\n\t\t\t\"input:h|input:hidden\": \"input[type=hidden name]\",\r\n\t\t\t\"input:t|input:text\": \"inp\",\r\n\t\t\t\"input:search\": \"inp[type=search]\",\r\n\t\t\t\"input:email\": \"inp[type=email]\",\r\n\t\t\t\"input:url\": \"inp[type=url]\",\r\n\t\t\t\"input:p|input:password\": \"inp[type=password]\",\r\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\r\n\t\t\t\"input:date\": \"inp[type=date]\",\r\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\r\n\t\t\t\"input:month\": \"inp[type=month]\",\r\n\t\t\t\"input:week\": \"inp[type=week]\",\r\n\t\t\t\"input:time\": \"inp[type=time]\",\r\n\t\t\t\"input:tel\": \"inp[type=tel]\",\r\n\t\t\t\"input:number\": \"inp[type=number]\",\r\n\t\t\t\"input:color\": \"inp[type=color]\",\r\n\t\t\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\r\n\t\t\t\"input:r|input:radio\": \"inp[type=radio]\",\r\n\t\t\t\"input:range\": \"inp[type=range]\",\r\n\t\t\t\"input:f|input:file\": \"inp[type=file]\",\r\n\t\t\t\"input:s|input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\r\n\t\t\t\"input:i|input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\r\n\t\t\t\"input:b|input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\r\n\t\t\t\"isindex\": \"<isindex/>\",\r\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\r\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\r\n\t\t\t\"select:d|select:disabled\": \"select[disabled.]\",\r\n\t\t\t\"opt|option\": \"<option value=\\\"\\\">\",\r\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\r\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\r\n\t\t\t\"menu:c|menu:context\": \"menu[type=context]>\",\r\n\t\t\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]>\",\r\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\r\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\r\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\r\n\t\t\t\"keygen\": \"<keygen/>\",\r\n\t\t\t\"command\": \"<command/>\",\r\n\t\t\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\r\n\t\t\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\r\n\t\t\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\r\n\t\t\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\r\n\t\t\t\r\n\t\t\t\"bq\": \"blockquote\",\r\n\t\t\t\"fig\": \"figure\",\r\n\t\t\t\"figc\": \"figcaption\",\r\n\t\t\t\"pic\": \"picture\",\r\n\t\t\t\"ifr\": \"iframe\",\r\n\t\t\t\"emb\": \"embed\",\r\n\t\t\t\"obj\": \"object\",\r\n\t\t\t\"cap\": \"caption\",\r\n\t\t\t\"colg\": \"colgroup\",\r\n\t\t\t\"fst\": \"fieldset\",\r\n\t\t\t\"btn\": \"button\",\r\n\t\t\t\"optg\": \"optgroup\",\r\n\t\t\t\"tarea\": \"textarea\",\r\n\t\t\t\"leg\": \"legend\",\r\n\t\t\t\"sect\": \"section\",\r\n\t\t\t\"art\": \"article\",\r\n\t\t\t\"hdr\": \"header\",\r\n\t\t\t\"ftr\": \"footer\",\r\n\t\t\t\"adr\": \"address\",\r\n\t\t\t\"dlg\": \"dialog\",\r\n\t\t\t\"str\": \"strong\",\r\n\t\t\t\"prog\": \"progress\",\r\n\t\t\t\"mn\": \"main\",\r\n\t\t\t\"tem\": \"template\",\r\n\t\t\t\"fset\": \"fieldset\",\r\n\t\t\t\"datag\": \"datagrid\",\r\n\t\t\t\"datal\": \"datalist\",\r\n\t\t\t\"kg\": \"keygen\",\r\n\t\t\t\"out\": \"output\",\r\n\t\t\t\"det\": \"details\",\r\n\t\t\t\"cmd\": \"command\",\r\n\r\n\t\t\t\"doc\": \"html>(head>meta[charset=${charset}]+meta:vp+meta:edge+title{${1:Document}})+body\",\r\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\r\n\r\n\t\t\t\"ri:d|ri:dpr\": \"img:s\",\r\n\t\t\t\"ri:v|ri:viewport\": \"img:z\",\r\n\t\t\t\"ri:a|ri:art\": \"pic>src:m+img\",\r\n\t\t\t\"ri:t|ri:type\": \"pic>src:t+img\",\r\n\r\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\r\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\r\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\r\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\r\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\r\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\r\n\t\t\t\r\n\t\t\t\"ol+\": \"ol>li\",\r\n\t\t\t\"ul+\": \"ul>li\",\r\n\t\t\t\"dl+\": \"dl>dt+dd\",\r\n\t\t\t\"map+\": \"map>area\",\r\n\t\t\t\"table+\": \"table>tr>td\",\r\n\t\t\t\"colgroup+\": \"colgroup>col\",\r\n\t\t\t\"colg+\": \"colgroup>col\",\r\n\t\t\t\"tr+\": \"tr>td\",\r\n\t\t\t\"select+\": \"select>option\",\r\n\t\t\t\"optgroup+\": \"optgroup>option\",\r\n\t\t\t\"optg+\": \"optgroup>option\",\r\n\t\t\t\"pic+\": \"picture>source:srcset+img\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"xml\": {\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\",\r\n\t\t\"filters\": \"html\"\r\n\t},\r\n\t\r\n\t\"svg\": {\r\n\t\t\"filters\": \"html\",\r\n\t\t\"profile\": \"xml\",\r\n\t\t\"snippets\": {\r\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\",\r\n\t\t\t\"svgdoc\": \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\"\r\n\t\t},\r\n\t\t\"abbreviations\": {\r\n\t\t\t\"!svg\": \"!!!+svgdoc+svg\",\r\n\t\t\t\"svg\": \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\",\r\n\t\t\t\"a\": \"<a xlink:href=\\\"\\\">\",\r\n\t\t\t\"ag\": \"altGliph\",\r\n\t\t\t\"agd\": \"altGliphDef\",\r\n\t\t\t\"agi\": \"altGliphItem\",\r\n\t\t\t\"anim|animate\": \"<animate attributeType=\\\"\\\" attributeName=\\\"\\\" from=\\\"\\\" to=\\\"\\\" dur=\\\"\\\" repeatCount=\\\"indefinite\\\">\",\r\n\t\t\t\"ac\": \"<animateColor>\",\r\n\t\t\t\"am\": \"<animateMotion>\",\r\n\t\t\t\"at\": \"<animateTransform>\",\r\n\t\t\t\"c\": \"circle\",\r\n\t\t\t\"cp\": \"colorPath\",\r\n\t\t\t\"c-p\": \"color-profile\",\r\n\t\t\t\"cur\": \"cursor\",\r\n\t\t\t\"df\": \"defs\",\r\n\t\t\t\"e|ellipse\": \"<ellipse  cx=\\\"\\\" cy=\\\"\\\" rx=\\\"\\\" ry=\\\"\\\"/>\",\r\n\t\t\t\"ff\": \"<font-face>\",\r\n\t\t\t\"fff\": \"<font-face-format>\",\r\n\t\t\t\"ffn\": \"<font-face-name>\",\r\n\t\t\t\"ffs\": \"<font-face-src>\",\r\n\t\t\t\"ffu\": \"<font-face-uri>\",\r\n\t\t\t\"fo\": \"<foreignObject>\",\r\n\t\t\t\"g\": \"<g>\",\r\n\t\t\t\"gl\": \"<glyph>\",\r\n\t\t\t\"glr\": \"<glyphRef>\",\r\n\t\t\t\"hk\": \"<hkern>\",\r\n\t\t\t\"i|image\": \"<image xlink:href=\\\"\\\" x=\\\"\\\" y=\\\"\\\" width=\\\"\\\" height=\\\"\\\"/>\",\r\n\t\t\t\"l\": \"<line>\",\r\n\t\t\t\"lg\": \"<linearGradient>\",\r\n\t\t\t\"marker\": \"<marker>\",\r\n\t\t\t\"mask\": \"<mask>\",\r\n\t\t\t\"md\": \"<metadata>\",\r\n\t\t\t\"mg\": \"<missing-glyph>\",\r\n\t\t\t\"mp\": \"<mpath>\",\r\n\t\t\t\"path\": \"<path d=\\\"\\\">\",\r\n\t\t\t\"patt\": \"<pattern>\",\r\n\t\t\t\"pg\": \"<polygon points=\\\"\\\">\",\r\n\t\t\t\"pl\": \"<polyline points=\\\"\\\">\",\r\n\t\t\t\"rg\": \"<radialGradient>\",\r\n\t\t\t\"r\": \"<rect x=\\\"\\\" y=\\\"\\\" width=\\\"\\\" height=\\\"\\\"/>\",\r\n\t\t\t\"scr\": \"<script>\",\r\n\t\t\t\"sb\": \"<symbol>\",\r\n\t\t\t\"txt\": \"<text>\",\r\n\t\t\t\"tp\": \"<textPath>\",\r\n\t\t\t\"ts\": \"<tspan>\",\r\n\t\t\t\"u|use\": \"<use xlink:href=\\\"\\\"/>\",\r\n\t\t\t\"v\": \"<view>\",\r\n\t\t\t\"vk\": \"<vkern>\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"xsl\": {\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\",\r\n\t\t\"filters\": \"html, xsl\",\r\n\t\t\"abbreviations\": {\r\n\t\t\t\"tm|tmatch\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\r\n\t\t\t\"tn|tname\": \"<xsl:template name=\\\"\\\">\",\r\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\r\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\r\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\r\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\r\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\r\n\r\n\t\t\t\"ch\": \"<xsl:choose>\",\r\n\t\t\t\"wh|xsl:when\": \"<xsl:when test=\\\"\\\">\",\r\n\t\t\t\"ot\": \"<xsl:otherwise>\",\r\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\r\n\r\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\r\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\r\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\r\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\r\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\r\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\r\n\r\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\r\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\r\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\r\n\r\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\r\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\r\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\r\n\t\t\t\"for|each\": \"<xsl:for-each select=\\\"\\\">\",\r\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\r\n\r\n\t\t\t\"com\": \"<xsl:comment>\",\r\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\r\n\t\t\t\"fall\": \"<xsl:fallback>\",\r\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\r\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\r\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\r\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\r\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\r\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\r\n\r\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\r\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\r\n\t\t}, \r\n\t\t\"snippets\": {\r\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\r\n\t\t}\r\n\t},\r\n\t\r\n\t\"haml\": {\r\n\t\t\"filters\": \"haml\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\r\n\t\"jade\": {\r\n\t\t\"filters\": \"jade\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\r\n\t\"jsx\": {\r\n\t\t\"filters\": \"jsx, html\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\r\n\t\"slim\": {\r\n\t\t\"filters\": \"slim\",\r\n\t\t\"extends\": \"html\",\r\n\t\t\"profile\": \"xml\"\r\n\t},\r\n\t\r\n\t\"scss\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\t\r\n\t\"sass\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\t\r\n\t\"less\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\t\r\n\t\"stylus\": {\r\n\t\t\"extends\": \"css\"\r\n\t},\r\n\r\n\t\"styl\": {\r\n\t\t\"extends\": \"stylus\"\r\n\t}\r\n}\r\n\r\n},{}],\"utils\\\\abbreviation.js\":[function(require,module,exports){\r\n/**\r\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\r\n * @param {Function} require\r\n * @param {Underscore} _\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar elements = require('../assets/elements');\r\n\tvar tabStops = require('../assets/tabStops');\r\n\tvar utils = require('../utils/common');\r\n\tvar tagName = require('../resolver/tagName');\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Test if passed node is unary (no closing tag)\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisUnary: function(node) {\r\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar r = node.data('resource');\r\n\t\t\treturn r && r.is_empty;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisInline: function(node) {\r\n\t\t\treturn node.isTextNode() \r\n\t\t\t\t|| !node.name() \r\n\t\t\t\t|| tagName.isInlineLevel(node.name());\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if passed node is block-level\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisBlock: function(node) {\r\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if given node is a snippet\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisSnippet: function(node) {\r\n\t\t\treturn elements.is(node.data('resource'), 'snippet');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * This function tests if passed node content contains HTML tags. \r\n\t\t * This function is mostly used for output formatting\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\thasTagsInContent: function(node) {\r\n\t\t\treturn utils.matchesTag(node.content);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if current element contains block-level children\r\n\t\t * @param {AbbreviationNode} node\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\thasBlockChildren: function(node) {\r\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \r\n\t\t\t\t|| node.children.some(function(child) {\r\n\t\t\t\t\treturn this.isBlock(child);\r\n\t\t\t\t}, this);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Utility function that inserts content instead of <code>${child}</code>\r\n\t\t * variables on <code>text</code>\r\n\t\t * @param {String} text Text where child content should be inserted\r\n\t\t * @param {String} childContent Content to insert\r\n\t\t * @param {Object} options\r\n\t\t * @returns {String\r\n\t\t */\r\n\t\tinsertChildContent: function(text, childContent, options) {\r\n\t\t\toptions = utils.extend({\r\n\t\t\t\tkeepVariable: true,\r\n\t\t\t\tappendIfNoChild: true\r\n\t\t\t}, options || {});\r\n\t\t\t\r\n\t\t\tvar childVariableReplaced = false;\r\n\t\t\ttext = tabStops.replaceVariables(text, function(variable, name, data) {\r\n\t\t\t\tvar output = variable;\r\n\t\t\t\tif (name == 'child') {\r\n\t\t\t\t\t// add correct indentation\r\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\r\n\t\t\t\t\tchildVariableReplaced = true;\r\n\t\t\t\t\tif (options.keepVariable)\r\n\t\t\t\t\t\toutput += variable;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn output;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\r\n\t\t\t\ttext += childContent;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn text;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/elements\":\"assets\\\\elements.js\",\"../assets/tabStops\":\"assets\\\\tabStops.js\",\"../resolver/tagName\":\"resolver\\\\tagName.js\",\"../utils/common\":\"utils\\\\common.js\"}],\"utils\\\\action.js\":[function(require,module,exports){\r\n/**\r\n * Utility methods for Emmet actions\r\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar cssSections = require('./cssSections');\r\n\tvar abbreviationParser = require('../parser/abbreviation');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\tvar range = require('../assets/range');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\treturn {\r\n\t\tmimeTypes: {\r\n\t\t\t'gif' : 'image/gif',\r\n\t\t\t'png' : 'image/png',\r\n\t\t\t'jpg' : 'image/jpeg',\r\n\t\t\t'jpeg': 'image/jpeg',\r\n\t\t\t'svg' : 'image/svg+xml',\r\n\t\t\t'html': 'text/html',\r\n\t\t\t'htm' : 'text/html'\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Extracts abbreviations from text stream, starting from the end\r\n\t\t * @param {String} str\r\n\t\t * @return {String} Abbreviation or empty string\r\n\t\t * @memberOf emmet.actionUtils\r\n\t\t */\r\n\t\textractAbbreviation: function(str) {\r\n\t\t\tvar curOffset = str.length;\r\n\t\t\tvar startIndex = -1;\r\n\t\t\tvar groupCount = 0;\r\n\t\t\tvar braceCount = 0;\r\n\t\t\tvar textCount = 0;\r\n\t\t\t\r\n\t\t\twhile (true) {\r\n\t\t\t\tcurOffset--;\r\n\t\t\t\tif (curOffset < 0) {\r\n\t\t\t\t\t// moved to the beginning of the line\r\n\t\t\t\t\tstartIndex = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar ch = str.charAt(curOffset);\r\n\t\t\t\t\r\n\t\t\t\tif (ch == ']') {\r\n\t\t\t\t\tbraceCount++;\r\n\t\t\t\t} else if (ch == '[') {\r\n\t\t\t\t\tif (!braceCount) { // unexpected brace\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbraceCount--;\r\n\t\t\t\t} else if (ch == '}') {\r\n\t\t\t\t\ttextCount++;\r\n\t\t\t\t} else if (ch == '{') {\r\n\t\t\t\t\tif (!textCount) { // unexpected brace\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttextCount--;\r\n\t\t\t\t} else if (ch == ')') {\r\n\t\t\t\t\tgroupCount++;\r\n\t\t\t\t} else if (ch == '(') {\r\n\t\t\t\t\tif (!groupCount) { // unexpected brace\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroupCount--;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (braceCount || textCount) \r\n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\telse if (!abbreviationParser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\r\n\t\t\t\t\t\t// found stop symbol\r\n\t\t\t\t\t\tstartIndex = curOffset + 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \r\n\t\t\t\t// found something, remove some invalid symbols from the \r\n\t\t\t\t// beginning and return abbreviation\r\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\r\n\t\t\telse\r\n\t\t\t\treturn '';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Gets image size from image byte stream.\r\n\t\t * @author http://romeda.org/rePublish/\r\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\r\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\r\n\t\t */\r\n\t\tgetImageSize: function(stream) {\r\n\t\t\tvar pngMagicNum = \"\\211PNG\\r\\n\\032\\n\",\r\n\t\t\t\tjpgMagicNum = \"\\377\\330\",\r\n\t\t\t\tgifMagicNum = \"GIF8\",\r\n\t\t\t\tpos = 0,\r\n\t\t\t\tnextByte = function() {\r\n\t\t\t\t\treturn stream.charCodeAt(pos++);\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\r\n\t\t\t\t// PNG. Easy peasy.\r\n\t\t\t\tpos = stream.indexOf('IHDR') + 4;\r\n\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth:  (nextByte() << 24) | (nextByte() << 16) | (nextByte() <<  8) | nextByte(),\r\n\t\t\t\t\theight: (nextByte() << 24) | (nextByte() << 16) | (nextByte() <<  8) | nextByte()\r\n\t\t\t\t};\r\n\t\t\t\r\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\r\n\t\t\t\tpos = 6;\r\n\t\t\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\r\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\r\n\t\t\t\t};\r\n\t\t\t\r\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\r\n\t\t\t\tpos = 2;\r\n\t\t\t\r\n\t\t\t\tvar l = stream.length;\r\n\t\t\t\twhile (pos < l) {\r\n\t\t\t\t\tif (nextByte() != 0xFF) return;\r\n\t\t\t\t\r\n\t\t\t\t\tvar marker = nextByte();\r\n\t\t\t\t\tif (marker == 0xDA) break;\r\n\t\t\t\t\r\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\r\n\t\t\t\t\r\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\r\n\t\t\t\t\t\tpos += 1;\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\theight: (nextByte() << 8) | nextByte(),\r\n\t\t\t\t\t\t\twidth: (nextByte() << 8) | nextByte()\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tpos += size - 2;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Captures context XHTML element from editor under current caret position.\r\n\t\t * This node can be used as a helper for abbreviation extraction\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tcaptureContext: function(editor, pos) {\r\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1, 'jsx': 1};\r\n\t\t\tvar syntax = editor.getSyntax();\r\n\t\t\tif (syntax in allowedSyntaxes) {\r\n\t\t\t\tvar content = editor.getContent();\r\n\t\t\t\tif (typeof pos === 'undefined') {\r\n\t\t\t\t\tpos = editor.getCaretPos();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar tag = htmlMatcher.find(content, pos);\r\n\t\t\t\tif (tag && tag.type == 'tag') {\r\n\t\t\t\t\tvar startTag = tag.open;\r\n\t\t\t\t\tvar contextNode = {\r\n\t\t\t\t\t\tname: startTag.name,\r\n\t\t\t\t\t\tattributes: [],\r\n\t\t\t\t\t\tmatch: tag\r\n\t\t\t\t\t};\r\n\t\t\t\t\t\r\n\t\t\t\t\t// parse attributes\r\n\t\t\t\t\tvar tagTree = xmlEditTree.parse(startTag.range.substring(content));\r\n\t\t\t\t\tif (tagTree) {\r\n\t\t\t\t\t\tcontextNode.attributes = tagTree.getAll().map(function(item) {\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\tname: item.name(),\r\n\t\t\t\t\t\t\t\tvalue: item.value()\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn contextNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Find expression bounds in current editor at caret position. \r\n\t\t * On each character a <code>fn</code> function will be called and must \r\n\t\t * return <code>true</code> if current character meets requirements, \r\n\t\t * <code>false</code> otherwise\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {Function} fn Function to test each character of expression\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tfindExpressionBounds: function(editor, fn) {\r\n\t\t\tvar content = String(editor.getContent());\r\n\t\t\tvar il = content.length;\r\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\r\n\t\t\tvar exprEnd = exprStart + 1;\r\n\t\t\t\t\r\n\t\t\t// start by searching left\r\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\r\n\t\t\t\r\n\t\t\t// then search right\r\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\r\n\t\t\t\r\n\t\t\tif (exprEnd > exprStart) {\r\n\t\t\t\treturn range([++exprStart, exprEnd]);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {Object} data\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tcompoundUpdate: function(editor, data) {\r\n\t\t\tif (data) {\r\n\t\t\t\tvar sel = editor.getSelectionRange();\r\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\r\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Common syntax detection method for editors that doesn’t provide any\r\n\t\t * info about current syntax scope. \r\n\t\t * @param {IEmmetEditor} editor Current editor\r\n\t\t * @param {String} hint Any syntax hint that editor can provide \r\n\t\t * for syntax detection. Default is 'html'\r\n\t\t * @returns {String} \r\n\t\t */\r\n\t\tdetectSyntax: function(editor, hint) {\r\n\t\t\tvar syntax = hint || 'html';\r\n\t\t\t\r\n\t\t\tif (!resources.hasSyntax(syntax)) {\r\n\t\t\t\tsyntax = 'html';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\r\n\t\t\t\tsyntax = 'css';\r\n\t\t\t}\r\n\r\n\t\t\tif (syntax == 'styl') {\r\n\t\t\t\tsyntax = 'stylus';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn syntax;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Common method for detecting output profile\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tdetectProfile: function(editor) {\r\n\t\t\tvar syntax = editor.getSyntax();\r\n\t\t\t\r\n\t\t\t// get profile from syntax definition\r\n\t\t\tvar profile = resources.findItem(syntax, 'profile');\r\n\t\t\tif (profile) {\r\n\t\t\t\treturn profile;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tswitch(syntax) {\r\n\t\t\t\tcase 'xml':\r\n\t\t\t\tcase 'xsl':\r\n\t\t\t\t\treturn 'xml';\r\n\t\t\t\tcase 'css':\r\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\r\n\t\t\t\t\t\treturn 'line';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'html':\r\n\t\t\t\t\tprofile = resources.getVariable('profile');\r\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\r\n\t\t\t\t\t\t// html or xhtml?\r\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn profile;\r\n\t\t\t}\r\n\r\n\t\t\treturn 'xhtml';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Tries to detect if current document is XHTML one.\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisXHTML: function(editor) {\r\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if current caret position is inside &lt;style&gt; tag\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Range} Inner range of &lt;style&gt; tag\r\n\t\t */\r\n\t\tisStyle: function(editor) {\r\n\t\t\treturn !!cssSections.styleTagRange(editor.getContent(), editor.getCaretPos());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Check if given CSS dialect is supported by CSS actions\r\n\t\t * @param  {String}  syntax\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisSupportedCSS: function(syntax) {\r\n\t\t\treturn syntax == 'css' || syntax == 'less' || syntax == 'scss';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\r\n\t\t * element\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @returns {Range} Inner range of style attribute\r\n\t\t */\r\n\t\tisInlineCSS: function(editor) {\r\n\t\t\treturn !!cssSections.styleAttrRange(editor.getContent(), editor.getCaretPos());\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/resources\":\"assets\\\\resources.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/abbreviation\":\"parser\\\\abbreviation.js\",\"./common\":\"utils\\\\common.js\",\"./cssSections\":\"utils\\\\cssSections.js\"}],\"utils\\\\base64.js\":[function(require,module,exports){\r\n/**\r\n * @author Sergey Chikuyonok (serge.che@gmail.com)\r\n * @link http://chikuyonok.ru\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n\t\r\n\treturn {\r\n\t\t/**\r\n\t\t * Encodes data using base64 algorithm\r\n\t\t * @author Tyler Akins (http://rumkin.com)\r\n\t\t * @param {String} input\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tencode : function(input) {\r\n\t\t\tvar output = [];\r\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\r\n\t\t\tvar i = 0, il = input.length, b64 = chars;\r\n\r\n\t\t\twhile (i < il) {\r\n\r\n\t\t\t\tcdp1 = input.charCodeAt(i++);\r\n\t\t\t\tcdp2 = input.charCodeAt(i++);\r\n\t\t\t\tcdp3 = input.charCodeAt(i++);\r\n\r\n\t\t\t\tchr1 = cdp1 & 0xff;\r\n\t\t\t\tchr2 = cdp2 & 0xff;\r\n\t\t\t\tchr3 = cdp3 & 0xff;\r\n\r\n\t\t\t\tenc1 = chr1 >> 2;\r\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n\t\t\t\tenc4 = chr3 & 63;\r\n\r\n\t\t\t\tif (isNaN(cdp2)) {\r\n\t\t\t\t\tenc3 = enc4 = 64;\r\n\t\t\t\t} else if (isNaN(cdp3)) {\r\n\t\t\t\t\tenc4 = 64;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\r\n\t\t\t}\r\n\r\n\t\t\treturn output.join('');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Decodes string using MIME base64 algorithm\r\n\t\t * \r\n\t\t * @author Tyler Akins (http://rumkin.com)\r\n\t\t * @param {String} data\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tdecode : function(data) {\r\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\r\n\t\t\tvar b64 = chars, il = data.length;\r\n\r\n\t\t\tif (!data) {\r\n\t\t\t\treturn data;\r\n\t\t\t}\r\n\r\n\t\t\tdata += '';\r\n\r\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\r\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\r\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\r\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\r\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\r\n\r\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\r\n\r\n\t\t\t\to1 = bits >> 16 & 0xff;\r\n\t\t\t\to2 = bits >> 8 & 0xff;\r\n\t\t\t\to3 = bits & 0xff;\r\n\r\n\t\t\t\tif (h3 == 64) {\r\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\r\n\t\t\t\t} else if (h4 == 64) {\r\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\r\n\t\t\t\t}\r\n\t\t\t} while (i < il);\r\n\r\n\t\t\treturn tmpArr.join('');\r\n\t\t}\r\n\t};\r\n});\r\n},{}],\"utils\\\\comments.js\":[function(require,module,exports){\r\n/**\r\n * Utility module for working with comments in source code\r\n * (mostly stripping it from source)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar range = require('../assets/range');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar reHasComment = /\\/\\*|\\/\\//;\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Replaces all comments in given CSS source with spaces,\r\n\t\t * which allows more reliable (and faster) token search\r\n\t\t * in CSS content\r\n\t\t * @param  {String} content CSS content\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tstrip: function(content) {\r\n\t\t\tif (!reHasComment.test(content)) {\r\n\t\t\t\treturn content;\r\n\t\t\t}\r\n\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tvar replaceRanges = [];\r\n\t\t\tvar ch, ch2;\r\n\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (ch === '/') {\r\n\t\t\t\t\tch2 = stream.peek();\r\n\t\t\t\t\tif (ch2 === '*') { // multiline CSS comment\r\n\t\t\t\t\t\tstream.start = stream.pos - 1;\r\n\r\n\t\t\t\t\t\tif (stream.skipTo('*/')) {\r\n\t\t\t\t\t\t\tstream.pos += 2;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// unclosed comment\r\n\t\t\t\t\t\t\tstream.skipToEnd();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\r\n\t\t\t\t\t} else if (ch2 === '/') {\r\n\t\t\t\t\t\t// preprocessor’s single line comments\r\n\t\t\t\t\t\tstream.start = stream.pos - 1;\r\n\t\t\t\t\t\twhile ((ch2 = stream.next())) {\r\n\t\t\t\t\t\t\tif (ch2 === '\\n' || ch2 == '\\r') {\r\n\t\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream.skipQuoted();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn utils.replaceWith(content, replaceRanges, ' ');\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\common.js\":[function(require,module,exports){\r\n/**\r\n * Common utility helper for Emmet\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar range = require('../assets/range');\r\n\r\n\t/** \r\n\t * Special token used as a placeholder for caret positions inside \r\n\t * generated output \r\n\t */\r\n\tvar caretPlaceholder = '${0}';\r\n\t\r\n\treturn {\r\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\r\n\r\n\t\tdefaultSyntax: function() {\r\n\t\t\treturn 'html';\r\n\t\t},\r\n\r\n\t\tdefaultProfile: function() {\r\n\t\t\treturn 'plain';\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\r\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \r\n\t\t * @param {String} str\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tendsWithTag: function(str) {\r\n\t\t\treturn this.reTag.test(str);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if passed symbol is a number\r\n\t\t * @param {String} ch\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tisNumeric: function(ch) {\r\n\t\t\tif (typeof(ch) == 'string')\r\n\t\t\t\tch = ch.charCodeAt(0);\r\n\t\t\t\t\r\n\t\t\treturn (ch && ch > 47 && ch < 58);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Trim whitespace from string\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\ttrim: (function() {\r\n\t\t\tif (String.prototype.trim) {\r\n\t\t\t\treturn function(text) {\r\n\t\t\t\t\treturn text ? text.trim() : '';\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function(text) {\r\n\t\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\r\n\t\t\t}\r\n\t\t})(),\r\n\t\t\r\n\t\t/**\r\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\r\n\t\t * empty lines\r\n\t\t * @param {String} text Text to split\r\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tsplitByLines: function(text, removeEmpty) {\r\n\t\t\t// IE fails to split string by regexp, \r\n\t\t\t// need to normalize newlines first\r\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\r\n\t\t\tvar nl = '\\n';\r\n\t\t\tvar lines = (text || '')\r\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\r\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\r\n\t\t\t\t.replace(/\\r/g, '\\n')\r\n\t\t\t\t.replace(/\\n/g, nl)\r\n\t\t\t\t.split(nl);\r\n\t\t\t\r\n\t\t\tif (removeEmpty) {\r\n\t\t\t\tlines = lines.filter(function(line) {\r\n\t\t\t\t\treturn line.length && !!this.trim(line);\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn lines;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Repeats string <code>howMany</code> times\r\n\t\t * @param {String} str\r\n\t\t * @param {Number} how_many\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\trepeatString: function(str, howMany) {\r\n\t\t\tvar out = '';\r\n\t\t\twhile (howMany--) {\r\n\t\t\t\tout += str;\r\n\t\t\t}\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns list of paddings that should be used to align passed string\r\n\t\t * @param {Array} strings\r\n\t\t * @returns {Array}\r\n\t\t */\r\n\t\tgetStringsPads: function(strings) {\r\n\t\t\tvar lengths = strings.map(function(s) {\r\n\t\t\t\treturn typeof s === 'string' ? s.length : +s;\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tvar max = lengths.reduce(function(prev, cur) {\r\n\t\t\t\treturn typeof prev === 'undefined' ? cur : Math.max(prev, cur);\r\n\t\t\t});\r\n\t\t\treturn lengths.map(function(l) {\r\n\t\t\t\tvar pad = max - l;\r\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Indents text with padding\r\n\t\t * @param {String} text Text to indent\r\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tpadString: function(text, pad) {\r\n\t\t\tvar result = [];\r\n\t\t\tvar lines = this.splitByLines(text);\r\n\t\t\tvar nl = '\\n';\r\n\t\t\t\t\r\n\t\t\tresult.push(lines[0]);\r\n\t\t\tfor (var j = 1; j < lines.length; j++) \r\n\t\t\t\tresult.push(nl + pad + lines[j]);\r\n\t\t\t\t\r\n\t\t\treturn result.join('');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Pad string with zeroes\r\n\t\t * @param {String} str String to pad\r\n\t\t * @param {Number} pad Desired string length\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tzeroPadString: function(str, pad) {\r\n\t\t\tvar padding = '';\r\n\t\t\tvar il = str.length;\r\n\t\t\t\t\r\n\t\t\twhile (pad > il++) padding += '0';\r\n\t\t\treturn padding + str; \r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Removes padding at the beginning of each text's line\r\n\t\t * @param {String} text\r\n\t\t * @param {String} pad\r\n\t\t */\r\n\t\tunindentString: function(text, pad) {\r\n\t\t\tvar lines = this.splitByLines(text);\r\n\t\t\tvar pl = pad.length;\r\n\t\t\tfor (var i = 0, il = lines.length, line; i < il; i++) {\r\n\t\t\t\tline = lines[i];\r\n\t\t\t\tif (line.substr(0, pl) === pad) {\r\n\t\t\t\t\tlines[i] = line.substr(pl);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn lines.join('\\n');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\r\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\r\n\t\t * @param {String} str Original string\r\n\t\t * @param {String} symbol Symbol to replace\r\n\t\t * @param {String} replace Symbol replacement. Might be a function that \r\n\t\t * returns new value\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\r\n\t\t\tvar i = 0;\r\n\t\t\tvar il = str.length;\r\n\t\t\tvar sl = symbol.length;\r\n\t\t\tvar matchCount = 0;\r\n\t\t\t\t\r\n\t\t\twhile (i < il) {\r\n\t\t\t\tif (str.charAt(i) == '\\\\') {\r\n\t\t\t\t\t// escaped symbol, skip next character\r\n\t\t\t\t\ti += sl + 1;\r\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\r\n\t\t\t\t\t// have match\r\n\t\t\t\t\tvar curSl = sl;\r\n\t\t\t\t\tmatchCount++;\r\n\t\t\t\t\tvar newValue = replace;\r\n\t\t\t\t\tif (typeof replace === 'function') {\r\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\r\n\t\t\t\t\t\tif (replaceData) {\r\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\r\n\t\t\t\t\t\t\tnewValue = replaceData[1];\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewValue = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (newValue === false) { // skip replacement\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\r\n\t\t\t\t\t// adjust indexes\r\n\t\t\t\t\til = str.length;\r\n\t\t\t\t\ti += newValue.length;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn str;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\r\n\t\t * @param {String} str String where character should be replaced\r\n\t\t * @param {String} value New value\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceCounter: function(str, value, total) {\r\n\t\t\tvar symbol = '$';\r\n\t\t\t// in case we received strings from Java, convert the to native strings\r\n\t\t\tstr = String(str);\r\n\t\t\tvalue = String(value);\r\n\t\t\t\r\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\r\n\t\t\t\tvalue = +value;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar that = this;\r\n\t\t\t\r\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\r\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\r\n\t\t\t\t\t// it's a variable, skip it\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// replace sequense of $ symbols with padded number  \r\n\t\t\t\tvar j = pos + 1;\r\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\r\n\t\t\t\tvar pad = j - pos;\r\n\t\t\t\t\r\n\t\t\t\t// get counter base\r\n\t\t\t\tvar base = 0, decrement = false, m;\r\n\t\t\t\tif ((m = str.substr(j).match(/^@(\\-?)(\\d*)/))) {\r\n\t\t\t\t\tj += m[0].length;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (m[1]) {\r\n\t\t\t\t\t\tdecrement = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tbase = parseInt(m[2] || 1, 10) - 1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (decrement && total && typeof value === 'number') {\r\n\t\t\t\t\tvalue = total - value + 1;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvalue += base;\r\n\t\t\t\t\r\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Check if string matches against <code>reTag</code> regexp. This \r\n\t\t * function may be used to test if provided string contains HTML tags\r\n\t\t * @param {String} str\r\n\t\t * @returns {Boolean}\r\n\t\t */\r\n\t\tmatchesTag: function(str) {\r\n\t\t\treturn this.reTag.test(str || '');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\r\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\r\n\t\t * to make sure that existing special characters won't be altered\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tescapeText: function(text) {\r\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tunescapeText: function(text) {\r\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns caret placeholder\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetCaretPlaceholder: function() {\r\n\t\t\treturn typeof caretPlaceholder === 'function'\r\n\t\t\t\t? caretPlaceholder.apply(this, arguments)\r\n\t\t\t\t: caretPlaceholder;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sets new representation for carets in generated output\r\n\t\t * @param {String} value New caret placeholder. Might be a \r\n\t\t * <code>Function</code>\r\n\t\t */\r\n\t\tsetCaretPlaceholder: function(value) {\r\n\t\t\tcaretPlaceholder = value;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns line padding\r\n\t\t * @param {String} line\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetLinePadding: function(line) {\r\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Helper function that returns padding of line of <code>pos</code>\r\n\t\t * position in <code>content</code>\r\n\t\t * @param {String} content\r\n\t\t * @param {Number} pos\r\n\t\t * @returns {String}\r\n\t\t */\r\n\t\tgetLinePaddingFromPosition: function(content, pos) {\r\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\r\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\r\n\t\t * regular expressions\r\n\t\t * @param {String} str\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tescapeForRegexp: function(str) {\r\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\r\n\t\t\treturn str.replace(specials, \"\\\\$&\");\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Make decimal number look good: convert it to fixed precision end remove\r\n\t\t * traling zeroes \r\n\t\t * @param {Number} num\r\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tprettifyNumber: function(num, fraction) {\r\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Replace substring of <code>str</code> with <code>value</code>\r\n\t\t * @param {String} str String where to replace substring\r\n\t\t * @param {String} value New substring value\r\n\t\t * @param {Number} start Start index of substring to replace. May also\r\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\r\n\t\t * argument is not required\r\n\t\t * @param {Number} end End index of substring to replace. If ommited, \r\n\t\t * <code>start</code> argument is used\r\n\t\t */\r\n\t\treplaceSubstring: function(str, value, start, end) {\r\n\t\t\tif (typeof start === 'object' && 'end' in start) {\r\n\t\t\t\tend = start.end;\r\n\t\t\t\tstart = start.start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof end === 'string') {\r\n\t\t\t\tend = start + end.length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (typeof end === 'undefined') {\r\n\t\t\t\tend = start;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (start < 0 || start > str.length)\r\n\t\t\t\treturn str;\r\n\t\t\t\r\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Fills substrings in `content`, defined by given ranges,\r\n\t\t * wich `ch` character\r\n\t\t * @param  {String} content\r\n\t\t * @param  {Array} ranges\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\treplaceWith: function(content, ranges, ch, noRepeat) {\r\n\t\t\tif (ranges.length) {\r\n\t\t\t\tvar offset = 0, fragments = [];\r\n\t\t\t\tranges.forEach(function(r) {\r\n\t\t\t\t\tvar repl = noRepeat ? ch : this.repeatString(ch, r[1] - r[0]);\r\n\t\t\t\t\tfragments.push(content.substring(offset, r[0]), repl);\r\n\t\t\t\t\toffset = r[1];\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\tcontent = fragments.join('') + content.substring(offset);\r\n\t\t\t}\r\n\r\n\t\t\treturn content;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Narrows down text range, adjusting selection to non-space characters\r\n\t\t * @param {String} text\r\n\t\t * @param {Number} start Starting range in <code>text</code> where \r\n\t\t * slection should be adjusted. Can also be any object that is accepted\r\n\t\t * by <code>Range</code> class\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tnarrowToNonSpace: function(text, start, end) {\r\n\t\t\tvar rng = range.create(start, end);\r\n\t\t\t\r\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\r\n\t\t\t// narrow down selection until first non-space character\r\n\t\t\twhile (rng.start < rng.end) {\r\n\t\t\t\tif (!reSpace.test(text.charAt(rng.start)))\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\trng.start++;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\twhile (rng.end > rng.start) {\r\n\t\t\t\trng.end--;\r\n\t\t\t\tif (!reSpace.test(text.charAt(rng.end))) {\r\n\t\t\t\t\trng.end++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn rng;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Find start and end index of text line for <code>from</code> index\r\n\t\t * @param {String} text \r\n\t\t * @param {Number} from\r\n\t\t */\r\n\t\tfindNewlineBounds: function(text, from) {\r\n\t\t\tvar len = text.length,\r\n\t\t\t\tstart = 0,\r\n\t\t\t\tend = len - 1, \r\n\t\t\t\tch;\r\n\r\n\t\t\t\r\n\t\t\t// search left\r\n\t\t\tfor (var i = from - 1; i > 0; i--) {\r\n\t\t\t\tch = text.charAt(i);\r\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\r\n\t\t\t\t\tstart = i + 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// search right\r\n\t\t\tfor (var j = from; j < len; j++) {\r\n\t\t\t\tch = text.charAt(j);\r\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\r\n\t\t\t\t\tend = j;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn range.create(start, end - start);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\r\n\t\t */\r\n\t\tdeepMerge: function() {\r\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\t\t\ttarget = arguments[0] || {},\r\n\t\t\t\ti = 1,\r\n\t\t\t\tlength = arguments.length;\r\n\r\n\r\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\r\n\t\t\tif (typeof target !== 'object' && typeof target !== 'function') {\r\n\t\t\t\ttarget = {};\r\n\t\t\t}\r\n\r\n\t\t\tfor ( ; i < length; i++ ) {\r\n\t\t\t\t// Only deal with non-null/undefined values\r\n\t\t\t\tif ( (options = arguments[ i ]) !== null ) {\r\n\t\t\t\t\t// Extend the base object\r\n\t\t\t\t\tfor ( name in options ) {\r\n\t\t\t\t\t\tsrc = target[ name ];\r\n\t\t\t\t\t\tcopy = options[ name ];\r\n\r\n\t\t\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\t\t\tif ( target === copy ) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\t\t\tif ( copy && ( typeof copy === 'object' || (copyIsArray = Array.isArray(copy)) ) ) {\r\n\t\t\t\t\t\t\tif ( copyIsArray ) {\r\n\t\t\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\t\t\tclone = src && Array.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tclone = src && typeof src === 'object' ? src : {};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\r\n\r\n\t\t\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\r\n\t\t\t\t\t\t\ttarget[ name ] = copy;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Return the modified object\r\n\t\t\treturn target;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Dead simple string-to-JSON parser\r\n\t\t * @param {String} str\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\tparseJSON: function(str) {\r\n\t\t\tif (typeof str == 'object') {\r\n\t\t\t\treturn str;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ttry {\r\n\t\t\t\treturn JSON.parse(str);\r\n\t\t\t} catch(e) {\r\n\t\t\t\treturn {};\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\t/**************************\r\n\t\t * Utility belt\r\n\t\t **************************/\r\n\t\tunique: function(arr, comparator) {\r\n\t\t\tvar lookup = [];\r\n\t\t\treturn arr.filter(function(item) {\r\n\t\t\t\tvar val = comparator ? comparator(item) : item;\r\n\t\t\t\tif (lookup.indexOf(val) < 0) {\r\n\t\t\t\t\tlookup.push(val);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Return a copy of the object, filtered to only have values for \r\n\t\t * the whitelisted keys. \r\n\t\t * @param  {Object} obj\r\n\t\t * @return {Object}\r\n\t\t */\r\n\t\tpick: function(obj) {\r\n\t\t\tvar result = {};\r\n\t\t\tvar keys = this.toArray(arguments, 1);\r\n\t\t\tObject.keys(obj).forEach(function(key) {\r\n\t\t\t\tif (~keys.indexOf(key)) {\r\n\t\t\t\t\tresult[key] = obj[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\tfind: function(arr, comparator, ctx) {\r\n\t\t\tvar result;\r\n\t\t\tif (ctx) {\r\n\t\t\t\tcomparator = comparator.bind(ctx);\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(arr)) {\r\n\t\t\t\tarr.some(function(item, i) {\r\n\t\t\t\t\tif (comparator(item, i)) {\r\n\t\t\t\t\t\treturn result = item;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tObject.keys(arr).some(function(key, i) {\r\n\t\t\t\t\tif (comparator(arr[key], i)) {\r\n\t\t\t\t\t\treturn result = arr[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\ttoArray: function(obj, sliceIx) {\r\n\t\t\tif (Array.isArray(obj) && !sliceIx) {\r\n\t\t\t\treturn obj;\r\n\t\t\t}\r\n\t\t\treturn Array.prototype.slice.call(obj, sliceIx || 0);\r\n\t\t},\r\n\r\n\t\textend: function(obj) {\r\n\t\t\tfor (var i = 1, il = arguments.length, a; i < il; i++) {\r\n\t\t\t\ta = arguments[i];\r\n\t\t\t\tif (a) {\r\n\t\t\t\t\tObject.keys(a).forEach(function(key) {\r\n\t\t\t\t\t\tobj[key] = a[key];\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tdefaults: function(obj) {\r\n\t\t\tfor (var i = 1, il = arguments.length, a; i < il; i++) {\r\n\t\t\t\ta = arguments[i];\r\n\t\t\t\tif (a) {\r\n\t\t\t\t\tObject.keys(a).forEach(function(key) {\r\n\t\t\t\t\t\tif (!(key in obj)) {\r\n\t\t\t\t\t\t\tobj[key] = a[key];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn obj;\r\n\t\t},\r\n\r\n\t\tflatten: function(arr, out) {\r\n\t\t\tout = out || [];\r\n\t\t\tvar self = this;\r\n\t\t\tself.toArray(arr).forEach(function(item) {\r\n\t\t\t\tif (Array.isArray(item)) {\r\n\t\t\t\t\tself.flatten(item, out);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tout.push(item);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\tclone: function(obj) {\r\n\t\t\tif (Array.isArray(obj)) {\r\n\t\t\t\treturn obj.slice(0);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.extend({}, obj);\r\n\t\t},\r\n\r\n\t\twithout: function(arr) {\r\n\t\t\tthis.toArray(arguments, 1).forEach(function(item) {\r\n\t\t\t\tvar ix;\r\n\t\t\t\twhile (~(ix = arr.indexOf(item))) {\r\n\t\t\t\t\tarr.splice(ix, 1);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn arr;\r\n\t\t},\r\n\r\n\t\tlast: function(arr) {\r\n\t\t\treturn arr[arr.length - 1];\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/range\":\"assets\\\\range.js\"}],\"utils\\\\cssSections.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar commentsUtils = require('./comments');\r\n\tvar range = require('../assets/range');\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar cssParser = require('../parser/css');\r\n\tvar htmlMatcher = require('../assets/htmlMatcher');\r\n\tvar xmlEditTree = require('../editTree/xml');\r\n\r\n\tvar idCounter = 1;\r\n\tvar maxId = 1000000;\r\n\r\n\tvar reSpaceTrim = /^(\\s*).+?(\\s*)$/;\r\n\tvar reSpace = /\\s/g;\r\n\tvar reComma = /,/;\r\n\r\n\tfunction isQuote(ch) {\r\n\t\treturn ch == '\"' || ch == \"'\";\r\n\t}\r\n\r\n\tfunction getId() {\r\n\t\tidCounter = (idCounter + 1) % maxId;\r\n\t\treturn 's' + idCounter;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Range} range Full selector range with additional\r\n\t * properties for matching name and content (@see findAllRules())\r\n\t * @param {String} source CSS source\r\n\t */\r\n\tfunction CSSSection(rng, source) {\r\n\t\tthis.id = getId();\r\n\t\t/** @type {CSSSection} */\r\n\t\tthis.parent = null;\r\n\t\t/** @type {CSSSection} */\r\n\t\tthis.nextSibling = null;\r\n\t\t/** @type {CSSSection} */\r\n\t\tthis.previousSibling = null;\r\n\t\tthis._source = source;\r\n\t\tthis._name = null;\r\n\t\tthis._content = null;\r\n\r\n\t\t/**\r\n\t\t * Custom data for current nodes, used by other modules for\r\n\t\t * caching etc.\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis._data = {};\r\n\r\n\t\tif (!rng && source) {\r\n\t\t\trng = range(0, source);\r\n\t\t}\r\n\r\n\t\tthis.range = rng;\r\n\t\tthis.children = [];\r\n\t}\r\n\r\n\tCSSSection.prototype = {\r\n\t\taddChild: function(section) {\r\n\t\t\tif (!(section instanceof CSSSection)) {\r\n\t\t\t\tsection = new CSSSection(section);\r\n\t\t\t}\r\n\r\n\t\t\tvar lastChild = utils.last(this.children);\r\n\t\t\tif (lastChild) {\r\n\t\t\t\tlastChild.nextSibling = section;\r\n\t\t\t\tsection.previousSibling = lastChild;\r\n\t\t\t}\r\n\t\t\tsection.parent = this;\r\n\r\n\t\t\tthis.children.push(section);\r\n\t\t\treturn section;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns root node\r\n\t\t * @return {CSSSection}\r\n\t\t */\r\n\t\troot: function() {\r\n\t\t\tvar root = this;\r\n\t\t\tdo {\r\n\t\t\t\tif (!root.parent) {\r\n\t\t\t\t\treturn root;\r\n\t\t\t\t}\r\n\t\t\t} while(root = root.parent);\r\n\r\n\t\t\treturn root;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns currect CSS source\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tsource: function() {\r\n\t\t\treturn this._source || this.root()._source;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns section name\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tname: function() {\r\n\t\t\tif (this._name === null) {\r\n\t\t\t\tvar range = this.nameRange();\r\n\t\t\t\tif (range) {\r\n\t\t\t\t\tthis._name = range.substring(this.source());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn this._name;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns section name range\r\n\t\t * @return {[type]} [description]\r\n\t\t */\r\n\t\tnameRange: function() {\r\n\t\t\tif (this.range && '_selectorEnd' in this.range) {\r\n\t\t\t\treturn range.create2(this.range.start, this.range._selectorEnd);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns deepest child of current section (or section itself) \r\n\t\t * which includes given position.\r\n\t\t * @param  {Number} pos\r\n\t\t * @return {CSSSection}\r\n\t\t */\r\n\t\tmatchDeep: function(pos) {\r\n\t\t\tif (!this.range.inside(pos)) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0, il = this.children.length, m; i < il; i++) {\r\n\t\t\t\tm = this.children[i].matchDeep(pos);\r\n\t\t\t\tif (m) {\r\n\t\t\t\t\treturn m;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\treturn this.parent ? this : null;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns current and all nested sections ranges\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tallRanges: function() {\r\n\t\t\tvar out = [];\r\n\t\t\tif (this.parent) {\r\n\t\t\t\t// add current range if it is not root node\r\n\t\t\t\tout.push(this.range);\r\n\t\t\t}\r\n\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tout = out.concat(child.allRanges());\r\n\t\t\t});\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\tdata: function(key, value) {\r\n\t\t\tif (typeof value !== 'undefined') {\r\n\t\t\t\tthis._data[key] = value;\r\n\t\t\t}\r\n\r\n\t\t\treturn this._data[key];\r\n\t\t},\r\n\r\n\t\tstringify: function(indent) {\r\n\t\t\tindent = indent || '';\r\n\t\t\tvar out = '';\r\n\t\t\tthis.children.forEach(function(item) {\r\n\t\t\t\tout += indent + item.name().replace(/\\n/g, '\\\\n') + '\\n';\r\n\t\t\t\tout += item.stringify(indent + '--');\r\n\t\t\t});\r\n\r\n\t\t\treturn out;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns current section’s actual content,\r\n\t\t * e.g. content without nested sections\r\n\t\t * @return {String} \r\n\t\t */\r\n\t\tcontent: function() {\r\n\t\t\tif (this._content !== null) {\r\n\t\t\t\treturn this._content;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.range || !('_contentStart' in this.range)) {\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\r\n\t\t\tvar r = range.create2(this.range._contentStart + 1, this.range.end - 1);\r\n\t\t\tvar source = this.source();\r\n\t\t\tvar start = r.start;\r\n\t\t\tvar out = '';\r\n\r\n\t\t\tthis.children.forEach(function(child) {\r\n\t\t\t\tout += source.substring(start, child.range.start);\r\n\t\t\t\tstart = child.range.end;\r\n\t\t\t});\r\n\r\n\t\t\tout += source.substring(start, r.end);\r\n\t\t\treturn this._content = utils.trim(out);\r\n\t\t}\r\n\t};\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * Finds all CSS rules‘ ranges in given CSS source\r\n\t\t * @param  {String} content CSS source\r\n\t\t * @return {Array} Array of ranges\r\n\t\t */\r\n\t\tfindAllRules: function(content) {\r\n\t\t\tcontent = this.sanitize(content);\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tvar ranges = [], matchedRanges;\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tvar saveRule = function(r) {\r\n\t\t\t\tvar selRange = self.extractSelector(content, r.start);\r\n\t\t\t\tvar rule = range.create2(selRange.start, r.end);\r\n\t\t\t\trule._selectorEnd = selRange.end;\r\n\t\t\t\trule._contentStart = r.start;\r\n\t\t\t\tranges.push(rule);\r\n\t\t\t};\r\n\r\n\t\t\tvar ch;\r\n\t\t\twhile (ch = stream.next()) {\r\n\t\t\t\tif (isQuote(ch)) {\r\n\t\t\t\t\tif (!stream.skipString(ch)) {\r\n\t\t\t\t\t\tbreak; // unterminated string\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ch == '{') {\r\n\t\t\t\t\tmatchedRanges = this.matchBracesRanges(content, stream.pos - 1);\r\n\t\t\t\t\tmatchedRanges.forEach(saveRule);\r\n\r\n\t\t\t\t\tif (matchedRanges.length) {\r\n\t\t\t\t\t\tstream.pos = utils.last(matchedRanges).end;\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t} \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn ranges.sort(function(a, b) {\r\n\t\t\t\treturn a.start - b.start;\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Matches curly braces content right after given position\r\n\t\t * @param  {String} content CSS content. Must not contain comments!\r\n\t\t * @param  {Number} pos     Search start position\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tmatchBracesRanges: function(content, pos, sanitize) {\r\n\t\t\tif (sanitize) {\r\n\t\t\t\tcontent = this.sanitize(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tstream.start = stream.pos = pos;\r\n\t\t\tvar stack = [], ranges = [];\r\n\t\t\tvar ch;\r\n\t\t\twhile (ch = stream.next()) {\r\n\t\t\t\tif (ch == '{') {\r\n\t\t\t\t\tstack.push(stream.pos - 1);\r\n\t\t\t\t} else if (ch == '}') {\r\n\t\t\t\t\tif (!stack.length) {\r\n\t\t\t\t\t\tthrow 'Invalid source structure (check for curly braces)';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tranges.push(range.create2(stack.pop(), stream.pos));\r\n\t\t\t\t\tif (!stack.length) {\r\n\t\t\t\t\t\treturn ranges;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream.skipQuoted();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn ranges;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Extracts CSS selector from CSS document from\r\n\t\t * given position. The selector is located by moving backward\r\n\t\t * from given position which means that passed position\r\n\t\t * must point to the end of selector \r\n\t\t * @param  {String}  content CSS source\r\n\t\t * @param  {Number}  pos     Search position\r\n\t\t * @param  {Boolean} sanitize Sanitize CSS source before processing.\r\n\t\t * Off by default and assumes that CSS must be comment-free already\r\n\t\t * (for performance)\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\textractSelector: function(content, pos, sanitize) {\r\n\t\t\tif (sanitize) {\r\n\t\t\t\tcontent = this.sanitize(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar skipString = function() {\r\n\t\t\t\tvar quote = content.charAt(pos);\r\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\r\n\t\t\t\t\twhile (--pos >= 0) {\r\n\t\t\t\t\t\tif (content.charAt(pos) == quote && content.charAt(pos - 1) != '\\\\') {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\t// find CSS selector\r\n\t\t\tvar ch;\r\n\t\t\tvar endPos = pos;\r\n\t\t\twhile (--pos >= 0) {\r\n\t\t\t\tif (skipString()) continue;\r\n\r\n\t\t\t\tch = content.charAt(pos);\r\n\t\t\t\tif (ch == ')') {\r\n\t\t\t\t\t// looks like it’s a preprocessor thing,\r\n\t\t\t\t\t// most likely a mixin arguments list, e.g.\r\n\t\t\t\t\t// .mixin (@arg1; @arg2) {...}\r\n\t\t\t\t\twhile (--pos >= 0) {\r\n\t\t\t\t\t\tif (skipString()) continue;\r\n\r\n\t\t\t\t\t\tif (content.charAt(pos) == '(') {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ch == '{' || ch == '}' || ch == ';') {\r\n\t\t\t\t\tpos++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pos < 0) {\r\n\t\t\t\tpos = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar selector = content.substring(pos, endPos);\r\n\r\n\t\t\t// trim whitespace from matched selector\r\n\t\t\tvar m = selector.replace(reSpace, ' ').match(reSpaceTrim);\r\n\t\t\tif (m) {\r\n\t\t\t\tpos += m[1].length;\r\n\t\t\t\tendPos -= m[2].length;\r\n\t\t\t}\r\n\r\n\t\t\treturn range.create2(pos, endPos);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Search for nearest CSS rule/section that contains\r\n\t\t * given position\r\n\t\t * @param  {String} content CSS content or matched CSS rules (array of ranges)\r\n\t\t * @param  {Number} pos     Search position\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tmatchEnclosingRule: function(content, pos) {\r\n\t\t\tif (typeof content === 'string') {\r\n\t\t\t\tcontent = this.findAllRules(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar rules = content.filter(function(r) {\r\n\t\t\t\treturn r.inside(pos);\r\n\t\t\t});\r\n\r\n\t\t\treturn utils.last(rules);\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Locates CSS rule next or before given position\r\n\t\t * @param  {String}  content    CSS content\r\n\t\t * @param  {Number}  pos        Search start position\r\n\t\t * @param  {Boolean} isBackward Search backward (find previous rule insteaf of next one)\r\n\t\t * @return {Range}\r\n\t\t */\r\n\t\tlocateRule: function(content, pos, isBackward) {\r\n\t\t\t// possible case: editor reported that current syntax is\r\n\t\t\t// CSS, but it’s actually a HTML document (either `style` tag or attribute)\r\n\t\t\tvar offset = 0;\r\n\t\t\tvar subrange = this.styleTagRange(content, pos);\r\n\t\t\tif (subrange) {\r\n\t\t\t\toffset = subrange.start;\r\n\t\t\t\tpos -= subrange.start;\r\n\t\t\t\tcontent = subrange.substring(content);\r\n\t\t\t}\r\n\r\n\t\t\tvar rules = this.findAllRules(content);\r\n\t\t\tvar ctxRule = this.matchEnclosingRule(rules, pos);\r\n\r\n\t\t\tif (ctxRule) {\r\n\t\t\t\treturn ctxRule.shift(offset);\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i = 0, il = rules.length; i < il; i++) {\r\n\t\t\t\tif (rules[i].start > pos) {\r\n\t\t\t\t\treturn rules[isBackward && i > 0 ? i - 1 : i].shift(offset);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Sanitizes given CSS content: replaces content that may \r\n\t\t * interfere with parsing (comments, interpolations, etc.)\r\n\t\t * with spaces. Sanitized content MUST NOT be used for\r\n\t\t * editing or outputting, it just simplifies searching\r\n\t\t * @param  {String} content CSS content\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tsanitize: function(content) {\r\n\t\t\tcontent = commentsUtils.strip(content);\r\n\r\n\t\t\t// remove preprocessor string interpolations like #{var}\r\n\t\t\tvar stream = stringStream(content);\r\n\t\t\tvar replaceRanges = [];\r\n\t\t\tvar ch, ch2;\r\n\r\n\t\t\twhile ((ch = stream.next())) {\r\n\t\t\t\tif (isQuote(ch)) {\r\n\t\t\t\t\t// skip string\r\n\t\t\t\t\tstream.skipString(ch)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else if (ch === '#' || ch === '@') {\r\n\t\t\t\t\tch2 = stream.peek();\r\n\t\t\t\t\tif (ch2 === '{') { // string interpolation\r\n\t\t\t\t\t\tstream.start = stream.pos - 1;\r\n\r\n\t\t\t\t\t\tif (stream.skipTo('}')) {\r\n\t\t\t\t\t\t\tstream.pos += 1;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow 'Invalid string interpolation at ' + stream.start;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treplaceRanges.push([stream.start, stream.pos]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn utils.replaceWith(content, replaceRanges, 'a');\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Parses and returns all sections in given CSS\r\n\t\t * as tree-like structure, e.g. provides nesting\r\n\t\t * info\r\n\t\t * @param  {String} content CSS content\r\n\t\t * @return {CSSSection}\r\n\t\t */\r\n\t\tsectionTree: function(content) {\r\n\t\t\tvar root = new CSSSection(null, content);\r\n\t\t\tvar rules = this.findAllRules(content);\r\n\r\n\t\t\t// rules are sorted in order they appear in CSS source\r\n\t\t\t// so we can optimize their nesting routine\r\n\t\t\tvar insert = function(range, ctx) {\r\n\t\t\t\twhile (ctx && ctx.range) {\r\n\t\t\t\t\tif (ctx.range.contains(range)) {\r\n\t\t\t\t\t\treturn ctx.addChild(range);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tctx = ctx.parent;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if we are here then given range is a top-level section\r\n\t\t\t\treturn root.addChild(range);\r\n\t\t\t};\r\n\r\n\t\t\tvar ctx = root;\r\n\t\t\trules.forEach(function(r) {\r\n\t\t\t\tctx = insert(r, ctx);\r\n\t\t\t});\r\n\r\n\t\t\treturn root;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Returns ranges for all nested sections, available in\r\n\t\t * given CSS rule\r\n\t\t * @param  {CSSEditContainer} rule\r\n\t\t * @return {Array}\r\n\t\t */\r\n\t\tnestedSectionsInRule: function(rule) {\r\n\t\t\tvar offset = rule.valueRange(true).start;\r\n\t\t\tvar nestedSections = this.findAllRules(rule.valueRange().substring(rule.source));\r\n\t\t\tnestedSections.forEach(function(section) {\r\n\t\t\t\tsection.start += offset;\r\n\t\t\t\tsection.end += offset;\r\n\t\t\t\tsection._selectorEnd += offset;\r\n\t\t\t\tsection._contentStart += offset;\r\n\t\t\t});\r\n\t\t\treturn nestedSections;\r\n\t\t},\r\n\r\n\t\tstyleTagRange: function(content, pos) {\r\n\t\t\tvar tag = htmlMatcher.tag(content, pos);\r\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \r\n\t\t\t\t&& tag.innerRange.cmp(pos, 'lte', 'gte')\r\n\t\t\t\t&& tag.innerRange;\r\n\t\t},\r\n\r\n\t\tstyleAttrRange: function(content, pos) {\r\n\t\t\tvar tree = xmlEditTree.parseFromPosition(content, pos, true);\r\n\t\t\tif (tree) {\r\n\t\t\t\tvar attr = tree.itemFromPosition(pos, true);\r\n\t\t\t\treturn attr && attr.name().toLowerCase() == 'style' \r\n\t\t\t\t\t&& attr.valueRange(true).cmp(pos, 'lte', 'gte')\r\n\t\t\t\t\t&& attr.valueRange(true);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tCSSSection: CSSSection\r\n\t};\r\n});\r\n},{\"../assets/htmlMatcher\":\"assets\\\\htmlMatcher.js\",\"../assets/range\":\"assets\\\\range.js\",\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"../editTree/xml\":\"editTree\\\\xml.js\",\"../parser/css\":\"parser\\\\css.js\",\"./comments\":\"utils\\\\comments.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\editor.js\":[function(require,module,exports){\r\n/**\r\n * Utility module used to prepare text for pasting into back-end editor\r\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('./common');\r\n\tvar resources = require('../assets/resources');\r\n\r\n\treturn  {\r\n\t\t/**\r\n\t\t * Check if cursor is placed inside XHTML tag\r\n\t\t * @param {String} html Contents of the document\r\n\t\t * @param {Number} caretPos Current caret position inside tag\r\n\t\t * @return {Boolean}\r\n\t\t */\r\n\t\tisInsideTag: function(html, caretPos) {\r\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\r\n\t\t\t\r\n\t\t\t// search left to find opening brace\r\n\t\t\tvar pos = caretPos;\r\n\t\t\twhile (pos > -1) {\r\n\t\t\t\tif (html.charAt(pos) == '<') \r\n\t\t\t\t\tbreak;\r\n\t\t\t\tpos--;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (pos != -1) {\r\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\r\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\r\n\t\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Sanitizes incoming editor data and provides default values for\r\n\t\t * output-specific info\r\n\t\t * @param {IEmmetEditor} editor\r\n\t\t * @param {String} syntax\r\n\t\t * @param {String} profile\r\n\t\t */\r\n\t\toutputInfo: function(editor, syntax, profile) {\r\n\t\t\t// most of this code makes sense for Java/Rhino environment\r\n\t\t\t// because string that comes from Java are not actually JS string\r\n\t\t\t// but Java String object so the have to be explicitly converted\r\n\t\t\t// to native string\r\n\t\t\tprofile = profile || editor.getProfileName();\r\n\t\t\treturn  {\r\n\t\t\t\t/** @memberOf outputInfo */\r\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\r\n\t\t\t\tprofile: profile || null,\r\n\t\t\t\tcontent: String(editor.getContent())\r\n\t\t\t};\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Unindent content, thus preparing text for tag wrapping\r\n\t\t * @param {IEmmetEditor} editor Editor instance\r\n\t\t * @param {String} text\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tunindent: function(editor, text) {\r\n\t\t\treturn utils.unindentString(text, this.getCurrentLinePadding(editor));\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Returns padding of current editor's line\r\n\t\t * @param {IEmmetEditor} Editor instance\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tgetCurrentLinePadding: function(editor) {\r\n\t\t\treturn utils.getLinePadding(editor.getCurrentLine());\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Normalizes content according to given preferences, e.g.\r\n\t\t * replaces newlines and indentation with ones defined in\r\n\t\t * `options`. If options are not provided or incomplete, \r\n\t\t * values will be taken from current user environment\r\n\t\t * @param {String} text\r\n\t\t * @param {Object} options\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\tnormalize: function(text, options) {\r\n\t\t\toptions = utils.extend({\r\n\t\t\t\tnewline: resources.getNewline(),\r\n\t\t\t\tindentation: resources.getVariable('indentation')\r\n\t\t\t}, options);\r\n\r\n\t\t\tvar indent = function(tabs) {\r\n\t\t\t\treturn utils.repeatString(options.indentation, tabs.length);\r\n\t\t\t};\r\n\r\n\t\t\tvar lines = utils.splitByLines(text);\r\n\r\n\t\t\t// normailze indentation if it’s not tabs\r\n\t\t\tif (options.indentation !== '\\t') {\r\n\t\t\t\tlines = lines.map(function(line) {\r\n\t\t\t\t\treturn line.replace(/^\\s+/, function(space) {\r\n\t\t\t\t\t\treturn space.replace(/\\t/g, indent);\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// normalize newlines\r\n\t\t\treturn lines.join(options.newline);\r\n\t\t}\r\n\t};\r\n});\r\n\r\n},{\"../assets/resources\":\"assets\\\\resources.js\",\"./common\":\"utils\\\\common.js\"}],\"utils\\\\math.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\t/*\r\n\t Source: https://github.com/silentmatt/js-expression-eval\r\n\r\n\t Based on ndef.parser, by Raphael Graf(r@undefined.ch)\r\n\t http://www.undefined.ch/mparser/index.html\r\n\r\n\t Ported to JavaScript and modified by Matthew Crumley (email@matthewcrumley.com, http://silentmatt.com/)\r\n\r\n\t You are free to use and modify this code in anyway you find useful. Please leave this comment in the code\r\n\t to acknowledge its original source. If you feel like it, I enjoy hearing about projects that use my code,\r\n\t but don't feel like you have to let me know or ask permission.\r\n\t*/\r\n\r\n\tfunction object(o) {\r\n\t\tfunction F() {}\r\n\t\tF.prototype = o;\r\n\t\treturn new F();\r\n\t}\r\n\r\n\tvar TNUMBER = 0;\r\n\tvar TOP1 = 1;\r\n\tvar TOP2 = 2;\r\n\tvar TVAR = 3;\r\n\tvar TFUNCALL = 4;\r\n\r\n\tfunction Token(type_, index_, prio_, number_) {\r\n\t\tthis.type_ = type_;\r\n\t\tthis.index_ = index_ || 0;\r\n\t\tthis.prio_ = prio_ || 0;\r\n\t\tthis.number_ = (number_ !== undefined && number_ !== null) ? number_ : 0;\r\n\t\tthis.toString = function () {\r\n\t\t\tswitch (this.type_) {\r\n\t\t\tcase TNUMBER:\r\n\t\t\t\treturn this.number_;\r\n\t\t\tcase TOP1:\r\n\t\t\tcase TOP2:\r\n\t\t\tcase TVAR:\r\n\t\t\t\treturn this.index_;\r\n\t\t\tcase TFUNCALL:\r\n\t\t\t\treturn \"CALL\";\r\n\t\t\tdefault:\r\n\t\t\t\treturn \"Invalid Token\";\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tfunction Expression(tokens, ops1, ops2, functions) {\r\n\t\tthis.tokens = tokens;\r\n\t\tthis.ops1 = ops1;\r\n\t\tthis.ops2 = ops2;\r\n\t\tthis.functions = functions;\r\n\t}\r\n\r\n\t// Based on http://www.json.org/json2.js\r\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n        escapable = /[\\\\\\'\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n        meta = {    // table of character substitutions\r\n            '\\b': '\\\\b',\r\n            '\\t': '\\\\t',\r\n            '\\n': '\\\\n',\r\n            '\\f': '\\\\f',\r\n            '\\r': '\\\\r',\r\n            \"'\" : \"\\\\'\",\r\n            '\\\\': '\\\\\\\\'\r\n        };\r\n\r\n\tfunction escapeValue(v) {\r\n\t\tif (typeof v === \"string\") {\r\n\t\t\tescapable.lastIndex = 0;\r\n\t        return escapable.test(v) ?\r\n\t            \"'\" + v.replace(escapable, function (a) {\r\n\t                var c = meta[a];\r\n\t                return typeof c === 'string' ? c :\r\n\t                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n\t            }) + \"'\" :\r\n\t            \"'\" + v + \"'\";\r\n\t\t}\r\n\t\treturn v;\r\n\t}\r\n\r\n\tExpression.prototype = {\r\n\t\tsimplify: function (values) {\r\n\t\t\tvalues = values || {};\r\n\t\t\tvar nstack = [];\r\n\t\t\tvar newexpression = [];\r\n\t\t\tvar n1;\r\n\t\t\tvar n2;\r\n\t\t\tvar f;\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TNUMBER) {\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TVAR && (item.index_ in values)) {\r\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, values[item.index_]);\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP2 && nstack.length > 1) {\r\n\t\t\t\t\tn2 = nstack.pop();\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops2[item.index_];\r\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, f(n1.number_, n2.number_));\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP1 && nstack.length > 0) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops1[item.index_];\r\n\t\t\t\t\titem = new Token(TNUMBER, 0, 0, f(n1.number_));\r\n\t\t\t\t\tnstack.push(item);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\twhile (nstack.length > 0) {\r\n\t\t\t\t\t\tnewexpression.push(nstack.shift());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewexpression.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (nstack.length > 0) {\r\n\t\t\t\tnewexpression.push(nstack.shift());\r\n\t\t\t}\r\n\r\n\t\t\treturn new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));\r\n\t\t},\r\n\r\n\t\tsubstitute: function (variable, expr) {\r\n\t\t\tif (!(expr instanceof Expression)) {\r\n\t\t\t\texpr = new Parser().parse(String(expr));\r\n\t\t\t}\r\n\t\t\tvar newexpression = [];\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TVAR && item.index_ === variable) {\r\n\t\t\t\t\tfor (var j = 0; j < expr.tokens.length; j++) {\r\n\t\t\t\t\t\tvar expritem = expr.tokens[j];\r\n\t\t\t\t\t\tvar replitem = new Token(expritem.type_, expritem.index_, expritem.prio_, expritem.number_);\r\n\t\t\t\t\t\tnewexpression.push(replitem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewexpression.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar ret = new Expression(newexpression, object(this.ops1), object(this.ops2), object(this.functions));\r\n\t\t\treturn ret;\r\n\t\t},\r\n\r\n\t\tevaluate: function (values) {\r\n\t\t\tvalues = values || {};\r\n\t\t\tvar nstack = [];\r\n\t\t\tvar n1;\r\n\t\t\tvar n2;\r\n\t\t\tvar f;\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TNUMBER) {\r\n\t\t\t\t\tnstack.push(item.number_);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP2) {\r\n\t\t\t\t\tn2 = nstack.pop();\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops2[item.index_];\r\n\t\t\t\t\tnstack.push(f(n1, n2));\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TVAR) {\r\n\t\t\t\t\tif (item.index_ in values) {\r\n\t\t\t\t\t\tnstack.push(values[item.index_]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (item.index_ in this.functions) {\r\n\t\t\t\t\t\tnstack.push(this.functions[item.index_]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(\"undefined variable: \" + item.index_);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP1) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = this.ops1[item.index_];\r\n\t\t\t\t\tnstack.push(f(n1));\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TFUNCALL) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = nstack.pop();\r\n\t\t\t\t\tif (f.apply && f.call) {\r\n\t\t\t\t\t\tif (Object.prototype.toString.call(n1) == \"[object Array]\") {\r\n\t\t\t\t\t\t\tnstack.push(f.apply(undefined, n1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnstack.push(f.call(undefined, n1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthrow new Error(f + \" is not a function\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error(\"invalid Expression\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nstack.length > 1) {\r\n\t\t\t\tthrow new Error(\"invalid Expression (parity)\");\r\n\t\t\t}\r\n\t\t\treturn nstack[0];\r\n\t\t},\r\n\r\n\t\ttoString: function (toJS) {\r\n\t\t\tvar nstack = [];\r\n\t\t\tvar n1;\r\n\t\t\tvar n2;\r\n\t\t\tvar f;\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar item;\r\n\t\t\tvar i = 0;\r\n\t\t\tfor (i = 0; i < L; i++) {\r\n\t\t\t\titem = this.tokens[i];\r\n\t\t\t\tvar type_ = item.type_;\r\n\t\t\t\tif (type_ === TNUMBER) {\r\n\t\t\t\t\tnstack.push(escapeValue(item.number_));\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP2) {\r\n\t\t\t\t\tn2 = nstack.pop();\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = item.index_;\r\n\t\t\t\t\tif (toJS && f == \"^\") {\r\n\t\t\t\t\t\tnstack.push(\"Math.pow(\" + n1 + \",\" + n2 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tnstack.push(\"(\" + n1 + f + n2 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TVAR) {\r\n\t\t\t\t\tnstack.push(item.index_);\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TOP1) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = item.index_;\r\n\t\t\t\t\tif (f === \"-\") {\r\n\t\t\t\t\t\tnstack.push(\"(\" + f + n1 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tnstack.push(f + \"(\" + n1 + \")\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (type_ === TFUNCALL) {\r\n\t\t\t\t\tn1 = nstack.pop();\r\n\t\t\t\t\tf = nstack.pop();\r\n\t\t\t\t\tnstack.push(f + \"(\" + n1 + \")\");\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error(\"invalid Expression\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (nstack.length > 1) {\r\n\t\t\t\tthrow new Error(\"invalid Expression (parity)\");\r\n\t\t\t}\r\n\t\t\treturn nstack[0];\r\n\t\t},\r\n\r\n\t\tvariables: function () {\r\n\t\t\tvar L = this.tokens.length;\r\n\t\t\tvar vars = [];\r\n\t\t\tfor (var i = 0; i < L; i++) {\r\n\t\t\t\tvar item = this.tokens[i];\r\n\t\t\t\tif (item.type_ === TVAR && (vars.indexOf(item.index_) == -1)) {\r\n\t\t\t\t\tvars.push(item.index_);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn vars;\r\n\t\t},\r\n\r\n\t\ttoJSFunction: function (param, variables) {\r\n\t\t\tvar f = new Function(param, \"with(Parser.values) { return \" + this.simplify(variables).toString(true) + \"; }\");\r\n\t\t\treturn f;\r\n\t\t}\r\n\t};\r\n\r\n\tfunction add(a, b) {\r\n\t\treturn Number(a) + Number(b);\r\n\t}\r\n\tfunction sub(a, b) {\r\n\t\treturn a - b; \r\n\t}\r\n\tfunction mul(a, b) {\r\n\t\treturn a * b;\r\n\t}\r\n\tfunction div(a, b) {\r\n\t\treturn a / b;\r\n\t}\r\n\tfunction mod(a, b) {\r\n\t\treturn a % b;\r\n\t}\r\n\tfunction concat(a, b) {\r\n\t\treturn \"\" + a + b;\r\n\t}\r\n\r\n\tfunction neg(a) {\r\n\t\treturn -a;\r\n\t}\r\n\r\n\tfunction random(a) {\r\n\t\treturn Math.random() * (a || 1);\r\n\t}\r\n\tfunction fac(a) { //a!\r\n\t\ta = Math.floor(a);\r\n\t\tvar b = a;\r\n\t\twhile (a > 1) {\r\n\t\t\tb = b * (--a);\r\n\t\t}\r\n\t\treturn b;\r\n\t}\r\n\r\n\t// TODO: use hypot that doesn't overflow\r\n\tfunction pyt(a, b) {\r\n\t\treturn Math.sqrt(a * a + b * b);\r\n\t}\r\n\r\n\tfunction append(a, b) {\r\n\t\tif (Object.prototype.toString.call(a) != \"[object Array]\") {\r\n\t\t\treturn [a, b];\r\n\t\t}\r\n\t\ta = a.slice();\r\n\t\ta.push(b);\r\n\t\treturn a;\r\n\t}\r\n\r\n\tfunction Parser() {\r\n\t\tthis.success = false;\r\n\t\tthis.errormsg = \"\";\r\n\t\tthis.expression = \"\";\r\n\r\n\t\tthis.pos = 0;\r\n\r\n\t\tthis.tokennumber = 0;\r\n\t\tthis.tokenprio = 0;\r\n\t\tthis.tokenindex = 0;\r\n\t\tthis.tmpprio = 0;\r\n\r\n\t\tthis.ops1 = {\r\n\t\t\t\"sin\": Math.sin,\r\n\t\t\t\"cos\": Math.cos,\r\n\t\t\t\"tan\": Math.tan,\r\n\t\t\t\"asin\": Math.asin,\r\n\t\t\t\"acos\": Math.acos,\r\n\t\t\t\"atan\": Math.atan,\r\n\t\t\t\"sqrt\": Math.sqrt,\r\n\t\t\t\"log\": Math.log,\r\n\t\t\t\"abs\": Math.abs,\r\n\t\t\t\"ceil\": Math.ceil,\r\n\t\t\t\"floor\": Math.floor,\r\n\t\t\t\"round\": Math.round,\r\n\t\t\t\"-\": neg,\r\n\t\t\t\"exp\": Math.exp\r\n\t\t};\r\n\r\n\t\tthis.ops2 = {\r\n\t\t\t\"+\": add,\r\n\t\t\t\"-\": sub,\r\n\t\t\t\"*\": mul,\r\n\t\t\t\"/\": div,\r\n\t\t\t\"%\": mod,\r\n\t\t\t\"^\": Math.pow,\r\n\t\t\t\",\": append,\r\n\t\t\t\"||\": concat\r\n\t\t};\r\n\r\n\t\tthis.functions = {\r\n\t\t\t\"random\": random,\r\n\t\t\t\"fac\": fac,\r\n\t\t\t\"min\": Math.min,\r\n\t\t\t\"max\": Math.max,\r\n\t\t\t\"pyt\": pyt,\r\n\t\t\t\"pow\": Math.pow,\r\n\t\t\t\"atan2\": Math.atan2\r\n\t\t};\r\n\r\n\t\tthis.consts = {\r\n\t\t\t\"E\": Math.E,\r\n\t\t\t\"PI\": Math.PI\r\n\t\t};\r\n\t}\r\n\r\n\tParser.parse = function (expr) {\r\n\t\treturn new Parser().parse(expr);\r\n\t};\r\n\r\n\tParser.evaluate = function (expr, variables) {\r\n\t\treturn Parser.parse(expr).evaluate(variables);\r\n\t};\r\n\r\n\tParser.Expression = Expression;\r\n\r\n\tParser.values = {\r\n\t\tsin: Math.sin,\r\n\t\tcos: Math.cos,\r\n\t\ttan: Math.tan,\r\n\t\tasin: Math.asin,\r\n\t\tacos: Math.acos,\r\n\t\tatan: Math.atan,\r\n\t\tsqrt: Math.sqrt,\r\n\t\tlog: Math.log,\r\n\t\tabs: Math.abs,\r\n\t\tceil: Math.ceil,\r\n\t\tfloor: Math.floor,\r\n\t\tround: Math.round,\r\n\t\trandom: random,\r\n\t\tfac: fac,\r\n\t\texp: Math.exp,\r\n\t\tmin: Math.min,\r\n\t\tmax: Math.max,\r\n\t\tpyt: pyt,\r\n\t\tpow: Math.pow,\r\n\t\tatan2: Math.atan2,\r\n\t\tE: Math.E,\r\n\t\tPI: Math.PI\r\n\t};\r\n\r\n\tvar PRIMARY      = 1 << 0;\r\n\tvar OPERATOR     = 1 << 1;\r\n\tvar FUNCTION     = 1 << 2;\r\n\tvar LPAREN       = 1 << 3;\r\n\tvar RPAREN       = 1 << 4;\r\n\tvar COMMA        = 1 << 5;\r\n\tvar SIGN         = 1 << 6;\r\n\tvar CALL         = 1 << 7;\r\n\tvar NULLARY_CALL = 1 << 8;\r\n\r\n\tParser.prototype = {\r\n\t\tparse: function (expr) {\r\n\t\t\tthis.errormsg = \"\";\r\n\t\t\tthis.success = true;\r\n\t\t\tvar operstack = [];\r\n\t\t\tvar tokenstack = [];\r\n\t\t\tthis.tmpprio = 0;\r\n\t\t\tvar expected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\tvar noperators = 0;\r\n\t\t\tthis.expression = expr;\r\n\t\t\tthis.pos = 0;\r\n\r\n\t\t\twhile (this.pos < this.expression.length) {\r\n\t\t\t\tif (this.isOperator()) {\r\n\t\t\t\t\tif (this.isSign() && (expected & SIGN)) {\r\n\t\t\t\t\t\tif (this.isNegativeSign()) {\r\n\t\t\t\t\t\t\tthis.tokenprio = 2;\r\n\t\t\t\t\t\t\tthis.tokenindex = \"-\";\r\n\t\t\t\t\t\t\tnoperators++;\r\n\t\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.isComment()) {\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tif ((expected & OPERATOR) === 0) {\r\n\t\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected operator\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\r\n\t\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isNumber()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected number\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, this.tokennumber);\r\n\t\t\t\t\ttokenstack.push(token);\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isString()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected string\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, this.tokennumber);\r\n\t\t\t\t\ttokenstack.push(token);\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isLeftParenth()) {\r\n\t\t\t\t\tif ((expected & LPAREN) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\"(\\\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (expected & CALL) {\r\n\t\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\t\tthis.tokenprio = -2;\r\n\t\t\t\t\t\tthis.tokenindex = -1;\r\n\t\t\t\t\t\tthis.addfunc(tokenstack, operstack, TFUNCALL);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN | NULLARY_CALL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isRightParenth()) {\r\n\t\t\t\t    if (expected & NULLARY_CALL) {\r\n\t\t\t\t\t\tvar token = new Token(TNUMBER, 0, 0, []);\r\n\t\t\t\t\t\ttokenstack.push(token);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ((expected & RPAREN) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\")\\\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isComma()) {\r\n\t\t\t\t\tif ((expected & COMMA) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected \\\",\\\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\r\n\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\texpected = (PRIMARY | LPAREN | FUNCTION | SIGN);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isConst()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected constant\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar consttoken = new Token(TNUMBER, 0, 0, this.tokennumber);\r\n\t\t\t\t\ttokenstack.push(consttoken);\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isOp2()) {\r\n\t\t\t\t\tif ((expected & FUNCTION) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected function\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP2);\r\n\t\t\t\t\tnoperators += 2;\r\n\t\t\t\t\texpected = (LPAREN);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isOp1()) {\r\n\t\t\t\t\tif ((expected & FUNCTION) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected function\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addfunc(tokenstack, operstack, TOP1);\r\n\t\t\t\t\tnoperators++;\r\n\t\t\t\t\texpected = (LPAREN);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isVar()) {\r\n\t\t\t\t\tif ((expected & PRIMARY) === 0) {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unexpected variable\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar vartoken = new Token(TVAR, this.tokenindex, 0, 0);\r\n\t\t\t\t\ttokenstack.push(vartoken);\r\n\r\n\t\t\t\t\texpected = (OPERATOR | RPAREN | COMMA | LPAREN | CALL);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.isWhite()) {\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (this.errormsg === \"\") {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, \"unknown character\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.error_parsing(this.pos, this.errormsg);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.tmpprio < 0 || this.tmpprio >= 10) {\r\n\t\t\t\tthis.error_parsing(this.pos, \"unmatched \\\"()\\\"\");\r\n\t\t\t}\r\n\t\t\twhile (operstack.length > 0) {\r\n\t\t\t\tvar tmp = operstack.pop();\r\n\t\t\t\ttokenstack.push(tmp);\r\n\t\t\t}\r\n\t\t\tif (noperators + 1 !== tokenstack.length) {\r\n\t\t\t\t//print(noperators + 1);\r\n\t\t\t\t//print(tokenstack);\r\n\t\t\t\tthis.error_parsing(this.pos, \"parity\");\r\n\t\t\t}\r\n\r\n\t\t\treturn new Expression(tokenstack, object(this.ops1), object(this.ops2), object(this.functions));\r\n\t\t},\r\n\r\n\t\tevaluate: function (expr, variables) {\r\n\t\t\treturn this.parse(expr).evaluate(variables);\r\n\t\t},\r\n\r\n\t\terror_parsing: function (column, msg) {\r\n\t\t\tthis.success = false;\r\n\t\t\tthis.errormsg = \"parse error [column \" + (column) + \"]: \" + msg;\r\n\t\t\tthrow new Error(this.errormsg);\r\n\t\t},\r\n\r\n//\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\r\n\r\n\t\taddfunc: function (tokenstack, operstack, type_) {\r\n\t\t\tvar operator = new Token(type_, this.tokenindex, this.tokenprio + this.tmpprio, 0);\r\n\t\t\twhile (operstack.length > 0) {\r\n\t\t\t\tif (operator.prio_ <= operstack[operstack.length - 1].prio_) {\r\n\t\t\t\t\ttokenstack.push(operstack.pop());\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toperstack.push(operator);\r\n\t\t},\r\n\r\n\t\tisNumber: function () {\r\n\t\t\tvar r = false;\r\n\t\t\tvar str = \"\";\r\n\t\t\twhile (this.pos < this.expression.length) {\r\n\t\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\t\tif ((code >= 48 && code <= 57) || code === 46) {\r\n\t\t\t\t\tstr += this.expression.charAt(this.pos);\r\n\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\tthis.tokennumber = parseFloat(str);\r\n\t\t\t\t\tr = true;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\t// Ported from the yajjl JSON parser at http://code.google.com/p/yajjl/\r\n\t\tunescape: function(v, pos) {\r\n\t\t\tvar buffer = [];\r\n\t\t\tvar escaping = false;\r\n\r\n\t\t\tfor (var i = 0; i < v.length; i++) {\r\n\t\t\t\tvar c = v.charAt(i);\r\n\t\r\n\t\t\t\tif (escaping) {\r\n\t\t\t\t\tswitch (c) {\r\n\t\t\t\t\tcase \"'\":\r\n\t\t\t\t\t\tbuffer.push(\"'\");\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase '\\\\':\r\n\t\t\t\t\t\tbuffer.push('\\\\');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase '/':\r\n\t\t\t\t\t\tbuffer.push('/');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\tbuffer.push('\\b');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'f':\r\n\t\t\t\t\t\tbuffer.push('\\f');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'n':\r\n\t\t\t\t\t\tbuffer.push('\\n');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'r':\r\n\t\t\t\t\t\tbuffer.push('\\r');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tbuffer.push('\\t');\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'u':\r\n\t\t\t\t\t\t// interpret the following 4 characters as the hex of the unicode code point\r\n\t\t\t\t\t\tvar codePoint = parseInt(v.substring(i + 1, i + 5), 16);\r\n\t\t\t\t\t\tbuffer.push(String.fromCharCode(codePoint));\r\n\t\t\t\t\t\ti += 4;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow this.error_parsing(pos + i, \"Illegal escape sequence: '\\\\\" + c + \"'\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tescaping = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (c == '\\\\') {\r\n\t\t\t\t\t\tescaping = true;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbuffer.push(c);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn buffer.join('');\r\n\t\t},\r\n\r\n\t\tisString: function () {\r\n\t\t\tvar r = false;\r\n\t\t\tvar str = \"\";\r\n\t\t\tvar startpos = this.pos;\r\n\t\t\tif (this.pos < this.expression.length && this.expression.charAt(this.pos) == \"'\") {\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\twhile (this.pos < this.expression.length) {\r\n\t\t\t\t\tvar code = this.expression.charAt(this.pos);\r\n\t\t\t\t\tif (code != \"'\" || str.slice(-1) == \"\\\\\") {\r\n\t\t\t\t\t\tstr += this.expression.charAt(this.pos);\r\n\t\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\t\tthis.tokennumber = this.unescape(str, startpos);\r\n\t\t\t\t\t\tr = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn r;\r\n\t\t},\r\n\r\n\t\tisConst: function () {\r\n\t\t\tvar str;\r\n\t\t\tfor (var i in this.consts) {\r\n\t\t\t\tif (true) {\r\n\t\t\t\t\tvar L = i.length;\r\n\t\t\t\t\tstr = this.expression.substr(this.pos, L);\r\n\t\t\t\t\tif (i === str) {\r\n\t\t\t\t\t\tthis.tokennumber = this.consts[i];\r\n\t\t\t\t\t\tthis.pos += L;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisOperator: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 43) { // +\r\n\t\t\t\tthis.tokenprio = 0;\r\n\t\t\t\tthis.tokenindex = \"+\";\r\n\t\t\t}\r\n\t\t\telse if (code === 45) { // -\r\n\t\t\t\tthis.tokenprio = 0;\r\n\t\t\t\tthis.tokenindex = \"-\";\r\n\t\t\t}\r\n\t\t\telse if (code === 124) { // |\r\n\t\t\t\tif (this.expression.charCodeAt(this.pos + 1) === 124) {\r\n\t\t\t\t\tthis.pos++;\r\n\t\t\t\t\tthis.tokenprio = 0;\r\n\t\t\t\t\tthis.tokenindex = \"||\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (code === 42) { // *\r\n\t\t\t\tthis.tokenprio = 1;\r\n\t\t\t\tthis.tokenindex = \"*\";\r\n\t\t\t}\r\n\t\t\telse if (code === 47) { // /\r\n\t\t\t\tthis.tokenprio = 2;\r\n\t\t\t\tthis.tokenindex = \"/\";\r\n\t\t\t}\r\n\t\t\telse if (code === 37) { // %\r\n\t\t\t\tthis.tokenprio = 2;\r\n\t\t\t\tthis.tokenindex = \"%\";\r\n\t\t\t}\r\n\t\t\telse if (code === 94) { // ^\r\n\t\t\t\tthis.tokenprio = 3;\r\n\t\t\t\tthis.tokenindex = \"^\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tthis.pos++;\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\tisSign: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 45 || code === 43) { // -\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisPositiveSign: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 43) { // -\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisNegativeSign: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 45) { // -\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisLeftParenth: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 40) { // (\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\tthis.tmpprio += 10;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisRightParenth: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 41) { // )\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\tthis.tmpprio -= 10;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisComma: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 44) { // ,\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\tthis.tokenprio = -1;\r\n\t\t\t\tthis.tokenindex = \",\";\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisWhite: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos);\r\n\t\t\tif (code === 32 || code === 9 || code === 10 || code === 13) {\r\n\t\t\t\tthis.pos++;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisOp1: function () {\r\n\t\t\tvar str = \"\";\r\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\r\n\t\t\t\tvar c = this.expression.charAt(i);\r\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\r\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstr += c;\r\n\t\t\t}\r\n\t\t\tif (str.length > 0 && (str in this.ops1)) {\r\n\t\t\t\tthis.tokenindex = str;\r\n\t\t\t\tthis.tokenprio = 5;\r\n\t\t\t\tthis.pos += str.length;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisOp2: function () {\r\n\t\t\tvar str = \"\";\r\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\r\n\t\t\t\tvar c = this.expression.charAt(i);\r\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\r\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstr += c;\r\n\t\t\t}\r\n\t\t\tif (str.length > 0 && (str in this.ops2)) {\r\n\t\t\t\tthis.tokenindex = str;\r\n\t\t\t\tthis.tokenprio = 5;\r\n\t\t\t\tthis.pos += str.length;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisVar: function () {\r\n\t\t\tvar str = \"\";\r\n\t\t\tfor (var i = this.pos; i < this.expression.length; i++) {\r\n\t\t\t\tvar c = this.expression.charAt(i);\r\n\t\t\t\tif (c.toUpperCase() === c.toLowerCase()) {\r\n\t\t\t\t\tif (i === this.pos || (c != '_' && (c < '0' || c > '9'))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tstr += c;\r\n\t\t\t}\r\n\t\t\tif (str.length > 0) {\r\n\t\t\t\tthis.tokenindex = str;\r\n\t\t\t\tthis.tokenprio = 4;\r\n\t\t\t\tthis.pos += str.length;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tisComment: function () {\r\n\t\t\tvar code = this.expression.charCodeAt(this.pos - 1);\r\n\t\t\tif (code === 47 && this.expression.charCodeAt(this.pos) === 42) {\r\n\t\t\t\tthis.pos = this.expression.indexOf(\"*/\", this.pos) + 2;\r\n\t\t\t\tif (this.pos === 1) {\r\n\t\t\t\t\tthis.pos = this.expression.length;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\treturn Parser;\r\n});\r\n},{}],\"utils\\\\template.js\":[function(require,module,exports){\r\n/**\r\n * A very simple, ERB-style templating. Basically, just as string substitution.\r\n * The reason to not use default Lo-dash’es `_.template()` implementation\r\n * is because it fails to run in CSP-enabled environments (Chrome extension, Atom)\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar stringStream = require('../assets/stringStream');\r\n\tvar utils = require('./common');\r\n\r\n\tfunction parseArgs(str) {\r\n\t\tvar args = [];\r\n\t\tvar stream = stringStream(str);\r\n\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tif (stream.peek() == ',') {\r\n\t\t\t\targs.push(utils.trim(stream.current()));\r\n\t\t\t\tstream.next();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t}\r\n\t\t\tstream.next();\r\n\t\t}\r\n\r\n\t\targs.push(utils.trim(stream.current()));\r\n\t\treturn args.filter(function(a) {\r\n\t\t\treturn !!a;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction parseFunctionCall(str) {\r\n\t\tvar fnName = null, args;\r\n\t\tvar stream = stringStream(str);\r\n\t\twhile (!stream.eol()) {\r\n\t\t\tif (stream.peek() == '(') {\r\n\t\t\t\tfnName = stream.current();\r\n\t\t\t\tstream.start = stream.pos;\r\n\t\t\t\tstream.skipToPair('(', ')', true);\r\n\t\t\t\targs = stream.current();\r\n\t\t\t\targs = parseArgs(args.substring(1, args.length - 1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tstream.next();\r\n\t\t}\r\n\r\n\t\treturn fnName && {\r\n\t\t\tname: fnName,\r\n\t\t\targs: args\r\n\t\t};\r\n\t}\r\n\r\n\tfunction evalArg(arg, context) {\r\n\t\tif (/^['\"]/.test(arg)) {\r\n\t\t\t// plain string\r\n\t\t\treturn arg.replace(/^(['\"])(.+?)\\1$/, '$2');\r\n\t\t}\r\n\r\n\t\tif (!isNaN(+arg)) {\r\n\t\t\t// a number\r\n\t\t\treturn +arg;\r\n\t\t}\r\n\r\n\t\t// otherwise, treat argument as a property name\r\n\t\tif (arg) {\r\n\t\t\tvar parts = arg.split('.');\r\n\t\t\tvar prop = context;\r\n\t\t\twhile (parts.length) {\r\n\t\t\t\tprop = prop[parts.shift()];\r\n\t\t\t}\r\n\r\n\t\t\treturn prop;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction process(template, context) {\r\n\t\treturn template.replace(/<%[=\\-](.+?)%>/g, function(str, match) {\r\n\t\t\tmatch = utils.trim(match);\r\n\t\t\tvar fn = parseFunctionCall(match);\r\n\t\t\tif (fn) {\r\n\t\t\t\tvar fnArgs = fn.args.map(function(arg) {\r\n\t\t\t\t\treturn evalArg(arg, context);\r\n\t\t\t\t});\r\n\t\t\t\treturn context[fn.name].apply(context, fnArgs);\r\n\t\t\t}\r\n\r\n\t\t\treturn evalArg(match, context);\r\n\t\t});\r\n\t}\r\n\r\n\treturn function(template, context) {\r\n\t\treturn context ? process(template, context) : function(context) {\r\n\t\t\treturn process(template, context);\r\n\t\t};\r\n\t};\r\n});\r\n},{\"../assets/stringStream\":\"assets\\\\stringStream.js\",\"./common\":\"utils\\\\common.js\"}],\"vendor\\\\klass.js\":[function(require,module,exports){\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\tvar utils = require('../utils/common');\r\n\r\n\t/**\r\n\t * Shared empty constructor function to aid in prototype-chain creation.\r\n\t */\r\n\tvar ctor = function(){};\r\n\r\n\t/**\r\n\t * Helper function to correctly set up the prototype chain, for subclasses.\r\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\r\n\t * class properties to be extended.\r\n\t * Took it from Backbone.\r\n\t * @param {Object} parent\r\n\t * @param {Object} protoProps\r\n\t * @param {Object} staticProps\r\n\t * @returns {Object}\r\n\t */\r\n\tfunction inherits(parent, protoProps, staticProps) {\r\n\t\tvar child;\r\n\r\n\t\t// The constructor function for the new subclass is either defined by\r\n\t\t// you (the \"constructor\" property in your `extend` definition), or\r\n\t\t// defaulted by us to simply call the parent's constructor.\r\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\r\n\t\t\tchild = protoProps.constructor;\r\n\t\t} else {\r\n\t\t\tchild = function() {\r\n\t\t\t\tparent.apply(this, arguments);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// Inherit class (static) properties from parent.\r\n\t\tutils.extend(child, parent);\r\n\r\n\t\t// Set the prototype chain to inherit from `parent`, without calling\r\n\t\t// `parent`'s constructor function.\r\n\t\tctor.prototype = parent.prototype;\r\n\t\tchild.prototype = new ctor();\r\n\r\n\t\t// Add prototype properties (instance properties) to the subclass,\r\n\t\t// if supplied.\r\n\t\tif (protoProps)\r\n\t\t\tutils.extend(child.prototype, protoProps);\r\n\r\n\t\t// Add static properties to the constructor function, if supplied.\r\n\t\tif (staticProps)\r\n\t\t\tutils.extend(child, staticProps);\r\n\r\n\t\t// Correctly set child's `prototype.constructor`.\r\n\t\tchild.prototype.constructor = child;\r\n\r\n\t\t// Set a convenience property in case the parent's prototype is needed\r\n\t\t// later.\r\n\t\tchild.__super__ = parent.prototype;\r\n\r\n\t\treturn child;\r\n\t}\r\n\r\n\treturn {\r\n\t\t/**\r\n\t\t * The self-propagating extend function for classes.\r\n\t\t * Took it from Backbone \r\n\t\t * @param {Object} protoProps\r\n\t\t * @param {Object} classProps\r\n\t\t * @returns {Object}\r\n\t\t */\r\n\t\textend: function(protoProps, classProps) {\r\n\t\t\tvar child = inherits(this, protoProps, classProps);\r\n\t\t\tchild.extend = this.extend;\r\n\t\t\t// a hack required to WSH inherit `toString` method\r\n\t\t\tif (protoProps.hasOwnProperty('toString'))\r\n\t\t\t\tchild.prototype.toString = protoProps.toString;\r\n\t\t\treturn child;\r\n\t\t}\r\n\t};\r\n});\r\n},{\"../utils/common\":\"utils\\\\common.js\"}],\"vendor\\\\stringScore.js\":[function(require,module,exports){\r\n/*!\r\n * string_score.js: String Scoring Algorithm 0.1.10 \r\n *\r\n * http://joshaven.com/string_score\r\n * https://github.com/joshaven/string_score\r\n *\r\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\r\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\r\n * MIT license: http://www.opensource.org/licenses/mit-license.php\r\n *\r\n * Date: Tue Mar 1 2011\r\n*/\r\n\r\n/**\r\n * Scores a string against another string.\r\n *  'Hello World'.score('he');     //=> 0.5931818181818181\r\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\r\n */\r\nif (typeof module === 'object' && typeof define !== 'function') {\r\n\tvar define = function (factory) {\r\n\t\tmodule.exports = factory(require, exports, module);\r\n\t};\r\n}\r\n\r\ndefine(function(require, exports, module) {\r\n\treturn {\r\n\t\tscore: function(string, abbreviation, fuzziness) {\r\n\t\t\t// If the string is equal to the abbreviation, perfect match.\r\n\t\t\t  if (string == abbreviation) {return 1;}\r\n\t\t\t  //if it's not a perfect match and is empty return 0\r\n\t\t\t  if(abbreviation == \"\") {return 0;}\r\n\r\n\t\t\t  var total_character_score = 0,\r\n\t\t\t      abbreviation_length = abbreviation.length,\r\n\t\t\t      string_length = string.length,\r\n\t\t\t      start_of_string_bonus,\r\n\t\t\t      abbreviation_score,\r\n\t\t\t      fuzzies=1,\r\n\t\t\t      final_score;\r\n\t\t\t  \r\n\t\t\t  // Walk through abbreviation and add up scores.\r\n\t\t\t  for (var i = 0,\r\n\t\t\t         character_score/* = 0*/,\r\n\t\t\t         index_in_string/* = 0*/,\r\n\t\t\t         c/* = ''*/,\r\n\t\t\t         index_c_lowercase/* = 0*/,\r\n\t\t\t         index_c_uppercase/* = 0*/,\r\n\t\t\t         min_index/* = 0*/;\r\n\t\t\t     i < abbreviation_length;\r\n\t\t\t     ++i) {\r\n\t\t\t    \r\n\t\t\t    // Find the first case-insensitive match of a character.\r\n\t\t\t    c = abbreviation.charAt(i);\r\n\t\t\t    \r\n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\r\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\r\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\r\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\r\n\t\t\t    \r\n\t\t\t    if (index_in_string === -1) { \r\n\t\t\t      if (fuzziness) {\r\n\t\t\t        fuzzies += 1-fuzziness;\r\n\t\t\t        continue;\r\n\t\t\t      } else {\r\n\t\t\t        return 0;\r\n\t\t\t      }\r\n\t\t\t    } else {\r\n\t\t\t      character_score = 0.1;\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Set base score for matching 'c'.\r\n\t\t\t    \r\n\t\t\t    // Same case bonus.\r\n\t\t\t    if (string[index_in_string] === c) { \r\n\t\t\t      character_score += 0.1; \r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Consecutive letter & start-of-string Bonus\r\n\t\t\t    if (index_in_string === 0) {\r\n\t\t\t      // Increase the score when matching first character of the remainder of the string\r\n\t\t\t      character_score += 0.6;\r\n\t\t\t      if (i === 0) {\r\n\t\t\t        // If match is the first character of the string\r\n\t\t\t        // & the first character of abbreviation, add a\r\n\t\t\t        // start-of-string match bonus.\r\n\t\t\t        start_of_string_bonus = 1; //true;\r\n\t\t\t      }\r\n\t\t\t    }\r\n\t\t\t    else {\r\n\t\t\t  // Acronym Bonus\r\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\r\n\t\t\t  // preceded it with two perfect character matches.\r\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\r\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\r\n\t\t\t  }\r\n\t\t\t    }\r\n\t\t\t    \r\n\t\t\t    // Left trim the already matched part of the string\r\n\t\t\t    // (forces sequential matching).\r\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\r\n\t\t\t    \r\n\t\t\t    total_character_score += character_score;\r\n\t\t\t  } // end of for loop\r\n\t\t\t  \r\n\t\t\t  // Uncomment to weigh smaller words higher.\r\n\t\t\t  // return total_character_score / string_length;\r\n\t\t\t  \r\n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\r\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\r\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\r\n\t\t\t  \r\n\t\t\t  // Reduce penalty for longer strings.\r\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\r\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\r\n\t\t\t  \r\n\t\t\t  final_score = final_score / fuzzies;\r\n\t\t\t  \r\n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\r\n\t\t\t    final_score += 0.15;\r\n\t\t\t  }\r\n\t\t\t  \r\n\t\t\t  return final_score;\r\n\t\t}\r\n\t};\r\n});\r\n},{}]},{},[\"./lib/emmet.js\",\"./bundles/snippets.js\"])(\"./lib/emmet.js\")\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/emmet/emmet.js\n// module id = 181\n// module chunks = 24","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 318\n// module chunks = 24","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/buffer/index.js\n// module id = 319\n// module chunks = 24","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ieee754/index.js\n// module id = 624\n// module chunks = 24","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isarray/index.js\n// module id = 625\n// module chunks = 24"],"sourceRoot":""}